{"version":1581335155402,"name":"rust","data":[{"column":[{"title":"数据类型","barcolor":"","fold":false,"box":[{"title":"数据类型","fold":false,"list":[{"prefix":"","tag":"整型 ","suffix":"i32","desc":"长度|有符号|无符号\n---|:--:|---:\n8-bit|i8|u8\n16-bit|i16|u16\n32-bit|i32|u32\n64-bit|i64|u64\n128-bit|i128|u128\narch|isize|usize","url":"","summary":"数字字面值|例子\n---|:--:|\n十进制Decimal|98_222|\n十六进制Hex|0xff|\n八进制Octal|0o77|\n二进制Binary|0b1111_0000|\n字节Byte (u8 only)|b'A'|\n﻿\n注意除 byte 以外的所有数字字面值允许使用类型后缀，例如 57u8，同时也允许使用 _ 做为分隔符以方便读数，例如1_000。","reference":"数据类型|https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html","dot":""},{"prefix":"","tag":"浮点型 ","suffix":"f64","desc":"Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位，默认类型是 f64。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"布尔型 ","suffix":" bool","desc":"值：true,false","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"字符型","suffix":" char","desc":"Rust的 char 类型大小为 4 个字节，代表 Unicode标量值，这意味着它可以支持中文，日文和韩文字符等非英文字符甚至表情符号和零宽度空格在 Rust 中都是有效的 char 值。\n\nUnicode 值的范围从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF （包括两端）。 但是，\"字符\"这个概念并不存在于 Unicode 中，因此您对\"字符\"是什么的直觉可能与Rust中的字符概念不匹配。所以一般推荐使用字符串储存 UTF-8 文字（非英文字符尽可能地出现在字符串中）。\n\n注意：由于中文文字编码有两种（GBK 和 UTF-8），所以编程中使用中文字符串有可能导致乱码的出现，这是因为源程序与命令行的文字编码不一致，所以在 Rust 中字符串和字符都必须使用 UTF-8 编码，否则编译器会报错。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"元组 ","suffix":"(i1,f2,c3)","desc":"## 声明\nlet tup = (500, 6.4, 1); 异构有限。\n可以解构 let (x, y, z) = tup;\n元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。\n\n## 访问\n**tup.0** 元组元素访问\n元组长度固定：一旦声明，其长度不会增大或缩小。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"数组 ","suffix":"[t,t,t]","desc":"## 声明\nlet arr = [1, 2, 3, 4, 5]; 同构有限。\n数组中的每个元素的类型必须相同。一旦声明，它们的长度不能增长或缩小。\nlet a: [i32; 5] = [1, 2, 3, 4, 5];\n\n## 访问\n**arr[0]** 数组元素访问\n","url":"","summary":"\n\n","reference":"","dot":""}]}]},{"title":"概念","barcolor":"","fold":false,"box":[{"title":"数据引用","fold":false,"list":[{"prefix":"","tag":"基本数据","suffix":"","desc":"移动则能复制。\n\n基本数据不需要存储到堆中，仅在栈中的数据的\"移动\"方式是直接复制，这不会花费更长的时间或更多的存储空间。\n\n+ 所有整数类型，例如 i32 、 u32 、 i64 等。\n+ 布尔类型 bool，值为 true 或 false 。\n+ 所有浮点类型，f32 和 f64。\n+ 字符类型 char。\n+ 仅包含以上类型数据的元组（Tuples）。\n\n","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"其它数据","suffix":"","desc":"需要主动克隆。\n\n如果需要将数据单纯的复制一份以供他用，可以使用数据的第二种交互方式——克隆。\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = s1.clone();\n    println!(\"s1 = {}, s2 = {}\", s1, s2);\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"移动","suffix":"","desc":"其它数据的默认移动，会导致失效，包括作为参数传入函数。\n\n```rust\nlet s1 = origin  //origin不是基本数据\nlet s2 = s1 //s1被移动，失效\n```","url":"","summary":"```rust\nfn main() {\n    let s = String::from(\"hello\");\n    // s 被声明有效\n\n    takes_ownership(s);\n    // s 的值被当作参数传入函数\n    // 所以可以当作 s 已经被移动，从这里开始已经无效\n\n    let x = 5;\n    // x 被声明有效\n\n    makes_copy(x);\n    // x 的值被当作参数传入函数\n    // 但 x 是基本类型，依然有效\n    // 在这里依然可以使用 x 却不能使用 s\n\n} // 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放\n\n\nfn takes_ownership(some_string: String) {\n    // 一个 String 参数 some_string 传入，有效\n    println!(\"{}\", some_string);\n} // 函数结束, 参数 some_string 在这里释放\n\nfn makes_copy(some_integer: i32) {\n    // 一个 i32 参数 some_integer 传入，有效\n    println!(\"{}\", some_integer);\n} // 函数结束, 参数 some_integer 是基本类型, 无需释放\n```","reference":"移动问题|https://www.runoob.com/rust/rust-ownership.html","dot":""},{"prefix":"","tag":"引用","suffix":" &mut ","desc":"如果不想被移动则使用&引用。我们用 &mut 修饰可变的引用类型，**可变引用不允许多重引用**。\n```rust\nlet s1 = &origin  //s1不可修改\nlet s2 = &mut origin  //s2可修改\n```\n\n","url":"","summary":"当一个变量的值被引用时，变量本身不会被认定无效。因为\"引用\"并没有在栈中复制变量的值\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = &s1;\n    println!(\"s1 is {}, s2 is {}\", s1, s2);\n}\n```\n引用不会获得值的所有权。\n引用只能租借（Borrow）值的所有权。\n引用本身也是一个类型并具有一个值，这个值记录的是别的值所在的位置，但引用不具有所指值的所有权：\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let s2 = &s1;\n    let s3 = s1;\n    println!(\"{}\", s2);\n}\n```\n这段程序不正确：因为 s2 租借的 s1 已经将所有权移动到 s3，所以 s2 将无法继续租借使用 s1 的所有权。如果需要使用 s2 使用该值，必须重新租借：\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n    let mut s2 = &s1;\n    let s3 = s1;\n    s2 = &s3; // 重新从 s3 租借所有权\n    println!(\"{}\", s2);\n}\n```\n既然引用不具有所有权，即使它租借了所有权，它也只享有使用权（这跟租房子是一个道理）。\n如果尝试利用租借来的权利来修改数据会被阻止\n```rust\nfn main() {\n    let mut s1 = String::from(\"run\");\n    // s1 是可变的\n\n    let s2 = &mut s1;\n    // s2 是可变的引用\n\n    s2.push_str(\"oob\");\n    println!(\"{}\", s2);\n}\n```\n","reference":"","dot":""},{"prefix":"","tag":"切片 ","suffix":"&s[x..y]","desc":"切片（Slice）是对数据值的部分引用。\n```rust\nfn main() {\n    let s = String::from(\"broadcast\");\n\n    let part1 = &s[0..5];\n    let part2 = &s[5..9];\n\n    println!(\"{}={}+{}\", s, part1, part2);\n}\n```\n被切片引用的字符串禁止更改其值","url":"","summary":"","reference":"","dot":""}]}]},{"title":"结构体","barcolor":"","fold":false,"box":[{"title":"基本","fold":false,"list":[{"prefix":"","tag":"结构体","suffix":" struct Name { }","desc":"## 定义\nRust 里 struct 语句仅用来定义，不能声明实例，结尾不需要 ; 符号，而且每个字段定义之后用 , 分隔。\n```rust\nstruct Site {\n    key : String,\n}\n```\n\n## 实例\n```rust\nlet runoob = Site {\n    key : String::from('val')\n};\n```\n\n## 解构/继承\n如果正在实例化的结构体有字段名称和现存变量名称一样的，可以简化书写。\n你想要新建一个结构体的实例，其中大部分属性需要被设置成与现存的一个结构体属性一样，仅需更改其中的一两个字段的值，可以使用结构体更新语法。\n```rust\nlet site = Site {\n    name, //同名变量\n    ..something //解构另一个结构体\n};\n```\n注意：..something 后面不可以有逗号。这种语法不允许一成不变的复制另一个结构体实例，意思就是说至少重新设定一个字段的值才能引用其他实例的值。","url":"","summary":"Rust 中的结构体（Struct）与元组（Tuple）都可以将若干个类型不一定相同的数据捆绑在一起形成整体，但结构体的每个成员和其本身都有一个名字，这样访问它成员的时候就不用记住下标了。元组常用于非定义的多值传递，而结构体用于规范常用的数据结构。结构体的每个成员叫做\"字段\"。\n","reference":"","dot":""},{"prefix":"","tag":"元组结构体","suffix":" struct Color(u8, u8, u8)","desc":"有一种更简单的定义和使用结构体的方式：元组结构体。\n元组结构体是一种形式是元组的结构体。\n与元组的区别是它有名字和固定的类型格式。它存在的意义是为了处理那些需要定义类型（经常使用）又不想太复杂的简单数据：\n```rust\nstruct Color(u8, u8, u8);\nstruct Point(f64, f64);\n\nlet black = Color(0, 0, 0);\nlet origin = Point(0.0, 0.0);\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"方法","fold":false,"list":[{"prefix":"method","tag":" ","suffix":"","desc":"方法（Method）和函数（Function）类似，只不过它是用来操作结构体实例的。\n\n如果你学习过一些面向对象的语言，那你一定很清楚函数一般放在类定义里并在函数中用 this 表示所操作的实例。\n\nRust 语言不是面向对象的，从它所有权机制的创新可以看出这一点。但是面向对象的珍贵思想可以在 Rust 实现。\n\n结构体方法的第一个参数必须是 &self，不需声明类型，因为 self 不是一种风格而是关键字。\n\n计算一个矩形的面积：\n```rust\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n   \nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle { width: 30, height: 50 };\n    println!(\"rect1's area is {}\", rect1.area());\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"impl ","suffix":"$Struct","desc":"```\nimpl Rectangle {\n    fn create(width: u32, height: u32) -> Rectangle {\n        Rectangle { width, height }\n    }\n}\n```\n结构体 impl 块可以写几次，效果相当于它们内容的拼接！","url":"","summary":"","reference":"","dot":""}]},{"title":"枚举","fold":false,"list":[{"prefix":"","tag":"enum ","suffix":"$Name","desc":"```rust\nenum Book {\n    Papery(u32),\n    Electronic(String),\n}\n\nlet book = Book::Papery(1001);\nlet ebook = Book::Electronic(String::from(\"url://...\"));\n```","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"函数","barcolor":"","fold":false,"box":[]},{"title":"宏","barcolor":"","fold":false,"box":[{"title":"macro","fold":false,"list":[{"prefix":"","tag":"println!","suffix":"(str,var)","desc":"println换行，print不换行\n```rust\nfn main() {\n    let a = 12;\n    let b = 13;\n    println!(\"a is {0},b is {1}\", a,b);\n}\n```\n转义使用`{{}}`","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"包","barcolor":"","fold":false,"box":[{"title":"cargo","fold":false,"list":[{"prefix":"","tag":"cargo --version","suffix":"","desc":"检查","url":"https://www.w3cschool.cn/cargo_guide/","summary":"","reference":"","dot":""},{"prefix":"","tag":"cargo new ","suffix":"$project","desc":"## 创建项目\n+ `--lib` 制作一个包\n+ `--bin` 制作一个二进制程序\n\n## 项目结构\n+ cargo.toml和cargo.lock文件总是位于项目根目录下。\n+ src : 源代码位于src目录下。\n+ 默认的库入口文件是src/lib.rs。\n+ 默认的可执行程序入口文件是src/main.rs。\n+ 其他可选的可执行文件位于src/bin/*.rs(这里每一个rs文件均对应一个可执行文件)。\n+ 外部测试源代码文件位于tests目录下。\n+ 示例程序源代码文件位于examples。\n+ 基准测试源代码文件位于benches目录下。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"cargo check","suffix":"","desc":"该命令快速检查代码确保其可以编译，但并不产生可执行文件。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"cargo build ","suffix":" --release","desc":"cargo build ：构建项目病自动下载依赖\ncargo build --release：优化构建，将结果二进制文件放入target/release，而不再是target/debug目录.","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"cargo run","suffix":"","desc":"自动编译并运行","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"cargo test","suffix":"","desc":"测试","url":"","summary":"","reference":"","dot":""}]},{"title":"crates","fold":false,"list":[{"prefix":"","tag":"crates.io","suffix":"","desc":"","url":"https://crates.io/","summary":"","reference":"","dot":""},{"prefix":"","tag":"cargo update ","suffix":"-p $pkg","desc":"+ `cargo update`           # updates all dependencies\n+ `cargo update -p rand`   # updates just “rand”","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"cargo publish","suffix":"","desc":"","url":"https://www.w3cschool.cn/cargo_guide/cargo_guide-g1v23l60.html","summary":"","reference":"","dot":""}]},{"title":"doc","fold":false,"list":[{"prefix":"","tag":"///doc","suffix":"","desc":"/// 生成库文档，一般用于函数或者结构体的说明，置于说明对象的上方\n//! 也生成库文档，一般用于说明整个模块的功能，置于模块文件的头部","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"cargo doc","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"调试","barcolor":"","fold":false,"box":[{"title":"console","fold":false,"list":[{"prefix":"","tag":"#[derive(Debug)]","suffix":"{:#?}","desc":"调试中，完整地显示出一个结构体实例是非常有用的。但如果我们手动的书写一个格式会非常的不方便。所以 Rust 提供了一个方便地输出一整个结构体的方法：\n```rust\n#[derive(Debug)]\n\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle { width: 30, height: 50 };\n\n    println!(\"rect1 is {:?}\", rect1);\n}\n```\n如第一行所示：一定要导入调试库 `#[derive(Debug)]` ，之后在 println 和 print 宏中就可以用 `{:?}` / `{:#?}`占位符输出一整个结构体","url":"","summary":"","reference":"","dot":""}]}]},{"title":"测试","barcolor":"","fold":false,"box":[{"title":"test","fold":false,"list":[{"prefix":"","tag":"#[test]","suffix":"","desc":"Rust 中，只需要在一个函数的上面，加上 #[test] 就标明这是一个测试用的函数。\n有了这个属性之后，在使用 cargo build 编译时，就会忽略这些函数。使用 cargo test 可以运行这些函数。\n\nCargo 寻找在两个地方运行的测试 :在你src中的每个文件，和tests/中的任何测试。测试你的src文件应该是单元测试，并在tests/中的应该是整合式测试。","url":"","summary":"```rust\n#[test]\nfn it_works() {\n    assert!(false);\n}\n```","reference":"","dot":""},{"prefix":"","tag":"#[should_panic]","suffix":"","desc":"如果你的测试函数没完成，或没有更新，或是故意让它崩溃，但为了让测试能够顺利完成，我们主动可以给测试函数加上 #[should_panic] 标识，就不会让 cargo test 报错了。","url":"","summary":"```rust\n#[test]\n#[should_panic]\nfn it_works() {\n    assert!(false);\n}\n```","reference":"","dot":""},{"prefix":"","tag":"#[ignore]","suffix":"","desc":"有时候，某个测试函数非常耗时，或暂时没更新，我们想不让它参与测试，但是又不想删除它，这时， #[ignore] 就派上用场了。","url":"","summary":"```rust\n#[test]\n#[ignore]\nfn expensive_test() {\n    // code that takes an hour to run\n}\n```","reference":"","dot":""},{"prefix":"","tag":"#[cfg(test)]","suffix":"","desc":"表明这个模块是个测试模块。一个测试模块中，可以包含若干测试函数，测试模块中还可以继续包含测试模块，即模块的嵌套。","url":"","summary":"```rust\npub fn add_two(a: i32) -&gt; i32 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::add_two;\n\n    #[test]\n    fn it_works() {\n        assert_eq!(4, add_two(2));\n    }\n}\n```","reference":"参考文档|https://hardocs.com/d/rustprimer/testing/threearchtest.html","dot":""}]},{"title":"macro","fold":false,"list":[{"prefix":"","tag":"assert!","suffix":"(expr)","desc":"测试表达式是否为 true 或 false","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"assert_eq!","suffix":"(expr, expr)","desc":"测试两个表达式的结果是否相等","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"语法","barcolor":"","fold":false,"box":[{"title":"声明与作用域","fold":false,"list":[{"prefix":"","tag":"let ","suffix":"x[:type] = val","desc":"声明一个**不可变变量**，let x = 1，不可重新赋值，例如：不可执行x = 2\n但可以执行 let x = x + 1，此时x的值为2 ，此行为称之为shadowing","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"let mut ","suffix":"x[:type] = val","desc":"声明一个**可变变量**，let mut x = 1，可重新赋值，但不可改变变量类型\nmut 与 shadowing的区别是，当再次使用 let 时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"const ","suffix":"x[:type] = val","desc":"声明一个常量，const MAX\\_POINTS: u32 = 100\\_000;","url":"","summary":"1.常量可以在任何作用域中声明，包括全局作用域，\n2.常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。\n3.在声明它的作用域之中，常量在整个程序生命周期中都有效","reference":"","dot":""}]},{"title":"函数体表达式","fold":false,"list":[{"prefix":"","tag":"fn ","suffix":"fn_name() -> $type","desc":"Rust 函数名称的命名风格是小写字母以下划线分割.\nRust 函数体由一系列可以以表达式（Expression）结尾的语句（Statement）组成.\n**->** 来声明函数返回值的类型","url":"","summary":"## 表达式\n```rust\n{\n    let x = 3;\n    x + 1\n};\n```\n最后一个步骤是表达式，此表达式的结果值是整个表达式块所代表的值。这种表达式块叫做函数体表达式。注意：x + 1 之后没有分号，否则它将变成一条语句！\n\n## 嵌套\n函数可以嵌套\n```rust\nfn main() {\n    fn five() -> i32 {\n        5\n    }\n    println!(\"five() 的值为: {}\", five());\n}\n```","reference":"","dot":""},{"prefix":"","tag":"return","suffix":"","desc":"在函数体中，随时都可以以 return 关键字结束函数运行并返回一个类型合适的值。\n但是 Rust 不支持自动返回值类型判断！**如果没有明确声明函数返回值的类型，函数将被认为是\"纯过程\"，不允许产生返回值，return 后面不能有返回值表达式。**这样做的目的是为了让公开的函数能够形成可见的公报。\n注意：函数体表达式并不能等同于函数体，它不能使用 return 关键字。\n```rust\nfn add(a: i32, b: i32) -> i32 {\n    return a + b;\n}\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"条件表达式","fold":false,"list":[{"prefix":"","tag":"if..else..","suffix":"","desc":"1. 条件无需括号\n2. if 不存在单语句不用加 {} 的规则，不允许使用一个语句代替一个块\n3. Rust 中的条件表达式必须是 bool 类型\n4. if 表达式的分支必须返回同一个类型的值\n5. 在 Rust 中我们可以使用 if-else 结构实现类似于三元条件运算表达式 (A ? B : C) 的效果，但两个函数体表达式的类型必须一样！且必须有一个 else 及其后的表达式块。\n\n```rust\nfn main() {\n    let a = 3;\n    let number = if a > 0 { 1 } else { -1 };\n    println!(\"number 为 {}\", number);\n}\n```\n\n\n","url":"","summary":"## 流程表达式\nRust 中不叫流程控制语句，而是叫做流程控制表达式。\n流程表达式是可以作为右值赋值的\n```rust\n// if 表达式可以用来赋值\nlet big_n = if n < 10 && n > -10 {\n    // 分支必须返回同一个类型的值\n    10 * n\n} else if ..{\n    // 自动截取\n    n / 2\n};\n```","reference":"","dot":""},{"prefix":"","tag":"match","suffix":"","desc":"```rust\nlet boolean = true;\nlet binary = match boolean {\n    false => 0,\n    true => 1,\n};\n```","url":"","summary":"左边是模式：\n不同分支可以是不同的模式\n必须穷尽每一种可能，所以通常最后使用通配符 _\n右边是执行代码\n同样所有分支必须返回同一个值\n```rust\nlet number = 42;\nmatch number {\n    // 模式为单个值\n    0 => println!(\"Origin\"),\n    // 模式为Range\n    1...3 => println!(\"All\"),\n    // 模式为 多个值\n    | 5 | 7 | 13  => println!(\"Bad Luck\"),\n    // 绑定模式，将模式中的值绑定给一个变量，供右边执行代码使用\n    n @ 42 => println!(\"Answer is {}\", n),\n    // _ 通配符处理剩余情况\n    _ => println!(\"Common\"),\n}\n```","reference":"","dot":""}]},{"title":"循环表达式","fold":false,"list":[{"prefix":"","tag":"while ","suffix":"exp { }","desc":"while exp {..}","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"for .. in  ","suffix":"iter { }","desc":"for 循环是最常用的循环结构，常用来遍历一个线性数据据结构（比如数组）。for 循环遍历数组：\n```rust\nfn main() {\n    let a = [10, 20, 30, 40, 50];\n    for i in a.iter() {\n        println!(\"值为 : {}\", i);\n    }\n}\n```\nfor 循环其实是可以通过下标来访问数组的：\n```rust\nfn main() {\nlet a = [10, 20, 30, 40, 50];\n    for i in 0..5 {\n        println!(\"a[{}] = {}\", i, a[i]);\n    }\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"loop ","suffix":"{ break val }","desc":"loop 循环可以通过 break 关键字类似于 return 一样使整个循环退出并给予外部一个返回值。","url":"","summary":"```rust\nfn main() {\n    let s = ['R', 'U', 'N', 'O', 'O', 'B'];\n    let mut i = 0;\n    let location = loop {\n        let ch = s[i];\n        if ch == 'O' {\n            break i;\n        }\n        i += 1;\n    };\n    println!(\" \\'O\\' 的索引为 {}\", location);\n}\n```","reference":"","dot":""}]},{"title":"运算符","fold":false,"list":[{"prefix":"","tag":"x..y","suffix":"","desc":"x..y 表示 [x, y) 的数学含义\n..y 等价于 0..y\nx.. 等价于位置 x 到数据结束\n.. 等价于位置 0 到结束","url":"","summary":"","reference":"","dot":""}]}]},{"title":"其它","barcolor":"","fold":false,"box":[{"title":"安装与编译","fold":false,"list":[{"prefix":"","tag":"Install","suffix":"","desc":"","url":"","summary":"# Window安装：\n1.安装[rustup](https://www.rust-lang.org/tools/install)\n2.安装[Visual Studio 2019 生成工具](https://visualstudio.microsoft.com/zh-hans/downloads/?rr=https%3A%2F%2Fkaisery.github.io%2Ftrpl-zh-cn%2Fch01-01-installation.html)\n如出现【0x80070003系统找不到指定的路径】错误，删除C:ProgramData/package cache目录\n\n# MacOS\n```curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh```\n```xcode-select --install```","reference":"","dot":""},{"prefix":"","tag":"rustup update","suffix":"","desc":"更新","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"rustc --version","suffix":"","desc":"检查","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"rustc","suffix":" main.rs","desc":"编译","url":"","summary":"","reference":"","dot":""}]}]}]}]}