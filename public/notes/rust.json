{
    "version": 1581335155402,
    "name": "rust",
    "data": [
        {
            "column": [
                { "title": "Rust", "barcolor": "#fbca65", "fold": false, "box": [] },
                {
                    "title": "数据类型",
                    "barcolor": "",
                    "fold": false,
                    "box": [
                        {
                            "title": "数据类型",
                            "fold": false,
                            "list": [
                                {
                                    "prefix": "",
                                    "tag": "整型 ",
                                    "suffix": "i32",
                                    "desc": "i有符号,u无符号,字面值",
                                    "url": "",
                                    "summary": "长度|有符号|无符号\n---|:--:|---:\n8-bit|i8|u8\n16-bit|i16|u16\n32-bit|i32|u32\n64-bit|i64|u64\n128-bit|i128|u128\narch|isize|usize\n\n---------------\n\n数字字面值|例子\n---|:--:|\nDecimal|98_222|\nHex|0xff|\nOctal|0o77|\nBinary|0b1111_0000|\nByte (u8 only)|b'A'|\n﻿\n注意除 byte 以外的所有数字字面值允许使用类型后缀，例如 57u8，同时也允许使用 _ 做为分隔符以方便读数，例如1_000。",
                                    "reference": "数据类型|https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html",
                                    "dot": ""
                                },
                                {
                                    "prefix": "",
                                    "tag": "浮点型 ",
                                    "suffix": "f64",
                                    "desc": "f32和f64,默认f64",
                                    "url": "",
                                    "summary": "Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位。默认类型是 f64",
                                    "reference": "",
                                    "dot": ""
                                },
                                { "prefix": "", "tag": "布尔型 ", "suffix": "bool", "desc": "值：true,false", "url": "", "summary": "", "reference": "", "dot": "" },
                                {
                                    "prefix": "",
                                    "tag": "元组 ",
                                    "suffix": "",
                                    "desc": "let tup = (500, 6.4, 1); 异构有限。\ntup.0 元组元素访问",
                                    "url": "",
                                    "summary": "元组长度固定：一旦声明，其长度不会增大或缩小。\n元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。\n可以解构 let (x, y, z) = tup;",
                                    "reference": "",
                                    "dot": ""
                                },
                                {
                                    "prefix": "",
                                    "tag": "数组 ",
                                    "suffix": "",
                                    "desc": "let arr = [1, 2, 3, 4, 5]; 同构有限。\narr[0] 数组元素访问",
                                    "url": "",
                                    "summary": "数组中的每个元素的类型必须相同。\nRust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小。\n可以像这样编写数组的类型：在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。\nlet a: [i32; 5] = [1, 2, 3, 4, 5];",
                                    "reference": "",
                                    "dot": ""
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "语法",
                    "barcolor": "",
                    "fold": false,
                    "box": [
                        {
                            "title": "声明与作用域",
                            "fold": false,
                            "list": [
                                {
                                    "prefix": "",
                                    "tag": "let ",
                                    "suffix": "x[:type] = val",
                                    "desc": "声明一个不可变变量，let x = 1，不可重新赋值\n隐藏 let x = x + 1",
                                    "url": "",
                                    "summary": "声明变量后，不可重新赋值，例如：不可执行x = 2\n但可以执行 let x = x + 1，此时x的值为2 ，此行为称之为隐藏\nmut 与 隐藏的区别是，当再次使用 let 时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字。",
                                    "reference": "",
                                    "dot": ""
                                },
                                {
                                    "prefix": "",
                                    "tag": "let mut ",
                                    "suffix": "x[:type] = val",
                                    "desc": "声明一个可变变量，let mut x = 1，可重新赋值\n但不可改变变量类型",
                                    "url": "",
                                    "summary": "但不可改变变量的类型，例如下方代码将报错\nlet mut spaces = \"   \";\nspaces = spaces.len();",
                                    "reference": "",
                                    "dot": ""
                                },
                                {
                                    "prefix": "",
                                    "tag": "const ",
                                    "suffix": "x[:type] = val",
                                    "desc": "声明一个常量，const MAX_POINTS: u32 = 100_000;",
                                    "url": "",
                                    "summary": "1.常量可以在任何作用域中声明，包括全局作用域，\n2.常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。\n3.在声明它的作用域之中，常量在整个程序生命周期中都有效",
                                    "reference": "",
                                    "dot": ""
                                }
                            ]
                        },
                        {
                            "title": "条件表达式",
                            "fold": false,
                            "list": [
                                {
                                    "prefix": "",
                                    "tag": "if..else..",
                                    "suffix": "",
                                    "desc": "let x = if exp {..} else {..}\nif 表达式的分支必须返回同一个类型的值\n条件无需括号\n",
                                    "url": "",
                                    "summary": "Rust 中不叫流程控制语句，而是叫做流程控制表达式。\n流程表达式是可以作为右值赋值的\n```rust\n// if 表达式可以用来赋值\nlet big_n = if n < 10 && n > -10 {\n    // 分支必须返回同一个类型的值\n    10 * n\n} else if ..{\n    // 自动截取\n    n / 2\n};\n```",
                                    "reference": "",
                                    "dot": ""
                                },
                                {
                                    "prefix": "",
                                    "tag": "match",
                                    "suffix": "",
                                    "desc": "```rust\nlet boolean = true;\nlet binary = match boolean {\n    false => 0,\n    true => 1,\n};\n```",
                                    "url": "",
                                    "summary": "左边是模式：\n不同分支可以是不同的模式\n必须穷尽每一种可能，所以通常最后使用通配符 _\n右边是执行代码\n同样所有分支必须返回同一个值\n```rust\nlet number = 42;\nmatch number {\n    // 模式为单个值\n    0 => println!(\"Origin\"),\n    // 模式为Range\n    1...3 => println!(\"All\"),\n    // 模式为 多个值\n    | 5 | 7 | 13  => println!(\"Bad Luck\"),\n    // 绑定模式，将模式中的值绑定给一个变量，供右边执行代码使用\n    n @ 42 => println!(\"Answer is {}\", n),\n    // _ 通配符处理剩余情况\n    _ => println!(\"Common\"),\n}\n```",
                                    "reference": "",
                                    "dot": ""
                                }
                            ]
                        },
                        {
                            "title": "循环表达式",
                            "fold": false,
                            "list": [
                                {
                                    "prefix": "",
                                    "tag": "for v in o {..}",
                                    "suffix": "",
                                    "desc": "```rust\nfor n in 1..101 {\n    if n % 15 == 0 {\n        println!(\"fizzbuzz\");\n    } else if n % 3 == 0 {\n        println!(\"fizz\");\n    } else if n % 5 == 0 {\n        println!(\"buzz\");\n    } else {\n        println!(\"{}\", n);\n    }\n}\n```",
                                    "url": "",
                                    "summary": "",
                                    "reference": "",
                                    "dot": ""
                                },
                                { "prefix": "", "tag": "while", "suffix": "", "desc": "while exp {..}", "url": "", "summary": "", "reference": "", "dot": "" },
                                {
                                    "prefix": "",
                                    "tag": "loop",
                                    "suffix": "",
                                    "desc": "loop{..}\nloop 循环，相当于一个 while true，需要程序自己 break\n强调：当使用无限循环时，务必使用 loop，避免使用 while true。",
                                    "url": "",
                                    "summary": "```rust\nlet mut n = 1;\nloop {\n    if n > 101 { break; }\n    if n % 15 == 0 {\n        println!(\"fizzbuzz\");\n    } else if n % 3 == 0 {\n        println!(\"fizz\");\n    } else if n % 5 == 0 {\n        println!(\"buzz\");\n    } else {\n        println!(\"{}\", n);\n    }\n    n += 1;\n}\n```",
                                    "reference": "",
                                    "dot": ""
                                }
                            ]
                        },
                        {
                            "title": "其它",
                            "fold": true,
                            "list": [
                                {
                                    "prefix": "",
                                    "tag": "文档注释",
                                    "suffix": "",
                                    "desc": "/// 生成库文档，一般用于函数或者结构体的说明，置于说明对象的上方\n//! 也生成库文档，一般用于说明整个模块的功能，置于模块文件的头部",
                                    "url": "",
                                    "summary": "",
                                    "reference": "",
                                    "dot": ""
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "其它",
                    "barcolor": "",
                    "fold": false,
                    "box": [
                        {
                            "title": "安装与编译",
                            "fold": false,
                            "list": [
                                {
                                    "prefix": "",
                                    "tag": "Win安装说明",
                                    "suffix": "",
                                    "desc": "",
                                    "url": "",
                                    "summary": "Window安装：\n1.安装[rustup](https://www.rust-lang.org/tools/install)\n2.安装[Visual Studio 2019 生成工具](https://visualstudio.microsoft.com/zh-hans/downloads/?rr=https%3A%2F%2Fkaisery.github.io%2Ftrpl-zh-cn%2Fch01-01-installation.html)\n如出现【0x80070003系统找不到指定的路径】错误，删除C:ProgramData/package cache目录",
                                    "reference": "",
                                    "dot": ""
                                },
                                { "prefix": "", "tag": "rustup update", "suffix": "", "desc": "更新", "url": "", "summary": "", "reference": "", "dot": "" },
                                { "prefix": "", "tag": "rustc --version", "suffix": "", "desc": "检查", "url": "", "summary": "", "reference": "", "dot": "" },
                                { "prefix": "", "tag": "rustc", "suffix": " main.rs", "desc": "编译", "url": "", "summary": "", "reference": "", "dot": "" }
                            ]
                        },
                        {
                            "title": "项目构建",
                            "fold": false,
                            "list": [
                                { "prefix": "", "tag": "cargo --version", "suffix": "", "desc": "检查", "url": "", "summary": "", "reference": "", "dot": "" },
                                { "prefix": "", "tag": "cargo new ", "suffix": "pjname", "desc": "创建项目", "url": "", "summary": "", "reference": "", "dot": "" },
                                {
                                    "prefix": "",
                                    "tag": "cargo check",
                                    "suffix": "",
                                    "desc": "该命令快速检查代码确保其可以编译，但并不产生可执行文件。",
                                    "url": "",
                                    "summary": "",
                                    "reference": "",
                                    "dot": ""
                                },
                                { "prefix": "", "tag": "cargo build", "suffix": "", "desc": "构建，自动下载依赖", "url": "", "summary": "", "reference": "", "dot": "" },
                                { "prefix": "", "tag": "cargo run", "suffix": "", "desc": "构建并测试运行", "url": "", "summary": "", "reference": "", "dot": "" },
                                { "prefix": "", "tag": "cargo build --release", "suffix": "", "desc": "优化编译项目", "url": "", "summary": "", "reference": "", "dot": "" },
                                { "prefix": "", "tag": "crates", "suffix": "", "desc": "https://crates.io/", "url": "", "summary": "", "reference": "", "dot": "" },
                                {
                                    "prefix": "",
                                    "tag": "cargo update",
                                    "suffix": "",
                                    "desc": "更新依赖包升级1个版本，如为其它最新版本需手动指定依赖版本",
                                    "url": "",
                                    "summary": "",
                                    "reference": "",
                                    "dot": ""
                                }
                            ]
                        },
                        { "title": "相关链接", "fold": false, "list": [] }
                    ]
                }
            ]
        }
    ]
}
