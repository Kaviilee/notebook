{"version":1582448803761,"name":"other","data":[{"column":[{"title":"C/C++","barcolor":"#9ce076","fold":false,"box":[]},{"title":"数据类型","barcolor":"","fold":false,"box":[{"title":"数据类型","fold":false,"list":[{"prefix":"","tag":"整型 ","suffix":"int","desc":"","url":"","summary":"类型|\t位|\t范围\n---|:--:|---:\nint|\t4 个字节|\t-2147483648 到 2147483647\nunsigned int|\t4 个字节|\t0 到 4294967295\nsigned int|\t4 个字节|\t-2147483648 到 2147483647\nshort int|\t2 个字节|\t-32768 到 32767\nunsigned short int|\t2 个字节|\t0 到 65,535\nsigned short int|\t2 个字节\t|-32768 到 32767\nlong int|\t8 个字节|\t-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807\nsigned long int|\t8 个字节|\t-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807\nunsigned long int|\t8 个字节|\t0 到 18,446,744,073,709,551,615","reference":"","dot":"","title":"数学"},{"prefix":"","tag":"浮点型 ","suffix":"float / double","desc":"","url":"","summary":"类型|\t位|\t范围\n---|:--:|---:\nfloat|\t4 个字节|\t精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)\ndouble|\t8 个字节|\t双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)\nlong double|\t16 个字节|\t长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。","reference":"","dot":""},{"prefix":"","tag":"布尔型 ","suffix":"bool","desc":"值：true,false","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"字符型 ","suffix":"char / wchar_t","desc":"","url":"","summary":"类型|\t位|\t范围\n---|:--:|---:\nchar|\t1 个字节|\t-128 到 127 或者 0 到 255\nunsigned char|\t1 个字节|\t0 到 255\nsigned char|\t1 个字节|\t-128 到 127\nwchar_t|\t2 或 4 个字节|\t1 个宽字符","reference":"","dot":""},{"prefix":"","tag":"无类型 ","suffix":"void","desc":"函数返回为空，函数参数为空，指针指向 void","url":"","summary":"void 类型指定没有可用的值。它通常用于以下三种情况下：\n1. 函数返回为空。C中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);\n2. 函数参数为空。C中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);\n3. 指针指向 void。类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。","reference":"","dot":""},{"prefix":"","tag":"字符串","suffix":"","desc":"char $str[] = \"string\" 一串字符串 ","url":"","summary":"字符串实际上是使用 null 字符 '\\0' 终止的一维字符数组\n由于在数组的末尾存储了空字符，所以字符数组(非字符串)的大小比字符串的字符数多一个","reference":"","dot":""},{"prefix":"","tag":"数组 ","suffix":"","desc":"<table>\n    <tr>\n        <th>数组</th>\n        <th>表示</th>\n    </tr>\n    <tr>\n        <td>一维数组 $arr[i]</td>\n        <td>$type $arr[len] = {,..}</td>\n    </tr>\n    <tr>\n        <td>二维数组 $arr[i][j]</td>\n        <td>$type $arr[len][len] = { {..},{..}..}</td>\n    </tr>\n</table>","url":"","summary":"<table>\n    <caption>const与指针</caption>\n    <tr>\n        <th>形式</th>\n        <th>说明</th>\n        <th>*号位置</th>\n    </tr>\n    <tr>\n        <td>int const* ptr</td>\n        <td>变量仅仅只作为指针，不能通过指针改变原地址的值(参数传值用)</td>\n        <td>*在const之后</td>\n    </tr>\n    <tr>\n        <td>int *const ptr</td>\n        <td>一个地址不能改变的指针，无法修改指针的值(存的内存地址)</td>\n        <td>*在const之前</td>\n    </tr>\n</table>\n\n1.数组变量是一个*const指针，固定指向了某个数组（存的是第一个元素的地址），故不可被赋值，故也不能够数组变量交换赋值（需要复制数组时必须遍历）。 <br>\n2.故当一个指针变量被数组变量或字符串变量赋值时，无需添加&取地址符，对其的求值，也无需使用*间接访问运算符 <br>\n3.故*和[]即可对指针做运算，也可对数组变量做运算\n\n<hr>\n\n1.函数参数表中的数组参数实际上也只是指针，故无法通过sizeof获取长度，必须手动传入数组长度。<br>\n2.当传入函数参数禁止该指针对原数据进行修改时，则使用const*指针","reference":"","dot":""},{"prefix":"","tag":"枚举 ","suffix":"enum","desc":"enum color { red, green, blue } ;\n默认第一个值为0，依次+1","url":"","summary":"如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。\n```\nenum 枚举名{ \n     标识符[=整型常数], \n     标识符[=整型常数], \n... \n    标识符[=整型常数]\n} 枚举变量;\n```\n```\nenum color { red, green, blue } ;\ncolor c = blue;\ncout << c << endl;\n//c的值为2\n```","reference":"","dot":""},{"prefix":"","tag":"指针 ","suffix":"*ptr","desc":"int  var = 20; 实际变量的声明\nint  *ip; 指针变量的声明\nip = &var; 在指针变量中存储","url":"","summary":"在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。\nNULL 指针是一个定义在标准库中的值为零的常量。\n<table>\n    <tbody>\n        <tr>\n            <th>大小</th>\n            <th>位数</th>\n            <th>16进制地址</th>\n        </tr>\n        <tr>\n            <td>4字节</td>\n            <td>32位</td>\n            <td>0x0062fe44</td>\n        </tr>\n        <tr>\n            <td>8字节</td>\n            <td>64位</td>\n            <td></td>\n        </tr>\n    </tbody>\n</table>","reference":"","dot":""},{"prefix":"","tag":"结构体 ","suffix":"struct","desc":"struct $obj {$type $var;..} [$_var]; \nstruct Book {char title[10];..} book1; \n结构名并不是地址，必须通过&取","url":"","summary":"**.** 结构体成员访问运算符\n定义结构体： struct Books {...}\n声明变量Book1，类型为结构体Books： struct Books Book1\n访问Book1成员：Book1.prop\n\n-----------\n\n**->** 指针访问结构的成员\n定义结构体： struct Books {...}\n声明变量Book1，类型为结构体Books： struct Books Book1 \n定义指向结构的指针： struct Books *ptr\n赋值指针地址： ptr = &Book1\n访问指针指向地址结构体的成员：ptr->prop\n\n-----------\n\n位域\nstruct 位域结构名 {类型说明符 位域名:位域长度;..} [变量名];\nstruct Book {int page:8;..} book1;","reference":"","dot":""},{"prefix":"","tag":"共用体 ","suffix":"union","desc":"union 共用体标识符 {类型说明符 成员名;..}[变量名]; \n共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型\n共用体占用的内存应足够存储共用体中最大的成员","url":"","summary":"","reference":"","dot":""}]},{"title":"类型检测","fold":false,"list":[{"prefix":"","tag":"typeid(var).name()","suffix":"","desc":"返回变量的类型\n\\#include \\<typeinfo>  （后面无分号）","url":"","summary":"","reference":"","dot":""}]},{"title":"类型方法","fold":false,"list":[{"prefix":"","tag":"typedef ","suffix":"old new","desc":"为一个已有的类型取一个新的名字\ntypedef int feet;\nfeet distance;","url":"","summary":"typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。\ntypedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。","reference":"","dot":""},{"prefix":"","tag":"$type","suffix":"(var)","desc":"强制类型转换","url":"","summary":"var3 = (double) var2 / var1\n这里要注意的是强制类型转换运算符的优先级大于除法\n如果一个运算符两边的运算数类型不同，先要将其转换为相同的类型，即较低类型转换为较高类型，然后再参加运算","reference":"","dot":""}]}]},{"title":"语法","barcolor":"","fold":false,"box":[{"title":"声明与作用域","fold":false,"list":[{"prefix":"","tag":"type ","suffix":"x = val","desc":"定义一个变量，建立了存储空间\nint zero = 0 定义变量并初始化","url":"","summary":"当局部变量被定义时，系统不会对其初始化，须自行对其初始化。\n定义全局变量时，系统会自动对其初始化。\n<table>\n    <tr>\n        <th>类型</th>\n        <th>初始化默认值</th>\n    </tr>\n    <tr>\n        <td>int</td>\n        <td>0</td>\n    </tr>\n    <tr>\n        <td>char</td>\n        <td>'\\0'</td>\n    </tr>\n    <tr>\n        <td>float</td>\n        <td>0</td>\n    </tr>\n    <tr>\n        <td>double</td>\n        <td>0</td>\n    </tr>\n    <tr>\n        <td>pointer</td>\n        <td>NULL</td>\n    </tr>\n</table>","reference":"","dot":""},{"prefix":"","tag":"const ","suffix":"type x = val","desc":"定义一个常量","url":"","summary":"","reference":"#define与const区别|https://blog.csdn.net/qq_26685237/article/details/79587445","dot":""},{"prefix":"type ","tag":"*ptr = ","suffix":"&var","desc":"*ptr在声明语句中为声明，在执行语句中返回该指针变量所指向的对象的值","url":"","summary":"*：\n1.声明语句中，用于指针变量声明： \n*ptr = NULL/0 \n\\*ptr = &var\n需要被赋值一个内存地址\n2.执行语句中，作为间接访问运算符：\nprint(\"%d\",*ptr) \n**要求运算对象是地址量(指针变量),返回值是该指针变量所指向的对象的值**\n\n------------\n\n&：\n取地址运算符，返回变量的地址\n&变量名 或 &数组元素名\n&运算符的操作数必须是一个变量，不能把地址运算符用于常量、表达式或存储类别为register型的变量上","reference":"","dot":""},{"prefix":"","tag":"type& x ","suffix":"= var","desc":"c++:引用就是另一个变量的别名\nint i = 17;\nint& r = i;","url":"","summary":"引用很容易与指针混淆，它们之间有三个主要的不同：\n1. 不存在空引用。引用必须连接到一块合法的内存。\n2. 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。\n3. 引用必须在创建时被初始化。指针可以在任何时间被初始化。","reference":"","dot":""}]},{"title":"修饰符","fold":true,"list":[{"prefix":"","tag":"volatile ","suffix":"var","desc":"不需要优化volatile声明的变量，让程序可以直接从内存中读取变量","url":"","summary":"修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。","reference":"","dot":""},{"prefix":"","tag":"restrict ","suffix":"*ptr","desc":"由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式","url":"","summary":"","reference":"","dot":""}]},{"title":"存储类","fold":true,"list":[{"prefix":"","tag":"extern ","suffix":"var","desc":"定义外部变量，不指定存储类别。\n存储在全局数据区，全局生存期，全局作用域。","url":"","summary":"extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。\n\n当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。\n\nextern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候","reference":"","dot":""},{"prefix":"","tag":"register ","suffix":"var","desc":"只对内部变量有效，存储在寄存器，自动生存期、局部作用域。","url":"","summary":"register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。","reference":"","dot":""},{"prefix":"","tag":"static ","suffix":"var","desc":"static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。\nstatic 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。","url":"","summary":"1.定义局部变量时\n存储在全局数据区，全局生存期，全局作用域\n2.定义在函数外面时\n存储在全局数据区，全局生存期，但为文件作用域，即作用域限制在声明它的文件内，外部无法使用extern引用。","reference":"","dot":""},{"prefix":"","tag":"thread_local ","suffix":"var","desc":"","url":"","summary":"使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。\nthread_local 说明符可以与 static 或 extern 合并。\n可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。\n","reference":"","dot":""},{"prefix":"","tag":"auto ","suffix":"var","desc":"只对内部变量有效，存在在内存栈区，自动生存期，局部作用域。\n","url":"","summary":"声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。\n从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符","reference":"","dot":""}]},{"title":"运算符","fold":true,"list":[{"prefix":"","tag":"算术运算符","suffix":"","desc":"加法运算符：x + y\n减法运算符： x - y\n乘法运算符： x * y\n除法运算符：x / y\n余数运算符：x % y\n自增运算符：++x 或者 x++\n自减运算符：--x 或者 x--","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"关系运算符","suffix":"","desc":"\\> 大于运算符\n\\< 小于运算符\n>= 大于或等于运算符\n<= 小于或等于运算符\n== 相等运算符\n!= 不相等运算符","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"逻辑运算符","suffix":"","desc":"取反运算符：!\n且运算符：&&\n或运算符：||\n三元运算符：?:","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"位运算符","suffix":"","desc":"| 按位或\n& 按位与\n~ 按位取反\n^ 按位异或\n\\<< 左移运算符 \n\n>> 右移运算符\n","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"赋值运算符","suffix":"","desc":"+= -= *= **= /= %= &= |= ^= <<= >>=","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"逗号运算符","suffix":"","desc":"会顺序执行一系列运算。\n整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。","url":"","summary":"","reference":"","dot":""}]},{"title":"预处理器","fold":true,"list":[{"prefix":"","tag":"#define ","suffix":"x val","desc":"定义一个常量或参数宏\n\\#define PI 3.14\n\\#define MIN(a,b) (a<b ? a : b)","url":"","summary":"1.带参数的宏，参数与整体都应加括号\n2.宏定义不应加分号\n3.宏定义没有类型检查\n4.由宏定义函数会被反复展开，以空间换区效率","reference":"","dot":""},{"prefix":"","tag":"#ifdef","suffix":"","desc":"","url":"","summary":"\\#ifdef | \\#ifndef\n如果宏已经定义，则返回真\n如果宏没有定义，则返回真\n------------\n\\#if | \\#else | \\#elif\n如果给定条件为真，则编译下面代码\n#if 的替代方案\n如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码\n------------\n\\#endif\n结束一个带if的条件编译块\n------------\n\\#undef\n取消已定义的宏","reference":"","dot":""},{"prefix":"","tag":"#error","suffix":"","desc":"当遇到标准错误时，输出错误消息","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"#pragma","suffix":"","desc":"使用标准化方法，向编译器发布特殊的命令到编译器中","url":"","summary":"","reference":"","dot":""}]},{"title":"流程控制","fold":false,"list":[{"prefix":"","tag":"if..else..","suffix":"","desc":"if(exp){...} //仅有一个语句时，可省略{}\nif(exp){...}else{...}\nif(exp){...}else if(exp){...}","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"switch","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"x?y:z","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"循环语句","fold":false,"list":[{"prefix":"","tag":"while","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"do..while","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"for","suffix":"","desc":"for(init;condition;increment){..}","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"break","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"continue","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"label:","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"goto ","suffix":"label","desc":"将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句","url":"","summary":"","reference":"","dot":""}]}]},{"title":"全局","barcolor":"","fold":false,"box":[{"title":"方法/语句","fold":false,"list":[{"prefix":"","tag":"sizeof","suffix":"(var)","desc":"返回变量的大小，静态运算符，不会对表示式做运算","url":"","summary":"例如，sizeof(a) 将返回 4，其中 a 是整数。","reference":"","dot":""}]},{"title":"预定义宏","fold":true,"list":[{"prefix":"","tag":"__DATE__","suffix":"","desc":"当前日期，一个以 \"MMM DD YYYY\" 格式表示的字符常量","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"__TIME__","suffix":"","desc":"当前时间，一个以 \"HH:MM:SS\" 格式表示的字符常量","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"__FILE__","suffix":"","desc":"当前文件名，一个字符串常量","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"__LINE__","suffix":"","desc":"当前行号，一个十进制常量","url":"","summary":"","reference":"","dot":""}]}]},{"title":"其它","barcolor":"","fold":false,"box":[{"title":"安装与编译","fold":false,"list":[{"prefix":"","tag":"g++ -v","suffix":"","desc":"程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"g++ ","suffix":"file -o outfile","desc":"g++ helloworld.cpp -o helloworld","url":"","summary":"使用 -o 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件\n\n选项|解释\n---|:--:|\n-ansi|只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。\n-c|只编译并生成目标文件。\n-DMACRO|以字符串\"1\"定义 MACRO 宏。\n-DMACRO=DEFN|以字符串\"DEFN\"定义 MACRO 宏。\n-E\t|只运行 C 预编译器。\n-g\t|生成调试信息。GNU 调试器可利用该信息。\n-IDIRECTORY\t|指定额外的头文件搜索路径DIRECTORY。\n-LDIRECTORY\t|指定额外的函数库搜索路径DIRECTORY。\n-lLIBRARY\t|连接时搜索指定的函数库LIBRARY。\n-m486\t|针对 486 进行代码优化。\n-o\t|FILE 生成指定的输出文件。用在生成可执行文件时。\n-O0\t|不进行优化处理。\n-O\t|或 -O1 优化生成代码。\n-O2\t|进一步优化。\n-O3\t|比 -O2 更进一步优化，包括 inline 函数。\n-shared\t|生成共享目标文件。通常用在建立共享库时。\n-static\t|禁止使用共享连接。\n-UMACRO\t|取消对 MACRO 宏的定义。\n-w\t|不生成任何警告信息。\n-Wall\t|生成所有警告信息。","reference":"","dot":""}]}]}]},{"column":[{"title":"Java","barcolor":"#e09aff","fold":false,"box":[]},{"title":"数据类型","barcolor":"","fold":false,"box":[{"title":"数据类型","fold":false,"list":[{"prefix":"","tag":"整型 ","suffix":"int","desc":"byte,short,int,long\n默认值0,0,0,0L","url":"","summary":"byte：\nbyte 数据类型是8位、有符号的，以二进制补码表示的整数；\n最小值是 -128（-2^7）；\n最大值是 127（2^7-1）；\n默认值是 0；\nbyte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n例子：byte a = 100，byte b = -50。\n---------------\nshort：\nshort 数据类型是 16 位、有符号的以二进制补码表示的整数\n最小值是 -32768（-2^15）；\n最大值是 32767（2^15 - 1）；\nShort 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n默认值是 0；\n例子：short s = 1000，short r = -20000。\n---------------\nint：\nint 数据类型是32位、有符号的以二进制补码表示的整数；\n最小值是 -2,147,483,648（-2^31）；\n最大值是 2,147,483,647（2^31 - 1）；\n一般地整型变量默认为 int 类型；\n默认值是 0 ；\n例子：int a = 100000, int b = -200000。\n---------------\nlong：\nlong 数据类型是 64 位、有符号的以二进制补码表示的整数；\n最小值是 -9,223,372,036,854,775,808（-2^63）；\n最大值是 9,223,372,036,854,775,807（2^63 -1）；\n这种类型主要使用在需要比较大整数的系统上；\n默认值是 0L；\n例子： long a = 100000L，Long b = -200000L。\n\"L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩。所以最好大写。","reference":"","dot":""},{"prefix":"","tag":"浮点型 ","suffix":"float / double","desc":"float,默认值是 0.0f\ndouble,默认值是 0.0d","url":"","summary":"float：\nfloat 数据类型是单精度、32位、符合IEEE 754标准的浮点数；\nfloat 在储存大型浮点数组的时候可节省内存空间；\n默认值是 0.0f；\n浮点数不能用来表示精确的值，如货币；\n例子：float f1 = 234.5f。\n----------------\ndouble：\ndouble 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；\n浮点数的默认类型为double类型；\ndouble类型同样不能表示精确的值，如货币；\n默认值是 0.0d；\n例子：double d1 = 123.4。","reference":"","dot":""},{"prefix":"","tag":"布尔型 ","suffix":"boolean","desc":"值：true,false","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"字符型 ","suffix":"char","desc":"默认值：'u0000'","url":"","summary":"字节型，byte 数据类型是8位、有符号的，以二进制补码表示的整数\n字符型，char类型是一个单一的 16 位 Unicode 字符","reference":"","dot":""},{"prefix":"","tag":"字符串 ","suffix":"String","desc":"默认值null","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"数组","suffix":"","desc":"new type[len] = {val..}","url":"","summary":"","reference":"","dot":""}]},{"title":"类型检测","fold":false,"list":[{"prefix":"x ","tag":"instanceof ","suffix":"y","desc":"检查该对象是否是一个特定类型（类类型或接口类型）","url":"","summary":"","reference":"","dot":""}]},{"title":"类型转换","fold":false,"list":[{"prefix":"","tag":"(type) ","suffix":"x","desc":"强制类型转换条件是转换的数据类型必须是兼容的","url":"","summary":"自动类型转换中必须满足转换前的数据类型的位数要低于转换后的数据类型。\n整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。转换从低级到高级。\nbyte,short,char—> int —> long—> float —> double \n-----------\n1. 不能对boolean类型进行类型转换。\n2. 不能把对象类型转换成不相关类的对象。\n3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。\n4. 转换过程中可能导致溢出或损失精度\n5. **浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入**","reference":"","dot":""}]}]},{"title":"语法","barcolor":"","fold":false,"box":[{"title":"声明与作用域","fold":false,"list":[{"prefix":"","tag":"type ","suffix":"x = val","desc":"声明变量","url":"","summary":"# 局部变量\n局部变量声明在方法、构造方法或者语句块中；\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；\n**访问修饰符不能用于局部变量；**\n局部变量只在声明它的方法、构造方法或者语句块中可见；\n局部变量是在栈上分配的。\n**局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。**\n\n---------------\n\n# 实例变量\n实例变量声明在一个类中，但在方法、构造方法和语句块之外；\n当一个对象被实例化之后，每个实例变量的值就跟着确定；\n实例变量在对象创建的时候创建，在对象被销毁的时候销毁；\n实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；\n实例变量可以声明在使用前或者使用后；\n访问修饰符可以修饰实例变量；\n实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\n实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；\n实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。\n\n---------------\n\n# 类变量（静态变量）\n类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。\n无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。\n静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。\n静态变量在第一次被访问时创建，在程序结束时销毁。\n与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。\n默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n静态变量可以通过：ClassName.VariableName的方式访问。\n类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。","reference":"","dot":""},{"prefix":"","tag":"final ","suffix":"x = val","desc":"声明常量","url":"","summary":"","reference":"","dot":""}]},{"title":"访问修饰符","fold":true,"list":[{"prefix":"","tag":"default","suffix":"","desc":"在同一包内可见，不使用任何修饰符。\n使用对象：类、接口、变量、方法。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"public","suffix":"","desc":"对所有类可见。\n使用对象：类、接口、变量、方法","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"protected","suffix":"","desc":"对同一包内的类和所有子类可见。\n使用对象：变量、方法。 注意：不能修饰类（外部类）。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"private","suffix":"","desc":"在同一类内可见。\n使用对象：变量、方法。 注意：不能修饰类（外部类）","url":"","summary":"","reference":"","dot":""}]},{"title":"非访问修饰符","fold":true,"list":[{"prefix":"","tag":"static","suffix":"","desc":"用来修饰类方法和类变量。\n无论一个类实例化多少对象，它的静态变量只有一份拷贝。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"final","suffix":"","desc":"用来修饰类、方法和变量\nfinal 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。\n被 final 修饰的实例变量必须显式指定初始值。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"abstract","suffix":"","desc":"用来创建抽象类和抽象方法","url":"","summary":"抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。\n一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。","reference":"","dot":""},{"prefix":"","tag":"synchronized","suffix":"","desc":"同一时间只能被一个线程访问","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"volatile","suffix":"","desc":"volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"transient","suffix":"","desc":"序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。\n该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。","url":"","summary":"","reference":"","dot":""}]},{"title":"运算符","fold":true,"list":[{"prefix":"","tag":"算术运算符","suffix":"","desc":"加法运算符：x + y\n减法运算符： x - y\n乘法运算符： x * y\n除法运算符：x / y\n余数运算符：x % y\n自增运算符：++x 或者 x++\n自减运算符：--x 或者 x--","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"关系运算符","suffix":"","desc":"\\> 大于运算符\n\\< 小于运算符\n>= 大于或等于运算符\n<= 小于或等于运算符\n== 相等运算符\n!= 不相等运算符","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"逻辑运算符","suffix":"","desc":"取反运算符：!\n且运算符：&&\n或运算符：||","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"位运算符","suffix":"","desc":"| 按位或\n& 按位与\n~ 按位取反\n^ 按位异或\n\\<< 左移运算符 \n\n>> 右移运算符\n\n\\>>> 头部补零的右移运算符","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"赋值运算符","suffix":"","desc":"+= -= *= **= /= %= &= |= ^= <<= >>=","url":"","summary":"","reference":"","dot":""}]},{"title":"流程控制","fold":false,"list":[{"prefix":"","tag":"if..else","suffix":"","desc":"if(exp){...} \nif(exp){...}else{...}\nif(exp){...}else if(exp){...}","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"switch","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"循环语句","fold":false,"list":[{"prefix":"","tag":"while","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"do..while","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"for","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"break","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"continue","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]}]},{"title":"其它","barcolor":"","fold":false,"box":[{"title":"安装与编译","fold":false,"list":[{"prefix":"","tag":"javac ","suffix":"file","desc":"编译file.java\njava文件需以gbk编码保存","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"java ","suffix":"file","desc":"执行file.class","url":"","summary":"","reference":"","dot":""}]},{"title":"开发环境","fold":false,"list":[{"prefix":"","tag":"dev","suffix":"","desc":"","url":"","summary":"1. 下载[jdk](https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html)\n2. [环境变量设置](https://www.liaoxuefeng.com/wiki/1252599548343744/1280507291631649)\n新建系统变量**JAVA_HOME**，变量值`C:\\Program Files\\Java\\jdk-15`\n编辑系统变量 Path，添加变量值：`Path=%JAVA_HOME%\\bin;`\n3. 下载[maven](https://maven.apache.org/download.cgi)\n4. [环境变量设置](https://www.runoob.com/maven/maven-setup.html)\n新建系统变量 MAVEN_HOME，变量值：`E:\\Maven\\apache-maven-3.3.9`\n编辑系统变量 Path，添加变量值：`;%MAVEN_HOME%\\bin`\n5. vscode插件\nJava Extension Pack\nSpring Boot Extension Pack\n6. vscode配置\n```\n\"java.home\":\"C:\\\\Program Files\\\\Java\\\\jdk-13.0.2\",\n\"maven.executable.path\": \"D:\\\\Code\\\\apache-maven-3.8.1\\\\bin\\\\mvn.cmd\",\n\"maven.terminal.useJavaHome\": true,\n\"maven.terminal.customEnv\": [\n    {\n        \"environmentVariable\": \"JAVA_HOME\",\n        \"value\": \"C:\\\\Program Files\\\\Java\\\\jdk-13.0.2\"\n    }\n],\n\"java.configuration.maven.userSettings\": \"D:\\\\Code\\\\apache-maven-3.8.1\\\\conf\\\\settings.xml\",\n```\n6. 设置mirror\n修改maven/conf/settings.xml\n```\n<mirror>\n    <id>alimaven</id>\n    <mirrorOf>central</mirrorOf>\n    <name>aliyun maven</name>\n    <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>\n</mirror>\n<mirror>\n    <id>nexus-aliyun</id>\n    <mirrorOf>*</mirrorOf>\n    <name>Nexus aliyun</name>\n    <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n</mirror>\n<!-- 中央仓库1 -->\n<mirror>\n    <id>repo1</id>\n    <mirrorOf>central</mirrorOf>\n    <name>Human Readable Name for this Mirror.</name>\n    <url>http://repo1.maven.org/maven2/</url>\n</mirror>\n\n<!-- 中央仓库2 -->\n<mirror>\n    <id>repo2</id>\n    <mirrorOf>central</mirrorOf>\n    <name>Human Readable Name for this Mirror.</name>\n    <url>http://repo2.maven.org/maven2/</url>\n</mirror>\n```","reference":"","dot":""}]}]}]},{"column":[{"title":"Rust","barcolor":"#fbca65","fold":false,"box":[]},{"title":"数据类型","barcolor":"","fold":false,"box":[{"title":"数据类型","fold":false,"list":[{"prefix":"","tag":"整型 ","suffix":"i32","desc":"i有符号,u无符号,字面值","url":"","summary":"长度|有符号|无符号\n---|:--:|---:\n8-bit|i8|u8\n16-bit|i16|u16\n32-bit|i32|u32\n64-bit|i64|u64\n128-bit|i128|u128\narch|isize|usize\n\n---------------\n\n数字字面值|例子\n---|:--:|\nDecimal|98_222|\nHex|0xff|\nOctal|0o77|\nBinary|0b1111_0000|\nByte (u8 only)|b'A'|\n﻿\n注意除 byte 以外的所有数字字面值允许使用类型后缀，例如 57u8，同时也允许使用 _ 做为分隔符以方便读数，例如1_000。","reference":"数据类型|https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html","dot":""},{"prefix":"","tag":"浮点型 ","suffix":"f64","desc":"f32和f64,默认f64","url":"","summary":"Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位。默认类型是 f64","reference":"","dot":""},{"prefix":"","tag":"布尔型 ","suffix":"bool","desc":"值：true,false","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"元组 ","suffix":"","desc":"let tup = (500, 6.4, 1); 异构有限。\ntup.0 元组元素访问","url":"","summary":"元组长度固定：一旦声明，其长度不会增大或缩小。\n元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的。\n可以解构 let (x, y, z) = tup;","reference":"","dot":""},{"prefix":"","tag":"数组 ","suffix":"","desc":"let arr = [1, 2, 3, 4, 5]; 同构有限。\narr[0] 数组元素访问","url":"","summary":"数组中的每个元素的类型必须相同。\nRust 中的数组是固定长度的：一旦声明，它们的长度不能增长或缩小。\n可以像这样编写数组的类型：在方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量。\nlet a: [i32; 5] = [1, 2, 3, 4, 5];","reference":"","dot":""}]}]},{"title":"语法","barcolor":"","fold":false,"box":[{"title":"声明与作用域","fold":false,"list":[{"prefix":"","tag":"let ","suffix":"x[:type] = val","desc":"声明一个不可变变量，let x = 1，不可重新赋值\n隐藏 let x = x + 1","url":"","summary":"声明变量后，不可重新赋值，例如：不可执行x = 2\n但可以执行 let x = x + 1，此时x的值为2 ，此行为称之为隐藏\nmut 与 隐藏的区别是，当再次使用 let 时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字。","reference":"","dot":""},{"prefix":"","tag":"let mut ","suffix":"x[:type] = val","desc":"声明一个可变变量，let mut x = 1，可重新赋值\n但不可改变变量类型","url":"","summary":"但不可改变变量的类型，例如下方代码将报错\nlet mut spaces = \"   \";\nspaces = spaces.len();","reference":"","dot":""},{"prefix":"","tag":"const ","suffix":"x[:type] = val","desc":"声明一个常量，const MAX_POINTS: u32 = 100_000;","url":"","summary":"1.常量可以在任何作用域中声明，包括全局作用域，\n2.常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值。\n3.在声明它的作用域之中，常量在整个程序生命周期中都有效","reference":"","dot":""}]},{"title":"条件表达式","fold":false,"list":[{"prefix":"","tag":"if..else..","suffix":"","desc":"let x = if exp {..} else {..}\nif 表达式的分支必须返回同一个类型的值\n条件无需括号\n","url":"","summary":"Rust 中不叫流程控制语句，而是叫做流程控制表达式。\n流程表达式是可以作为右值赋值的\n```rust\n// if 表达式可以用来赋值\nlet big_n = if n < 10 && n > -10 {\n    // 分支必须返回同一个类型的值\n    10 * n\n} else if ..{\n    // 自动截取\n    n / 2\n};\n```","reference":"","dot":""},{"prefix":"","tag":"match","suffix":"","desc":"```rust\nlet boolean = true;\nlet binary = match boolean {\n    false => 0,\n    true => 1,\n};\n```","url":"","summary":"左边是模式：\n不同分支可以是不同的模式\n必须穷尽每一种可能，所以通常最后使用通配符 _\n右边是执行代码\n同样所有分支必须返回同一个值\n```rust\nlet number = 42;\nmatch number {\n    // 模式为单个值\n    0 => println!(\"Origin\"),\n    // 模式为Range\n    1...3 => println!(\"All\"),\n    // 模式为 多个值\n    | 5 | 7 | 13  => println!(\"Bad Luck\"),\n    // 绑定模式，将模式中的值绑定给一个变量，供右边执行代码使用\n    n @ 42 => println!(\"Answer is {}\", n),\n    // _ 通配符处理剩余情况\n    _ => println!(\"Common\"),\n}\n```","reference":"","dot":""}]},{"title":"循环表达式","fold":false,"list":[{"prefix":"","tag":"for v in o {..}","suffix":"","desc":"```rust\nfor n in 1..101 {\n    if n % 15 == 0 {\n        println!(\"fizzbuzz\");\n    } else if n % 3 == 0 {\n        println!(\"fizz\");\n    } else if n % 5 == 0 {\n        println!(\"buzz\");\n    } else {\n        println!(\"{}\", n);\n    }\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"while","suffix":"","desc":"while exp {..}","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"loop","suffix":"","desc":"loop{..}\nloop 循环，相当于一个 while true，需要程序自己 break\n强调：当使用无限循环时，务必使用 loop，避免使用 while true。","url":"","summary":"```rust\nlet mut n = 1;\nloop {\n    if n > 101 { break; }\n    if n % 15 == 0 {\n        println!(\"fizzbuzz\");\n    } else if n % 3 == 0 {\n        println!(\"fizz\");\n    } else if n % 5 == 0 {\n        println!(\"buzz\");\n    } else {\n        println!(\"{}\", n);\n    }\n    n += 1;\n}\n```","reference":"","dot":""}]},{"title":"其它","fold":true,"list":[{"prefix":"","tag":"文档注释","suffix":"","desc":"/// 生成库文档，一般用于函数或者结构体的说明，置于说明对象的上方\n//! 也生成库文档，一般用于说明整个模块的功能，置于模块文件的头部","url":"","summary":"","reference":"","dot":""}]}]},{"title":"其它","barcolor":"","fold":false,"box":[{"title":"安装与编译","fold":false,"list":[{"prefix":"","tag":"Win安装说明","suffix":"","desc":"","url":"","summary":"Window安装：\n1.安装[rustup](https://www.rust-lang.org/tools/install)\n2.安装[Visual Studio 2019 生成工具](https://visualstudio.microsoft.com/zh-hans/downloads/?rr=https%3A%2F%2Fkaisery.github.io%2Ftrpl-zh-cn%2Fch01-01-installation.html)\n如出现【0x80070003系统找不到指定的路径】错误，删除C:ProgramData/package cache目录","reference":"","dot":""},{"prefix":"","tag":"rustup update","suffix":"","desc":"更新","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"rustc --version","suffix":"","desc":"检查","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"rustc","suffix":" main.rs","desc":"编译","url":"","summary":"","reference":"","dot":""}]},{"title":"项目构建","fold":false,"list":[{"prefix":"","tag":"cargo --version","suffix":"","desc":"检查","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"cargo new ","suffix":"pjname","desc":"创建项目","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"cargo check","suffix":"","desc":"该命令快速检查代码确保其可以编译，但并不产生可执行文件。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"cargo build","suffix":"","desc":"构建，自动下载依赖","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"cargo run","suffix":"","desc":"构建并测试运行","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"cargo build --release","suffix":"","desc":"优化编译项目","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"crates","suffix":"","desc":"https://crates.io/","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"cargo update","suffix":"","desc":"更新依赖包升级1个版本，如为其它最新版本需手动指定依赖版本","url":"","summary":"","reference":"","dot":""}]},{"title":"相关链接","fold":false,"list":[]}]}]},{"column":[{"title":"Go","barcolor":"#73cddc","fold":false,"box":[]},{"title":"数据类型","barcolor":"","fold":false,"box":[{"title":"数据类型","fold":false,"list":[{"prefix":"","tag":"整型 ","suffix":"int","desc":"","url":"","summary":"类型|描述\n---|:--:|\nbyte|类似 uint8\nrune|类似 int32\nuint|32 或 64 位\nint|与 uint 一样大小\nuintptr|无符号整型，用于存放一个指针\nuint8|无符号 8 位整型 (0 到 255)\nuint16|无符号 16 位整型 (0 到 65535)\nuint32|无符号 32 位整型 (0 到 4294967295)\nuint64|无符号 64 位整型 (0 到 18446744073709551615)\nint8|有符号 8 位整型 (-128 到 127)\nint16|有符号 16 位整型 (-32768 到 32767)\nint32|有符号 32 位整型 (-2147483648 到 2147483647)\nint64|有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)","reference":"其它数字类型|https://www.runoob.com/go/go-data-types.html","dot":""},{"prefix":"","tag":"浮点型 ","suffix":"float64","desc":"支持复数","url":"","summary":"类型|描述\n---|:--:|\nfloat32|IEEE-754 32位浮点型数\nfloat64|IEEE-754 64位浮点型数\ncomplex64|32 位实数和虚数\ncomplex128|64 位实数和虚数","reference":"","dot":""},{"prefix":"","tag":"布尔型 ","suffix":"bool","desc":"值：true,false","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"字符串 ","suffix":"string +","desc":"字符串拼接符 +","url":"","summary":"字符串就是一串固定长度的字符连接起来的字符序列。\nGo 的字符串是由单个字节连接起来的。\nGo 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。","reference":"","dot":""},{"prefix":"","tag":"指针","suffix":"","desc":"var var_name *var-type\n在使用指针前你需要声明指针","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"数组","suffix":"","desc":"var x [len] type = {val,..}","url":"","summary":"","reference":"","dot":""}]},{"title":"类型检测","fold":false,"list":[{"prefix":"var","tag":".(type)","suffix":"","desc":"仅可用于type-switch","url":"","summary":"```go\nswitch x.(type){\n    case type:\n       statement(s);      \n    case type:\n       statement(s); \n    /* 你可以定义任意个数的case */\n    default: /* 可选 */\n       statement(s);\n}\n```","reference":"","dot":""}]}]},{"title":"语法","barcolor":"","fold":false,"box":[{"title":"声明与作用域","fold":false,"list":[{"prefix":"","tag":"var ","suffix":"x [type] = val","desc":"可以一次声明多个变量 var x1,x2 type","url":"","summary":"类型|初始化默认值\n---|:--:|\n数值类型（包括complex64/128）| 0\n布尔类型|false\n字符串|\"\"（空字符串）\n其它类型|nil\n\n---------------\n\n空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。\n_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。","reference":"","dot":""},{"prefix":"","tag":"x ","suffix":":= val","desc":"声明一个变量，只能在函数体中出现","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"var ","suffix":"(x type ..)","desc":"这种因式分解关键字的写法一般用于声明全局变量","url":"","summary":"```\nvar (\n    a int\n    b bool\n)\n```","reference":"","dot":""},{"prefix":"","tag":"const ","suffix":"x [type] = val","desc":"定义常量","url":"","summary":"常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。","reference":"","dot":""},{"prefix":"","tag":"const ","suffix":"(x type ..)","desc":"定义多个常量","url":"","summary":"iota，特殊常量，可以认为是一个可以被编译器修改的常量。\niota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。","reference":"iota|https://www.runoob.com/go/go-constants.html","dot":""},{"prefix":"var ","tag":"x *type ","suffix":"= &var","desc":"指针使用流程：\n定义指针变量。\n为指针变量赋值。\n访问指针变量中指向地址的值。","url":"","summary":"当一个指针被定义后没有分配到任何变量时，它的值为 nil。\nnil 指针也称为空指针。","reference":"","dot":""}]},{"title":"运算符","fold":true,"list":[{"prefix":"","tag":"算术运算符","suffix":"","desc":"加法运算符：x + y\n减法运算符： x - y\n乘法运算符： x * y\n除法运算符：x / y\n余数运算符：x % y\n自增运算符：x++\n自减运算符：x--","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"关系运算符","suffix":"","desc":"\\> 大于运算符\n\\< 小于运算符\n>= 大于或等于运算符\n<= 小于或等于运算符\n== 相等运算符\n!= 不相等运算符","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"逻辑运算符","suffix":"","desc":"取反运算符：!\n且运算符：&&\n或运算符：||","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"位运算符","suffix":"","desc":"| 按位或\n& 按位与\n^ 按位异或\n\\<< 左移运算符 \n\n>> 右移运算符","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"赋值运算符","suffix":"","desc":"+= -= *= **= /= %= &= |= ^= <<= >>=","url":"","summary":"","reference":"","dot":""}]},{"title":"流程控制","fold":false,"list":[{"prefix":"","tag":"if..else..","suffix":"","desc":"if .. {}\nif ..{} else ..{}\nif ..{} else if.. {}\n表达式无需括号","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"switch","suffix":"","desc":"表达式无需括号\n可直接使用switch{ case exp1==exp2 : ..}","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"select","suffix":"","desc":"select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。\n```go\nselect{\n    case a :\n        statement;\n    default:\n        statement;\n}\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"循环语句","fold":false,"list":[{"prefix":"","tag":"for","suffix":"","desc":"和 C 语言的 for 一样 ```for init; condition; post { }```\n和 C 语言的 while 一样 ```for condition { }```\n和 C 的 for(;;) 一样 ```for { }```","url":"","summary":"init： 一般为赋值表达式，给控制变量赋初值；\ncondition： 关系表达式或逻辑表达式，循环控制条件；\npost： 一般为赋值表达式，给控制变量增量或减量。\nfor语句执行过程如下：\n1、先对表达式 1 赋初值；\n2、判别赋值表达式 init 是否满足给定条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。","reference":"","dot":""},{"prefix":"","tag":"break","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"continue","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"goto ","suffix":"label","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"label:","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"包","fold":false,"list":[{"prefix":"","tag":"package ","suffix":"main","desc":"包声明","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"import ","suffix":"\"fmt\"","desc":"引入包","url":"","summary":"","reference":"","dot":""}]}]},{"title":"其它","barcolor":"","fold":false,"box":[{"title":"安装与编译","fold":false,"list":[{"prefix":"","tag":"go run ","suffix":"file","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"参考资料","fold":false,"list":[{"prefix":"","tag":"标准库中文版","suffix":"","desc":"","url":"https://studygolang.com/pkgdoc","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Swift","barcolor":"#ff4480","fold":false,"box":[]},{"title":"数据类型","barcolor":"","fold":false,"box":[{"title":"数据类型","fold":false,"list":[{"prefix":"","tag":"整型 ","suffix":"Int","desc":"长度与当前平台的原生字长相同。","url":"","summary":"一般来说，你不需要专门指定整数的长度。\nInt8, Int16, Int32, Int64 分别表示 8 位, 16 位, 32 位, 和 64 位的有符号整数形式。\nUInt8, UInt16, UInt32, UInt64 分别表示 8 位, 16 位, 32 位 和 64 位的无符号整数形式。","reference":"","dot":""},{"prefix":"","tag":"浮点型 ","suffix":"Float / Double","desc":"Double精确度很高，至少有15位数字，而 Float 最少只有6位数字。","url":"","summary":"Double 表示64位浮点数。当你需要存储很大或者很高精度的浮点数时请使用此类型。\nFloat 表示32位浮点数。精度要求不高的话可以使用此类型。","reference":"","dot":""},{"prefix":"","tag":"布尔型 ","suffix":"Bool","desc":"值：true,false,nil（没有值）","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"字符型 ","suffix":"Character","desc":"字符指的是单个字母","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"字符串 ","suffix":"String","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"可选类型 ","suffix":"Optional","desc":"使用可选类型来处理值可能缺失的情况。可选类型表示有值或没有值。","url":"","summary":"","reference":"参考资料|https://www.runoob.com/swift/swift-optionals.html","dot":""},{"prefix":"","tag":"元组 ","suffix":"tuple","desc":"元组可作为函数返回值","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":" ","suffix":"nil","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"类型方法","fold":false,"list":[{"prefix":"","tag":"typealias ","suffix":"new = old","desc":"对当前的类型定义了另一个名字\ntypealias Feet = Int","url":"","summary":"","reference":"","dot":""}]}]},{"title":"语法","barcolor":"","fold":false,"box":[{"title":"声明与作用域","fold":false,"list":[{"prefix":"","tag":"var ","suffix":"x[:type] = val","desc":"定义变量\nvar x:Float = 3.14","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"let ","suffix":"x[:type] = val","desc":"定义常量\nlet x:Float = 3.14159","url":"","summary":"","reference":"","dot":""}]},{"title":"运算符","fold":false,"list":[{"prefix":"","tag":"算术运算符","suffix":"","desc":"加法运算符：x + y\n减法运算符： x - y\n乘法运算符： x * y\n除法运算符：x / y\n余数运算符：x % y\n数值运算符： +x\n负数值运算符：-x","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"关系运算符","suffix":"","desc":"\\> 大于运算符\n\\< 小于运算符\n>= 大于或等于运算符\n<= 小于或等于运算符\n== 相等运算符\n!= 不相等运算符","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"逻辑运算符","suffix":"","desc":"取反运算符：!\n且运算符：&&\n或运算符：||\n三元运算符：?:","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"位运算符","suffix":"","desc":"| 按位或\n& 按位与\n~ 按位取反\n^ 按位异或\n\\<< 左移运算符 \n\n>> 右移运算符\n","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"赋值运算符","suffix":"","desc":"+= -= *= /= %= &= |= ^= <<= >>=","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"区间运算符 ","suffix":"...|..","desc":"# 闭区间运算符`...`\t\n定义一个包含从a到b(包括a和b)的所有值的区间，b必须大于等于a。 ‌ \n# 半开区间运算符`..`\t\n半开区间1..< 5 区间值为 1, 2, 3, 和 4","url":"","summary":"","reference":"","dot":""}]},{"title":"流程控制","fold":false,"list":[{"prefix":"","tag":"if..else..","suffix":"","desc":"if exp {..}\nif exp {..} else {..}\nif exp {..} else if exp {..}","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"switch","suffix":"","desc":"默认中断，无需break。\n如果使用了fallthrough 语句，则会继续执行之后的 case 或 default 语句，不论条件是否满足都会执行。","url":"","summary":"```swift\nswitch exp {\n    case exp :\n        ...\n        [fallthrough]\n    default :\n}\n```","reference":"","dot":""},{"prefix":"","tag":"x?y:z","suffix":"","desc":"三元运算符","url":"","summary":"? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。","reference":"","dot":""}]},{"title":"循环语句","fold":false,"list":[{"prefix":"","tag":"for .. in ..","suffix":"","desc":"默认取的为具体值 for $val in var\n遍历一个集合里面的所有元素，例如由数字表示的区间、数组中的元素、字符串中的字符。","url":"","summary":"```swift\nimport Cocoa\n\nfor index in 1...5 {\n    print(\"\\(index) 乘于 5 为：\\(index * 5)\")\n}\n\nvar someInts:[Int] = [10, 20, 30]\nfor index in someInts {\n   print( \"index 的值为 \\(index)\")\n}\n```","reference":"","dot":""},{"prefix":"","tag":"while","suffix":"","desc":"while exp {..}","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"repeat..while","suffix":"","desc":"repeat{..}while exp\n相当于do while","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"break","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"continue","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"函数","fold":false,"list":[{"prefix":"","tag":"func ","suffix":"fn (argname : Type)","desc":"定义函数\n```\nfunc runoob(site: String) -> String {\n    return (site)\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":" ","suffix":"(outname innername : Type)","desc":"outname 外部参数名\ninnername 内部参数名\n如果你提供了外部参数名，那么函数在被调用时，必须使用外部参数名。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":" ","suffix":"(argname: inout Type)","desc":"一般默认在函数中定义的参数都是常量参数，也就是这个参数你只可以查询使用，不能改变它的值。\n如果想要声明一个变量参数，可以在参数定义前加 inout 关键字，这样就可以改变这个参数的值了。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":" ","suffix":"(argname : Type...)","desc":"可变参数可以接受零个或多个值。函数调用时，你可以用可变参数来指定函数参数，其数量是不确定的。\n可变参数通过在变量类型名后面加入（...）的方式来定义。","url":"","summary":"","reference":"","dot":""},{"prefix":"fn","tag":" ","suffix":"(argname : value)","desc":"调用函数","url":"","summary":"","reference":"","dot":""},{"prefix":"fn ","tag":"(&val)","suffix":"","desc":"一般默认的参数传递都是传值调用的，而不是传引用。所以传入的参数在函数内改变，并不影响原来的那个参数。传入的只是这个参数的副本。\n当传入的参数作为输入输出参数时，需要在参数名前加 & 符，表示这个值可以被函数修改。","url":"","summary":"","reference":"","dot":""},{"prefix":"var ","tag":"fn:(Type)->Type ","suffix":"= fn2","desc":"使用函数类型\n`var addition: (Int, Int) -> Int = sum`","url":"","summary":"","reference":"","dot":""}]}]},{"title":"其它","barcolor":"","fold":false,"box":[{"title":"参考资料","fold":false,"list":[{"prefix":"","tag":"入门教程","suffix":"","desc":"","url":"https://www.runoob.com/swift/swift-tutorial.html","summary":"","reference":"","dot":""},{"prefix":"","tag":"中文手册","suffix":"","desc":"","url":"https://www.runoob.com/manual/gitbook/swift5/source/_book/index.html","summary":"","reference":"","dot":""}]}]}]}]}