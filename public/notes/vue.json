{"version":1577292216582,"name":"vue","data":[{"column":[{"title":"Vue2基础","barcolor":"","fold":false,"box":[{"title":"应用&实例","fold":false,"list":[{"prefix":"","tag":"new Vue","suffix":"(opt)","desc":"","url":"","summary":"","reference":"API - 全部选项|https://cn.vuejs.org/v2/api/","dot":""},{"prefix":"","tag":"el","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"模板语法","fold":false,"list":[{"prefix":"","tag":"v-text","suffix":"{{data}}","desc":"{{data}}文本插值","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-once","suffix":"","desc":"一次性文本插值\n只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-html","suffix":"","desc":"输出HTML","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-bind","suffix":":attr","desc":"`<button v-bind:[key]=\"value\"></button>`动态属性名\n`<div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>`多个attribute","url":"","summary":"# 修饰符\n.prop - 作为一个 DOM property 绑定而不是作为 attribute 绑定。\n.camel - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。\n.sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。","reference":"","dot":""},{"prefix":"","tag":"class","suffix":"","desc":"```\n<div :class=\"{ red: isRed }\"></div>\n<div :class=\"[classA, classB]\"></div>\n<div :class=\"[classA, { classB: isB, classC: isC }]\">\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"style","suffix":"","desc":"```\n<div :style=\"{ fontSize: size + 'px' }\"></div>\n<div :style=\"[styleObjectA, styleObjectB]\"></div>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-if","suffix":"","desc":"v-if/v-else/v-else-if\nv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-show","suffix":"","desc":"v-show 只是简单地切换元素的 CSS property display。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"key","suffix":"","desc":"Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。\n添加key以保证元素是完全独立而不会复用。","url":"","summary":"","reference":"极客时间|https://time.geekbang.org/course/detail/100024601-86448\nAPI文档|https://cn.vuejs.org/v2/api/#key","dot":""},{"prefix":"","tag":"v-for","suffix":"","desc":"```\n<div v-for=\"(item, index) in items\"></div>\n<div v-for=\"(val, key) in object\"></div>\n<div v-for=\"(val, name, index) in object\"></div>\n<div v-for=\"item in 5\">{{item}}</div> 从1-5\n```","url":"","summary":"v-for 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute key 来提供一个排序提示","reference":"","dot":""}]},{"title":"生命周期","fold":false,"list":[{"prefix":"lifeCycle","tag":" ","suffix":"","desc":"生命周期钩子的 this 上下文指向调用它的 Vue 实例。","url":"","summary":"","reference":"生命周期图|https://cn.vuejs.org/v2/guide/instance.html","dot":""},{"prefix":"","tag":"beforeCreate","suffix":"","desc":"在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"created","suffix":"","desc":"在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeMount","suffix":"","desc":"在挂载开始之前被调用：相关的 render 函数首次被调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"mounted","suffix":"","desc":"实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。\n注意 mounted 不会保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，可以在 mounted 内部使用 vm.$nextTick","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeUpdate","suffix":"","desc":"在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。\n该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。","url":"","summary":"期间不可更改依赖数据。","reference":"","dot":""},{"prefix":"","tag":"updated","suffix":"","desc":"在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。\n注意，updated 不会保证所有的子组件也都被重新渲染完毕。如果你希望等到整个视图都渲染完毕，可以在 updated 里使用 vm.$nextTick。","url":"","summary":"期间不可更改依赖数据。","reference":"声明周期应用场景|https://time.geekbang.org/course/detail/100024601-86621","dot":""},{"prefix":"","tag":"activated","suffix":"","desc":"被 keep-alive 缓存的组件激活时调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"deactivated","suffix":"","desc":"被 keep-alive 缓存的组件失活时调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeDestroy","suffix":"","desc":"实例销毁之前调用。在这一步，实例仍然完全可用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":"#66d9ef"},{"prefix":"","tag":"destroyed","suffix":"","desc":"实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":"#66d9ef"},{"prefix":"","tag":"errorCaptured","suffix":"","desc":"在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Vue3基础","barcolor":"","fold":false,"box":[{"title":"实例","fold":false,"list":[{"prefix":"","tag":"Vue.createApp","suffix":"(opt)","desc":"每个 Vue 应用都是通过用 createApp 函数创建一个新的应用实例开始的。\n传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。","url":"","summary":"应用实例暴露的大多数方法都会返回该同一实例，允许链式。","reference":"API文档|https://v3.cn.vuejs.org/api/global-api.html#createapp","dot":""},{"prefix":"app","tag":".mount","suffix":"('#app')","desc":"","url":"","summary":"mount 不返回应用本身。相反，它返回的是根组件实例。","reference":"","dot":""}]},{"title":"模板语法","fold":false,"list":[{"prefix":"","tag":"v-text","suffix":"{{data}}","desc":"{{data}}文本插值","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-once","suffix":"","desc":"一次性文本插值\n只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-html","suffix":"","desc":"输出HTML","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-bind","suffix":":attr","desc":"`<button v-bind:[key]=\"value\"></button>`动态属性名\n`<div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>`多个attribute\n\n当在一个元素上设置一个绑定的时候，Vue 会默认通过 in 操作检测该元素是否有一个被定义为 property 的 key。如果该 property 被定义了，Vue 会将这个值设置为一个 DOM property 而不是 attribute。大多数情况下，这样工作是正常的，但你也可以通过 .prop 或 .attr 修饰符显性地覆写这个行为。有的时候这是必要的，尤其是基于自定义元素的工作。","url":"","summary":"# 修饰符\n.camel - 将 kebab-case attribute 名转换为 camelCase。\n.prop - 将一个绑定强制设置为一个 DOM property。\n.attr - 将一个绑定强制设置为一个 DOM attribute。\n\n# 特殊\n属性disabled为空字符串时也保留空，优先转布尔。","reference":"","dot":""},{"prefix":"","tag":"class","suffix":"","desc":"```\n<div :class=\"{ red: isRed }\"></div>\n<div :class=\"[classA, classB]\"></div>\n<div :class=\"[classA, { classB: isB, classC: isC }]\">\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"style","suffix":"","desc":"```\n<div :style=\"{ fontSize: size + 'px' }\"></div>\n<div :style=\"[styleObjectA, styleObjectB]\"></div>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-if","suffix":"","desc":"v-if/v-else/v-else-if\nv-if 是“真正”的条件渲染，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-show","suffix":"","desc":"v-show 只是简单地切换元素的 CSS property display。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"key","suffix":"","desc":"Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。\n添加key以保证元素是完全独立而不会复用。","url":"","summary":"","reference":"API文档|https://v3.cn.vuejs.org/api/special-attributes.html#key","dot":""},{"prefix":"","tag":"v-for","suffix":"","desc":"```\n<div v-for=\"(item, index) in items\"></div>\n<div v-for=\"(value, key) in object\"></div>\n<div v-for=\"(value, name, index) in object\"></div>\n<div v-for=\"item in 5\">{{item}}</div> 从1-5\n```","url":"","summary":"v-for 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute key 来提供一个排序提示","reference":"","dot":""}]},{"title":"生命周期","fold":false,"list":[{"prefix":"lifeCycle","tag":" ","suffix":"","desc":"生命周期钩子的 this 上下文指向调用它的 Vue 实例。","url":"","summary":"","reference":"生命周期图|https://v3.cn.vuejs.org/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA","dot":""},{"prefix":"","tag":"beforeCreate","suffix":"","desc":"在实例初始化之后、进行数据侦听和事件/侦听器的配置之前同步调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"created","suffix":"","desc":"在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeMount","suffix":"","desc":"在挂载开始之前被调用：相关的 render 函数首次被调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"mounted","suffix":"","desc":"在实例挂载完成后被调用，这时候传递给 app.mount 的元素已经被新创建的 vm.$el 替换了。\n注意 mounted 不会保证所有的子组件也都被挂载完成。如果你希望等待整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeUpdate","suffix":"","desc":"在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。\n该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"updated","suffix":"","desc":"在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。\n注意，updated 不会保证所有的子组件也都被重新渲染完毕。如果你希望等待整个视图都渲染完毕，可以在 updated 内部使用 vm.$nextTick。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"activated","suffix":"","desc":"被 keep-alive 缓存的组件激活时调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"deactivated","suffix":"","desc":"被 keep-alive 缓存的组件失活时调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeUnmount","suffix":"","desc":"在卸载组件实例之前调用。在这个阶段，实例仍然是完全正常的。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":"#ffa500"},{"prefix":"","tag":"unmounted","suffix":"","desc":"卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":"#ffa500"},{"prefix":"","tag":"errorCaptured","suffix":"","desc":"在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"renderTracked","suffix":"","desc":"跟踪虚拟 DOM 重新渲染时调用。钩子接收 debugger event 作为参数。此事件告诉你哪个操作跟踪了组件以及该操作的目标对象和键。","url":"","summary":"","reference":"API文档|https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html#rendertracked","dot":""},{"prefix":"","tag":"renderTriggered","suffix":"","desc":"当虚拟 DOM 重新渲染被触发时调用。和 renderTracked 类似，接收 debugger event 作为参数。此事件告诉你是什么操作触发了重新渲染，以及该操作的目标对象和键。","url":"","summary":"","reference":"API文档|https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html#rendertriggered","dot":""}]}]}]},{"column":[{"title":"Vue2扩展","barcolor":"","fold":false,"box":[{"title":"数据","fold":false,"list":[{"prefix":"","tag":"data","suffix":"","desc":"Vue2 不能检测数组和对象的变化。\n组件的 data 选项是一个函数。","url":"","summary":"当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。\n当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。\n\n这里唯一的例外是使用 Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。\n实例创建之后，可以通过 vm.$data 访问原始数据对象。Vue 实例也代理了 data 对象上所有的 property，因此访问 vm.a 等价于访问 vm.$data.a。\n以 _ 或 $ 开头的 property 不会被 Vue 实例代理，因为它们可能和 Vue 内置的 property、API 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些 property。\n\n当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。\n如果需要，可以通过将 vm.$data 传入 JSON.parse(JSON.stringify(...)) 得到深拷贝的原始数据对象。","reference":"","dot":""},{"prefix":"vm","tag":".$set","suffix":"(target,prop/i,val)","desc":"响应式更改数组/对象中的值","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"computed","suffix":"","desc":"计算属性是基于它们的响应式依赖进行缓存的\n```\ncomputed: {\n    // 仅读取\n    aDouble() {\n      return this.a * 2\n    },\n    // 读取和设置\n    aPlus: {\n      get() {\n        return this.a + 1\n      },\n      set(v) {\n        this.a = v - 1    //v为对computed属性尝试设置的值\n      }\n    }\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"watch","suffix":"","desc":"`a.b.c` 默认为this.a.b.c\n`immediate:true` 回调将会在侦听开始之后被立即调用\n`deep:true` 回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深\n`handler:fn/[fns,..]` 回调函数或回调函数数组","url":"","summary":"","reference":"watch API|https://cn.vuejs.org/v2/api/#watch\n$watch API|https://cn.vuejs.org/v2/api/#vm-watch","dot":""}]},{"title":"选项","fold":false,"list":[]},{"title":"指令","fold":false,"list":[]},{"title":"表单","fold":false,"list":[{"prefix":"","tag":"v-model","suffix":"","desc":"`<input type=\"checkbox\" v-model=\"toggle\" true-value=\"yes\" false-value=\"no\">`","url":"","summary":"# select 注意事项\n添加一个初始化为空的禁用项 `<option disabled value=\"\">请选择</option>`","reference":"select注意事项|https://cn.vuejs.org/v2/guide/forms.html#%E9%80%89%E6%8B%A9%E6%A1%86","dot":""},{"prefix":"v-model","tag":".lazy","suffix":"","desc":"在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件_之后_进行同步","url":"","summary":"","reference":"","dot":""},{"prefix":"v-model","tag":".number","suffix":"","desc":"如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符","url":"","summary":"","reference":"","dot":""},{"prefix":"v-model","tag":".trim","suffix":"","desc":"如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符","url":"","summary":"","reference":"","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"","tag":"@[event]","suffix":"","desc":"用在普通元素上时，只能监听原生 DOM 事件。用在自定义元素组件上时，也可以监听子组件触发的自定义事件。\n```\n<button v-on:click=\"doThis\"></button> //事件event\n<button v-on:click=\"doThat('hello', $event)\"></button> //指定参数\n<button v-on=\"{ mousedown: doThis, mouseup: doThat }\"></button> //多个事件\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".once","suffix":"","desc":"只触发一次回调。","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".native","suffix":"","desc":"监听组件根元素的原生事件。","url":"","summary":"","reference":"","dot":"#66d9ef"},{"prefix":"@event","tag":".stop","suffix":"","desc":"阻止冒泡，调用 event.stopPropagation()。\n修饰符可以串联","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".capture","suffix":"","desc":"添加事件侦听器时使用 capture 模式。\n即内部元素触发的事件先在此处理，然后才交由内部元素进行处理","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".self","suffix":"","desc":"只当事件是从侦听器绑定的元素本身触发时才触发回调。\n用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".prevent","suffix":"","desc":"阻止默认事件，调用 event.preventDefault()。","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".passive","suffix":"","desc":"以 { passive: true } 模式添加侦听器\n`<div v-on:scroll.passive=\"onScroll\">...</div>`\n滚动事件的默认行为 (即滚动行为) 将会立即触发，而不会等待 `onScroll` 完成。\n这个 .passive 修饰符尤其能够提升移动端的性能。\n不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。","url":"","summary":"","reference":"","dot":""},{"prefix":":attr","tag":".sync","suffix":"","desc":"会扩展成一个更新父组件绑定值的 v-on 侦听器","url":"","summary":"","reference":"","dot":""},{"prefix":"@KeyboardEvent","tag":".$key","suffix":"","desc":"`<input v-on:keyup.enter=\"submit\">` 按键事件\n.enter\n.tab\n.delete (捕获“删除”和“退格”键)\n.esc\n.space\n.up\n.down\n.left\n.right","url":"","summary":"","reference":"key values|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values","dot":""},{"prefix":"@click","tag":".left/right/middle","suffix":"","desc":"鼠标点击事件修饰符","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".ctrl/alt/shift/meta","suffix":"","desc":"系统修饰键，可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。\n\nMac:meta 对应 command 键 (⌘)。\nWin:meta 对应 Windows 徽标键 (⊞)。\n\n`<div v-on:click.ctrl=\"doSomething\">Do something</div>`","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".exact","suffix":"","desc":"```\n<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->\n<button v-on:click.ctrl=\"onClick\">A</button>\n\n<!-- 有且只有 Ctrl 被按下的时候才触发 -->\n<button v-on:click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- 没有任何系统修饰符被按下的时候才触发 -->\n<button v-on:click.exact=\"onClick\">A</button>\n```","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Vue3扩展","barcolor":"","fold":false,"box":[{"title":"数据","fold":false,"list":[{"prefix":"","tag":"data","suffix":"","desc":"实例或组件的 data 选项是一个函数。\n以 _ 或 $ 开头的 property 不会被组件实例代理","url":"","summary":"直接将不包含在 data 中的新 property 添加到组件实例是可行的。但由于该 property 不在背后的响应式 $data 对象内，所以 Vue 的响应性系统不会自动跟踪它。","reference":"","dot":""},{"prefix":"","tag":"computed","suffix":"","desc":"```\nconst count = ref(1)\n//接受一个 getter 函数，并根据 getter 的返回值返回一个不可变的响应式 ref 对象。\nconst plusOne = computed(() => count.value + 1)\n//接受一个具有 get 和 set 函数的对象，用来创建可写的 ref 对象。\nconst plusOne = computed({\n  get: () => count.value + 1,\n  set: val => {\n    count.value = val - 1\n  }\n})\n//通过.value获取值\nconsole.log(plusOne.value)\n```\n","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"watch","suffix":"","desc":"选项：flush\n+ 'pre'（默认），指定的回调应该在渲染前被调用。它允许回调在模板运行前更新了其他值。\n+ 'post' 值是可以用来将回调推迟到渲染之后的。如果回调需要通过 $refs 访问更新的 DOM 或子组件，那么则使用该值。\n+ 'sync'，一旦值发生了变化，回调将被同步调用。\n\n对于 'pre' 和 'post'，回调使用队列进行缓冲（默认只会在条件下一次，回调完成前监听不会再触发。）。回调只被添加到队列中一次，即使观察值变化了多次。值的中间变化将被跳过，不会传递给回调。","url":"","summary":"","reference":"API参考文档|https://v3.cn.vuejs.org/guide/reactivity-computed-watchers.html#%E5%89%AF%E4%BD%9C%E7%94%A8%E5%88%B7%E6%96%B0%E6%97%B6%E6%9C%BA","dot":""}]},{"title":"选项","fold":false,"list":[]},{"title":"指令","fold":false,"list":[]},{"title":"表单","fold":false,"list":[{"prefix":"","tag":"v-model","suffix":"","desc":"`<input type=\"checkbox\" v-model=\"toggle\" true-value=\"yes\" false-value=\"no\">`","url":"","summary":"# select 注意事项\n添加一个初始化为空的禁用项 `<option disabled value=\"\">请选择</option>`","reference":"select注意事项|https://cn.vuejs.org/v2/guide/forms.html#%E9%80%89%E6%8B%A9%E6%A1%86","dot":""},{"prefix":"v-model","tag":".lazy","suffix":"","desc":"在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件_之后_进行同步","url":"","summary":"","reference":"","dot":""},{"prefix":"v-model","tag":".number","suffix":"","desc":"如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符","url":"","summary":"","reference":"","dot":""},{"prefix":"v-model","tag":".trim","suffix":"","desc":"如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符","url":"","summary":"","reference":"","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"","tag":"@[event]","suffix":"","desc":"支持多事件处理器\n`<button @click=\"one($event), two($event)\">submit</button>`\n*移除.native修饰符","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".once","suffix":"","desc":"只触发一次回调。","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".stop","suffix":"","desc":"阻止冒泡，调用 event.stopPropagation()。\n修饰符可以串联","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".capture","suffix":"","desc":"添加事件侦听器时使用 capture 模式。\n即内部元素触发的事件先在此处理，然后才交由内部元素进行处理","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".self","suffix":"","desc":"只当事件是从侦听器绑定的元素本身触发时才触发回调。\n用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".prevent","suffix":"","desc":"阻止默认事件，调用 event.preventDefault()。","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".passive","suffix":"","desc":"以 { passive: true } 模式添加侦听器\n`<div v-on:scroll.passive=\"onScroll\">...</div>`\n滚动事件的默认行为 (即滚动行为) 将会立即触发，而不会等待 `onScroll` 完成。\n这个 .passive 修饰符尤其能够提升移动端的性能。\n不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。","url":"","summary":"","reference":"","dot":""},{"prefix":":attr","tag":".sync","suffix":"","desc":"会扩展成一个更新父组件绑定值的 v-on 侦听器","url":"","summary":"","reference":"","dot":""},{"prefix":"@KeyboardEvent","tag":".$key","suffix":"","desc":"`<input v-on:keyup.enter=\"submit\">` 按键事件\n.enter\n.tab\n.delete (捕获“删除”和“退格”键)\n.esc\n.space\n.up\n.down\n.left\n.right","url":"","summary":"","reference":"key values|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values","dot":""},{"prefix":"@click","tag":".left/right/middle","suffix":"","desc":"鼠标点击事件修饰符","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".ctrl/alt/shift/meta","suffix":"","desc":"系统修饰键，可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。\n\nMac:meta 对应 command 键 (⌘)。\nWin:meta 对应 Windows 徽标键 (⊞)。\n\n`<div v-on:click.ctrl=\"doSomething\">Do something</div>`","url":"","summary":"","reference":"","dot":""},{"prefix":"@event","tag":".exact","suffix":"","desc":"```\n<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->\n<button v-on:click.ctrl=\"onClick\">A</button>\n\n<!-- 有且只有 Ctrl 被按下的时候才触发 -->\n<button v-on:click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- 没有任何系统修饰符被按下的时候才触发 -->\n<button v-on:click.exact=\"onClick\">A</button>\n```","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Vue2组件","barcolor":"","fold":false,"box":[{"title":"注册","fold":false,"list":[{"prefix":"","tag":"Vue.component","suffix":"(name,opt)","desc":"每个组件必须只有一个根元素","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"components","suffix":"","desc":"注意局部注册的组件在其子组件中不可用。\n```\ncomponents: {\n    'component-a': ComponentA,\n    'component-b': ComponentB\n}\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"属性","fold":false,"list":[{"prefix":"","tag":"props","suffix":"","desc":"```\nprops:['a','b']\nprops:{\n   test: {\n      type: String,  //支持自定义构造函数（使用instanceof验证）\n      required: true,\n      default: 100,\n      validator ： fn(val)\n   },\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-bind=","suffix":"\"propObj\"","desc":"将整个对象的全部属性都作为props传入","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"$attrs","suffix":"","desc":"$attrs包含所有传递给子组件的全部属性（不包括prop,class,style），默认根节点继承，可设置`inheritAttrs:false`禁用，通过v-bind=\"$attrs\"给其他元素绑定。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"provide/inject","suffix":"","desc":"provide，子组件可作为属性读取，基本类型数据无响应更新。\n```\nprovide: function () {\n  return {\n    getMap: this.getMap\n  }\n}\n```\n\ninject\n```\ninject: {\n    foo: {\n      from: 'bar', //原始provide属性名不同名\n      default: 'foo',\n      default: () => [1, 2, 3] //与 prop 的默认值类似，你需要对非原始值使用一个工厂方法\n    }\n}\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"动态组件","fold":false,"list":[{"prefix":"component ","tag":":is","suffix":"=\"$component\"","desc":"`<component v-bind:is=\"currentView\"></component>` 当 `currentView` 改变时，组件也跟着改变","url":"","summary":"","reference":"参考文档|https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6","dot":""},{"prefix":"tag ","tag":"is=","suffix":"\"$component\"","desc":"有些 HTML 元素，诸如 ul、ol、table 和 select，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 li、tr 和 option，只能出现在其它某些特定的元素内部。\n```\n<table>\n  <tr is=\"my-row\"></tr>\n</table>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"keep-alive","suffix":"","desc":"# 用途\n保持这些组件的状态，以避免反复重新渲染导致的性能问题。\n一般用于多个直属子组件（不应包含内容每次需要变更的组件）。\n默认只能有1个子组件处于激活状态。\n\n# 参数\n+ include - 字符串或正则表达式或数组。只有名称匹配的组件会被缓存。\n+ exclude - 字符串或正则表达式或数组。任何名称匹配的组件都不会被缓存。\n+ max - 数字。最多可以缓存多少组件实例。\n\n# 注意事项\n1.不能为匿名组件\n2.设置了Max后，达到最大值在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。\n3.不会在函数式组件中正常工作，因为它们没有缓存实例。\n4.用在其一个直属的子组件被开关的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素，keep-alive>要求同时只有一个子元素被渲染。\n5.当组件在keep-alive内被切换时，它的 mounted 和 unmounted 生命周期钩子不会被调用（除首次挂载），取而代之的是 activated 和 deactivated。","url":"","summary":"","reference":"API参考文档|https://cn.vuejs.org/v2/api/#keep-alive","dot":""}]},{"title":"异步组件","fold":false,"list":[{"prefix":"","tag":"Vue.component","suffix":"","desc":"全局异步组件注册\n## 方法一\n```\nVue.component(\n  'async-webpack-example',\n  // 这个动态导入会返回一个 `Promise` 对象。\n  () => import('./my-async-component')\n)\n```\n\n# 方法二\n```\nVue.component('async-webpack-example', function (resolve) {\n  // 这个特殊的 `require` 语法将会告诉 webpack\n  // 自动将你的构建代码切割成多个包，这些包\n  // 会通过 Ajax 请求加载\n  require(['./my-async-component'], resolve)\n})\n```\n\n# 方法三\n```\nVue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    // 向 `resolve` 回调传递组件定义\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"components","suffix":"","desc":"局部注册异步组件。\n默认将组件限制不要渲染，例如v-if\n```\ncomponents: {\n    'my-component': () => import('./my-async-component')\n}\n```\n\n# 加载状态\n这里的异步组件工厂函数也可以返回一个如下格式的对象：\n```\nconst AsyncComponent = () => ({\n  // 需要加载的组件 (应该是一个 `Promise` 对象)\n  component: import('./MyComponent.vue'),\n  // 异步组件加载时使用的组件\n  loading: LoadingComponent,\n  // 加载失败时使用的组件\n  error: ErrorComponent,\n  // 展示加载时组件的延时时间。默认值是 200 (毫秒)\n  delay: 200,\n  // 如果提供了超时时间且组件加载也超时了，\n  // 则使用加载失败时使用的组件。默认值是：`Infinity`\n  timeout: 3000\n})\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"事件","fold":false,"list":[]},{"title":"插槽","fold":false,"list":[]}]}]},{"column":[{"title":"Vue3组件","barcolor":"","fold":false,"box":[{"title":"注册","fold":false,"list":[{"prefix":"app","tag":".component","suffix":"(name,opt)","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"components","suffix":"","desc":"注意局部注册的组件在其子组件中不可用。\n```\ncomponents: {\n    'component-a': ComponentA,\n    'component-b': ComponentB\n}\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"属性","fold":false,"list":[{"prefix":"","tag":"props","suffix":"","desc":"```\nprops:['a','b']\nprops:{\n   test: {\n      type: String,  //支持自定义构造函数（使用instanceof验证）\n      required: true,\n      default: 100,\n      validator ： fn(val)\n   },\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-bind=","suffix":"\"propObj\"","desc":"将整个对象的全部属性都作为props传入","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"$attrs","suffix":"","desc":"$attrs包含所有传递给子组件的全部属性（不包括prop,class,style），默认根节点继承，可设置`inheritAttrs:false`禁用，通过v-bind=\"$attrs\"给其他元素绑定。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"provide/inject","suffix":"","desc":"provide，子组件可作为属性读取，基本类型数据无响应更新。\n```\nprovide: function () {\n  return {\n    getMap: this.getMap\n  }\n}\n```\n\ninject\n```\ninject: {\n    foo: {\n      from: 'bar', //原始provide属性名不同名\n      default: 'foo',\n      default: () => [1, 2, 3] //与 prop 的默认值类似，你需要对非原始值使用一个工厂方法\n    }\n}\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"动态组件","fold":false,"list":[{"prefix":"component ","tag":":is","suffix":"=\"$component\"","desc":"`<component v-bind:is=\"currentView\"></component>` 当 `currentView` 改变时，组件也跟着改变","url":"","summary":"","reference":"参考文档|https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6","dot":""},{"prefix":"tag ","tag":"is=","suffix":"\"$component\"","desc":"有些 HTML 元素，诸如 ul、ol、table 和 select，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 li、tr 和 option，只能出现在其它某些特定的元素内部。\n```\n<table>\n  <tr is=\"my-row\"></tr>\n</table>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"keep-alive","suffix":"","desc":"# 用途\n保持这些组件的状态，以避免反复重新渲染导致的性能问题。\n一般用于多个直属子组件（不应包含内容每次需要变更的组件）。\n默认只能有1个子组件处于激活状态。\n\n# 参数\n+ include - 字符串或正则表达式或数组。只有名称匹配的组件会被缓存。\n+ exclude - 字符串或正则表达式或数组。任何名称匹配的组件都不会被缓存。\n+ max - 数字。最多可以缓存多少组件实例。\n\n# 注意事项\n1.不能为匿名组件\n2.设置了Max后，达到最大值在新实例被创建之前，已缓存组件中最久没有被访问的实例会被销毁掉。\n3.不会在函数式组件中正常工作，因为它们没有缓存实例。\n4.用在其一个直属的子组件被开关的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素，keep-alive>要求同时只有一个子元素被渲染。\n5.当组件在keep-alive内被切换时，它的 mounted 和 unmounted 生命周期钩子不会被调用（除首次挂载），取而代之的是 activated 和 deactivated。","url":"","summary":"","reference":"API参考文档|https://cn.vuejs.org/v2/api/#keep-alive","dot":""}]},{"title":"异步组件","fold":false,"list":[{"prefix":"","tag":"Vue.component","suffix":"","desc":"全局异步组件注册\n## 方法一\n```\nVue.component(\n  'async-webpack-example',\n  // 这个动态导入会返回一个 `Promise` 对象。\n  () => import('./my-async-component')\n)\n```\n\n# 方法二\n```\nVue.component('async-webpack-example', function (resolve) {\n  // 这个特殊的 `require` 语法将会告诉 webpack\n  // 自动将你的构建代码切割成多个包，这些包\n  // 会通过 Ajax 请求加载\n  require(['./my-async-component'], resolve)\n})\n```\n\n# 方法三\n```\nVue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    // 向 `resolve` 回调传递组件定义\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"components","suffix":"","desc":"局部注册异步组件。\n默认将组件限制不要渲染，例如v-if\n```\ncomponents: {\n    'my-component': () => import('./my-async-component')\n}\n```\n\n# 加载状态\n这里的异步组件工厂函数也可以返回一个如下格式的对象：\n```\nconst AsyncComponent = () => ({\n  // 需要加载的组件 (应该是一个 `Promise` 对象)\n  component: import('./MyComponent.vue'),\n  // 异步组件加载时使用的组件\n  loading: LoadingComponent,\n  // 加载失败时使用的组件\n  error: ErrorComponent,\n  // 展示加载时组件的延时时间。默认值是 200 (毫秒)\n  delay: 200,\n  // 如果提供了超时时间且组件加载也超时了，\n  // 则使用加载失败时使用的组件。默认值是：`Infinity`\n  timeout: 3000\n})\n```","url":"","summary":"# Suspense\n异步组件在默认情况下是可挂起的。这意味着如果它在父链中有一个 <Suspense>，它将被视为该 <Suspense> 的异步依赖。在这种情况下，加载状态将由 <Suspense> 控制，组件自身的加载、错误、延迟和超时选项都将被忽略。\n\n通过在其选项中指定 suspensible: false，异步组件可以退出 Suspense 控制，并始终控制自己的加载状态。","reference":"","dot":""}]}]}]},{"column":[{"title":"Vuex","barcolor":"","fold":false,"box":[]}]},{"column":[{"title":"Vue Router","barcolor":"","fold":false,"box":[]}]},{"column":[{"title":"其它","barcolor":"","fold":false,"box":[{"title":"参考资料","fold":false,"list":[{"prefix":"","tag":"vue2技术揭秘","suffix":"","desc":"","url":"https://ustbhuangyi.github.io/vue-analysis/","summary":"","reference":"","dot":""}]}]}]}]}