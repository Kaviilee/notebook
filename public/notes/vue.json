{"version":1577292216582,"name":"vue","data":[{"column":[{"title":"Vue2基础","barcolor":"","fold":false,"box":[{"title":"应用&实例","fold":false,"list":[{"prefix":"","tag":"new Vue","suffix":"(opt)","desc":"","url":"","summary":"","reference":"API - 全部选项|https://cn.vuejs.org/v2/api/","dot":""},{"prefix":"","tag":"el","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"模板语法","fold":false,"list":[{"prefix":"","tag":"v-text","suffix":"{{data}}","desc":"{{data}}文本插值","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-once","suffix":"","desc":"一次性文本插值\n只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-html","suffix":"","desc":"输出HTML","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-bind","suffix":":attr","desc":"`<button v-bind:[key]=\"value\"></button>`动态属性名\n`<div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>`多个attribute","url":"","summary":"# 修饰符\n.prop - 作为一个 DOM property 绑定而不是作为 attribute 绑定。\n.camel - (2.1.0+) 将 kebab-case attribute 名转换为 camelCase。\n.sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。","reference":"","dot":""},{"prefix":"","tag":"class","suffix":"","desc":"```\n<div :class=\"{ red: isRed }\"></div>\n<div :class=\"[classA, classB]\"></div>\n<div :class=\"[classA, { classB: isB, classC: isC }]\">\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"style","suffix":"","desc":"```\n<div :style=\"{ fontSize: size + 'px' }\"></div>\n<div :style=\"[styleObjectA, styleObjectB]\"></div>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-if","suffix":"","desc":"v-if/v-else/v-else-if\nv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-show","suffix":"","desc":"v-show 只是简单地切换元素的 CSS property display。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"key","suffix":"","desc":"Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。\n添加key以保证元素是完全独立而不会复用。","url":"","summary":"","reference":"极客时间|https://time.geekbang.org/course/detail/100024601-86448\nAPI文档|https://cn.vuejs.org/v2/api/#key","dot":""},{"prefix":"","tag":"v-for","suffix":"","desc":"```\n<div v-for=\"(item, index) in items\"></div>\n<div v-for=\"(val, key) in object\"></div>\n<div v-for=\"(val, name, index) in object\"></div>\n<div v-for=\"item in 5\">{{item}}</div> 从1-5\n```","url":"","summary":"v-for 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute key 来提供一个排序提示","reference":"","dot":""}]},{"title":"生命周期","fold":false,"list":[{"prefix":"lifeCycle","tag":" ","suffix":"","desc":"生命周期钩子的 this 上下文指向调用它的 Vue 实例。","url":"","summary":"","reference":"生命周期图|https://cn.vuejs.org/v2/guide/instance.html","dot":""},{"prefix":"","tag":"beforeCreate","suffix":"","desc":"在实例初始化之后,进行数据侦听和事件/侦听器的配置之前同步调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"created","suffix":"","desc":"在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeMount","suffix":"","desc":"在挂载开始之前被调用：相关的 render 函数首次被调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"mounted","suffix":"","desc":"实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。\n注意 mounted 不会保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，可以在 mounted 内部使用 vm.$nextTick","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeUpdate","suffix":"","desc":"在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。\n该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。","url":"","summary":"期间不可更改依赖数据。","reference":"","dot":""},{"prefix":"","tag":"updated","suffix":"","desc":"在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。\n注意，updated 不会保证所有的子组件也都被重新渲染完毕。如果你希望等到整个视图都渲染完毕，可以在 updated 里使用 vm.$nextTick。","url":"","summary":"期间不可更改依赖数据。","reference":"声明周期应用场景|https://time.geekbang.org/course/detail/100024601-86621","dot":""},{"prefix":"","tag":"activated","suffix":"","desc":"被 keep-alive 缓存的组件激活时调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"deactivated","suffix":"","desc":"被 keep-alive 缓存的组件失活时调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeDestroy","suffix":"","desc":"实例销毁之前调用。在这一步，实例仍然完全可用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"destroyed","suffix":"","desc":"实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"errorCaptured","suffix":"","desc":"在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Vue3基础","barcolor":"","fold":false,"box":[{"title":"实例","fold":false,"list":[{"prefix":"","tag":"Vue.createApp","suffix":"(opt)","desc":"每个 Vue 应用都是通过用 createApp 函数创建一个新的应用实例开始的。\n传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。","url":"","summary":"应用实例暴露的大多数方法都会返回该同一实例，允许链式。","reference":"API文档|https://v3.cn.vuejs.org/api/global-api.html#createapp","dot":""},{"prefix":"app","tag":".mount","suffix":"('#app')","desc":"","url":"","summary":"mount 不返回应用本身。相反，它返回的是根组件实例。","reference":"","dot":""}]},{"title":"模板语法","fold":false,"list":[{"prefix":"","tag":"v-text","suffix":"{{data}}","desc":"{{data}}文本插值","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-once","suffix":"","desc":"一次性文本插值\n只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-html","suffix":"","desc":"输出HTML","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-bind","suffix":":attr","desc":"`<button v-bind:[key]=\"value\"></button>`动态属性名\n`<div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>`多个attribute\n\n当在一个元素上设置一个绑定的时候，Vue 会默认通过 in 操作检测该元素是否有一个被定义为 property 的 key。如果该 property 被定义了，Vue 会将这个值设置为一个 DOM property 而不是 attribute。大多数情况下，这样工作是正常的，但你也可以通过 .prop 或 .attr 修饰符显性地覆写这个行为。有的时候这是必要的，尤其是基于自定义元素的工作。","url":"","summary":"# 修饰符\n.camel - 将 kebab-case attribute 名转换为 camelCase。\n.prop - 将一个绑定强制设置为一个 DOM property。\n.attr - 将一个绑定强制设置为一个 DOM attribute。\n\n# 特殊\n属性disabled为空字符串时也保留空，优先转布尔。","reference":"","dot":""},{"prefix":"","tag":"class","suffix":"","desc":"```\n<div :class=\"{ red: isRed }\"></div>\n<div :class=\"[classA, classB]\"></div>\n<div :class=\"[classA, { classB: isB, classC: isC }]\">\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"style","suffix":"","desc":"```\n<div :style=\"{ fontSize: size + 'px' }\"></div>\n<div :style=\"[styleObjectA, styleObjectB]\"></div>\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-if","suffix":"","desc":"v-if/v-else/v-else-if\nv-if 是“真正”的条件渲染，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"v-show","suffix":"","desc":"v-show 只是简单地切换元素的 CSS property display。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"key","suffix":"","desc":"Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。\n添加key以保证元素是完全独立而不会复用。","url":"","summary":"","reference":"API文档|https://v3.cn.vuejs.org/api/special-attributes.html#key","dot":""},{"prefix":"","tag":"v-for","suffix":"","desc":"```\n<div v-for=\"(item, index) in items\"></div>\n<div v-for=\"(value, key) in object\"></div>\n<div v-for=\"(value, name, index) in object\"></div>\n<div v-for=\"item in 5\">{{item}}</div> 从1-5\n```","url":"","summary":"v-for 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute key 来提供一个排序提示","reference":"","dot":""}]},{"title":"生命周期","fold":false,"list":[{"prefix":"lifeCycle","tag":" ","suffix":"","desc":"生命周期钩子的 this 上下文指向调用它的 Vue 实例。","url":"","summary":"","reference":"生命周期图|https://v3.cn.vuejs.org/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA","dot":""},{"prefix":"","tag":"beforeCreate","suffix":"","desc":"在实例初始化之后、进行数据侦听和事件/侦听器的配置之前同步调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"created","suffix":"","desc":"在实例创建完成后被立即同步调用。在这一步中，实例已完成对选项的处理，意味着以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。然而，挂载阶段还没开始，且 $el property 目前尚不可用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeMount","suffix":"","desc":"在挂载开始之前被调用：相关的 render 函数首次被调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"mounted","suffix":"","desc":"在实例挂载完成后被调用，这时候传递给 app.mount 的元素已经被新创建的 vm.$el 替换了。\n注意 mounted 不会保证所有的子组件也都被挂载完成。如果你希望等待整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeUpdate","suffix":"","desc":"在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。\n该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务器端进行。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"updated","suffix":"","desc":"在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。\n注意，updated 不会保证所有的子组件也都被重新渲染完毕。如果你希望等待整个视图都渲染完毕，可以在 updated 内部使用 vm.$nextTick。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"activated","suffix":"","desc":"被 keep-alive 缓存的组件激活时调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"deactivated","suffix":"","desc":"被 keep-alive 缓存的组件失活时调用。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"beforeUnmount","suffix":"","desc":"在卸载组件实例之前调用。在这个阶段，实例仍然是完全正常的。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"unmounted","suffix":"","desc":"卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。\n该钩子在服务器端渲染期间不被调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"errorCaptured","suffix":"","desc":"在捕获一个来自后代组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"renderTracked","suffix":"","desc":"跟踪虚拟 DOM 重新渲染时调用。钩子接收 debugger event 作为参数。此事件告诉你哪个操作跟踪了组件以及该操作的目标对象和键。","url":"","summary":"","reference":"API文档|https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html#rendertracked","dot":""},{"prefix":"","tag":"renderTriggered","suffix":"","desc":"当虚拟 DOM 重新渲染被触发时调用。和 renderTracked 类似，接收 debugger event 作为参数。此事件告诉你是什么操作触发了重新渲染，以及该操作的目标对象和键。","url":"","summary":"","reference":"API文档|https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html#rendertriggered","dot":""}]}]}]},{"column":[{"title":"Vue2扩展","barcolor":"","fold":false,"box":[{"title":"数据","fold":false,"list":[{"prefix":"","tag":"data","suffix":"","desc":"Vue2 不能检测数组和对象的变化。","url":"","summary":"当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。\n当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。\n\n这里唯一的例外是使用 Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。\n实例创建之后，可以通过 vm.$data 访问原始数据对象。Vue 实例也代理了 data 对象上所有的 property，因此访问 vm.a 等价于访问 vm.$data.a。\n以 _ 或 $ 开头的 property 不会被 Vue 实例代理，因为它们可能和 Vue 内置的 property、API 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些 property。\n\n当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。\n如果需要，可以通过将 vm.$data 传入 JSON.parse(JSON.stringify(...)) 得到深拷贝的原始数据对象。","reference":"","dot":""}]},{"title":"指令","fold":false,"list":[]},{"title":"事件","fold":false,"list":[{"prefix":":attr","tag":".sync","suffix":"","desc":"会扩展成一个更新父组件绑定值的 v-on 侦听器","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Vue3扩展","barcolor":"","fold":false,"box":[{"title":"数据","fold":false,"list":[]},{"title":"指令","fold":false,"list":[]},{"title":"事件","fold":false,"list":[]}]}]},{"column":[{"title":"Vue2组件","barcolor":"","fold":false,"box":[]}]},{"column":[{"title":"Vue3组件","barcolor":"","fold":false,"box":[]}]},{"column":[{"title":"Vuex","barcolor":"","fold":false,"box":[]}]},{"column":[{"title":"Vue Router","barcolor":"","fold":false,"box":[]}]}]}