{"version":1585048658556,"name":"bom","data":[{"column":[{"title":"Navigator","barcolor":"","fold":false,"box":[{"title":"代理","fold":false,"list":[{"prefix":"navigator","tag":".userAgent","suffix":"","desc":"返回浏览器的 User Agent 字符串，表示浏览器的厂商和版本信息。","url":"","summary":"","reference":"","dot":""},{"prefix":"navigator","tag":".platform","suffix":"","desc":"返回用户的操作系统信息，比如MacIntel、Win32、Linux x86_64等 。","url":"","summary":"","reference":"","dot":""},{"prefix":"navigator","tag":".language","suffix":"","desc":"浏览器的首选语言。该属性只读。\nnavigator.languages属性返回一个数组，表示用户可以接受的语言","url":"","summary":"","reference":"","dot":""}]},{"title":"地理","fold":false,"list":[{"prefix":"navigator","tag":".geolocation","suffix":"","desc":"返回一个 Geolocation 对象，包含用户地理位置的信息","url":"","summary":"","reference":"","dot":""},{"prefix":"geo","tag":".getCurrentPosition","suffix":"(suc(pos),fail(err),opt)","desc":"得到用户的当前位置","url":"","summary":"# opt\n+ enableHighAccuracy：布尔值，是否返回高精度结果。如果设为true，可能导致响应时间变慢或（移动设备的）功耗增加；反之，如果设为false，设备可以更快速地响应。默认值为false。\n+ timeout：正整数，表示等待查询的最长时间，单位为毫秒。默认值为Infinity。\n+ maximumAge：正整数，表示可接受的缓存最长时间，单位为毫秒。如果设为0，表示不返回缓存值，必须查询当前的实际位置；如果设为Infinity，必须返回缓存值，不管缓存了多少时间。默认值为0。","reference":"参考资料|https://wangdoc.com/webapi/geolocation.html","dot":""},{"prefix":"geo","tag":".watchPosition","suffix":"(suc(pos),fail(err),opt)","desc":"监听用户位置变化,返回一个id","url":"","summary":"","reference":"","dot":""},{"prefix":"geo","tag":".clearWatch","suffix":"(id)","desc":"取消watchPosition()方法指定的监听函数","url":"","summary":"","reference":"","dot":""},{"prefix":"pos","tag":".coords","suffix":"","desc":"coords属性指向一个对象，包含了用户的位置信息\ncoords.latitude：纬度\ncoords.longitude：经度\ncoords.accuracy：精度\ncoords.altitude：海拔\ncoords.altitudeAccuracy：海拔精度（单位：米）\ncoords.heading：以360度表示的方向\ncoords.speed：每秒的速度（单位：米）\n大多数桌面浏览器不提供上面列表的后四个值。","url":"","summary":"","reference":"","dot":""},{"prefix":"pos","tag":".timestamp","suffix":"","desc":"返回获得位置信息的具体时间","url":"","summary":"","reference":"","dot":""},{"prefix":"err.","tag":"code","suffix":"","desc":"geoError的参数也是一个event对象。event.code属性表示错误类型，有四个值\n0：未知错误，浏览器没有提示出错的原因，相当于常量event.UNKNOWN\\_ERROR。\n1：用户拒绝授权，相当于常量event.PERMISSION_DENIED。\n2：没有得到位置，GPS或其他定位机制无法定位，相当于常量event.POSITION\\_UNAVAILABLE。\n3：超时，GPS没有在指定时间内返回结果，相当于常量event.TIMEOUT。","url":"","summary":"","reference":"","dot":""},{"prefix":"err","tag":".message","suffix":"","desc":"字符串，表示错误的描述。","url":"","summary":"","reference":"","dot":""}]},{"title":"状态","fold":true,"list":[{"prefix":"navigator","tag":".onLine","suffix":"","desc":"返回一个布尔值，表示用户当前在线还是离线（浏览器断线）。\n有时，浏览器可以连接局域网，但是局域网不能连通外网。这时，有的浏览器的onLine属性会返回true，所以不能假定只要是true，用户就一定能访问互联网。不过，如果是false，可以断定用户一定离线。","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"offline","suffix":"","desc":"离线事件","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"online","suffix":"","desc":"上线事件","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Location","barcolor":"","fold":false,"box":[{"title":"location","fold":false,"list":[{"prefix":"window","tag":".isSecureContext","suffix":"","desc":"返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是true，否则就是false。","url":"","summary":"","reference":"","dot":""},{"prefix":"location","tag":".<prop>","suffix":"","desc":"+ location.href：整个 URL。\n+ location.origin：URL 的协议、主机名和端口。\n+ location.protocol：当前 URL 的协议，包括冒号（:）。\n+ location.host：主机。如果端口不是协议默认的80和433，则还会包括冒号（:）和端口。\n+ location.hostname：主机名，不包括端口。\n+ location.port：端口号。\n+ location.pathname：URL 的路径部分，从根路径/开始。\n+ location.search：查询字符串部分，从问号?开始。\n+ location.hash：片段字符串部分，从#开始。\n+ location.username：域名前面的用户名。\n+ location.password：域名前面的密码。\n只有origin属性是只读的，其他属性都可写\n","url":"","summary":"","reference":"","dot":""},{"prefix":"location","tag":".assign","suffix":"(url)","desc":"立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。","url":"","summary":"","reference":"","dot":""},{"prefix":"location","tag":".replace","suffix":"(url)","desc":"浏览器立刻跳转到新的 URL。\nreplace会在浏览器的浏览历史History里面删除当前网址，也就是说，一旦使用了该方法，后退按钮就无法回到当前网页了，相当于在浏览历史里面，使用新的 URL 替换了老的 URL。","url":"","summary":"","reference":"","dot":""},{"prefix":"location","tag":".reload","suffix":"([true])","desc":"重新加载当前网址，相当于按下浏览器的刷新按钮。\n它接受一个布尔值作为参数。如果参数为true，浏览器将向服务器重新请求这个网页，并且重新加载后，网页将滚动到头部（即scrollTop === 0）。如果参数是false或为空，浏览器将从本地缓存重新加载该网页，并且重新加载后，网页的视口位置是重新加载前的位置。","url":"","summary":"","reference":"","dot":""},{"prefix":"window.on","tag":"hashchange","suffix":"","desc":"变更锚点#","url":"","summary":"","reference":"","dot":""}]},{"title":"URL","fold":false,"list":[{"prefix":"","tag":"new URL","suffix":"(url)","desc":"创建一个url实例","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/bom/location.html#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95","dot":""}]},{"title":"URLSearchParams","fold":false,"list":[{"prefix":"","tag":"new URLSearchParams","suffix":"(val)","desc":"构造、解析和处理 URL 的查询字符串.\n对查询字符串自动编码","url":"","summary":"```\n// 方法一：传入字符串\nvar params = new URLSearchParams('?foo=1&bar=2');\n// 等同于\nvar params = new URLSearchParams(document.location.search);\n\n// 方法二：传入数组\nvar params = new URLSearchParams([['foo', 1], ['bar', 2]]);\n\n// 方法三：传入对象\nvar params = new URLSearchParams({'foo' : 1 , 'bar' : 2});\n```","reference":"参考资料|https://wangdoc.com/javascript/bom/location.html#urlsearchparams-%E5%AF%B9%E8%B1%A1\nMDN|https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams","dot":""},{"prefix":"params","tag":".toString()","suffix":"","desc":"返回实例的字符串形式","url":"","summary":"```\nvar params = new URLSearchParams({version: 2.0});\nwindow.location.href = location.pathname + '?' + params;\n```\n上面代码中，location.href赋值时，可以直接使用params对象。这时就会自动调用toString方法。","reference":"","dot":""},{"prefix":"params","tag":".get","suffix":"(key)","desc":"读取查询字符串里面的指定键,不存在返回null\n`params.getAll()` 方法返回一个数组，成员是指定键的所有键值。\n","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".has","suffix":"(key)","desc":"返回一个布尔值，表示查询字符串是否包含指定的键名","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".append","suffix":"(key,val)","desc":"追加一个查询参数,没有返回值","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".set","suffix":"(key,val)","desc":"设置查询字符串的键值.如果是已经存在的键，键值会被改写，否则会被追加。","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".delete","suffix":"(key)","desc":"删除指定的查询参数","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".sort()","suffix":"","desc":"对查询字符串里面的键进行排序，规则是按照 Unicode 码点从小到大排列。","url":"","summary":"","reference":"","dot":""},{"prefix":"params","tag":".entries()","suffix":"","desc":"URLSearchParams实例有遍历器接口，可以用for...of循环遍历\nparams.keys()\nparams.values()\nparams.entries()","url":"","summary":"```\nvar params = new URLSearchParams({'foo': 1 , 'bar': 2});\n\nfor (var p of params) {\n  console.log(p[0] + ': ' + p[1]);\n}\n// foo: 1\n// bar: 2\n```","reference":"","dot":""}]}]},{"title":"History","barcolor":"","fold":false,"box":[{"title":"访问","fold":false,"list":[{"prefix":"history","tag":".length","suffix":"","desc":"当前窗口一共访问过的网址个数","url":"","summary":"","reference":"","dot":""},{"prefix":"history","tag":".back()","suffix":"","desc":"等同`history.go(-1)`\n移动到上一个网址，等同于点击浏览器的后退键。\n注意，移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。","url":"","summary":"","reference":"","dot":""},{"prefix":"history","tag":".forward()","suffix":"","desc":"移动到下一个网址，等同于点击浏览器的前进键。","url":"","summary":"","reference":"","dot":""},{"prefix":"history","tag":".go","suffix":"(n)","desc":"接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址，比如go(1)相当于forward()，go(-1)相当于back()。如果不指定参数，默认参数为0，相当于刷新当前页面。","url":"","summary":"","reference":"","dot":""}]},{"title":"记录","fold":false,"list":[{"prefix":"history","tag":".state","suffix":"","desc":"history 堆栈最上层的状态值","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/bom/history.html\nVue|https://juejin.im/post/5ceedf8ff265da1b80202841","dot":""},{"prefix":"history","tag":".pushState","suffix":"(state,title,path)","desc":"使用pushState()方法在浏览记录（History 对象）中添加一个新记录。\n不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有反应。\n```\nvar stateObj = { foo: 'bar' };\nhistory.pushState(stateObj, 'page 2', '2.html');\n```","url":"","summary":"如果pushState的 URL 参数设置了一个新的锚点值（即hash），并不会触发hashchange事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。","reference":"","dot":""},{"prefix":"history","tag":".replaceState","suffix":"(state,title,path)","desc":"修改 History 对象的当前记录，其他都与pushState()方法一模一样","url":"","summary":"","reference":"","dot":""},{"prefix":"window.on","tag":"popstate","suffix":"","desc":"每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。","url":"","summary":"注意，仅仅调用pushState()方法或replaceState()方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用History.back()、History.forward()、History.go()方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。\n\n回调函数的参数是一个event事件对象，它的state属性指向pushState和replaceState方法为当前 URL 所提供的状态对象（即这两个方法的第一个参数）。上面代码中的event.state，就是通过pushState和replaceState方法，为当前 URL 绑定的state对象。","reference":"","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"window.on","tag":"pageshow","suffix":"","desc":"即使从缓存中加载也会触发该事件\npageshow 事件有一个persisted属性，返回一个布尔值。\n页面第一次加载时，这个属性是false；当页面从缓存加载时，这个属性是true。","url":"","summary":"注意，这两个事件只在浏览器的history对象发生变化时触发，跟网页是否可见没有关系。","reference":"","dot":""},{"prefix":"window.on","tag":"pagehide","suffix":"","desc":"pagehide事件实例也有一个persisted属性\n将这个属性设为true，就表示页面要保存在缓存中；\n设为false，表示网页不保存在缓存中","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Window","barcolor":"","fold":false,"box":[{"title":"事件","fold":false,"list":[{"prefix":"window.on","tag":"load","suffix":"","desc":"文档和资源浏览器窗口加载完毕时\n注意，页面或资源从浏览器缓存加载，并不会触发load事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"window.on","tag":"beforeunload","suffix":"","desc":"在窗口、文档、各种资源将要卸载前触发\n它可以用来防止用户不小心卸载资源","url":"","summary":"如果该事件对象的returnValue属性是一个非空字符串，那么浏览器就会弹出一个对话框，询问用户是否要卸载该资源。但是，用户指定的字符串可能无法显示，浏览器会展示预定义的字符串。如果用户点击“取消”按钮，资源就不会卸载。\n```\nwindow.addEventListener('beforeunload', function (e) {\n  var confirmationMessage = '确认关闭窗口？';\n\n  e.returnValue = confirmationMessage;\n  return confirmationMessage;\n});\n```","reference":"","dot":""},{"prefix":"window.on","tag":"focus","suffix":"","desc":"激活窗口，获得焦点","url":"","summary":"","reference":"","dot":""},{"prefix":"window.on","tag":"blur","suffix":"","desc":"失去焦点","url":"","summary":"","reference":"","dot":""}]},{"title":"窗口","fold":false,"list":[{"prefix":"window.","tag":"name","suffix":"","desc":"当前浏览器窗口的名字","url":"","summary":"只要浏览器窗口不关闭，这个属性是不会消失的。举例来说，访问a.com时，该页面的脚本设置了window.name，接下来在同一个窗口里面载入了b.com，新页面的脚本可以读到上一个网页设置的window.name。页面刷新也是这种情况。一旦浏览器窗口关闭后，该属性保存的值就会消失，因为这时窗口已经不存在了。","reference":"","dot":""},{"prefix":"window.","tag":"closed","suffix":"","desc":"检查当前窗口是否关闭\n`(popup !== null) && !popup.closed`","url":"","summary":"","reference":"","dot":""},{"prefix":"window.","tag":"opener","suffix":"","desc":"打开当前窗口的父窗口。如果当前窗口没有父窗口（即直接在地址栏输入打开），则返回null。","url":"","summary":"通过opener属性，可以获得父窗口的全局属性和方法，但只限于两个窗口同源的情况，且其中一个窗口由另一个打开。a元素添加rel=\"noopener\"属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。","reference":"","dot":""},{"prefix":"window","tag":".open","suffix":"(url,name,opt)","desc":"打开一个新窗口,如果无法新建窗口，则返回null\n`var newWin = window.open('example.html', 'newWindow', 'height=400,width=400');`","url":"","summary":"strWindowFeatures是一个字符串值，这个值列出了将要打开的窗口的一些特性(窗口功能和工具栏) 。 字符串中不能包含任何空白字符，特性之间用逗号分隔开。对于那些可以打开和关闭的属性，设为yes或1或不设任何值就表示打开\n\nleft：新窗口距离屏幕最左边的距离（单位像素）。注意，新窗口必须是可见的，不能设置在屏幕以外的位置。\ntop：新窗口距离屏幕最顶部的距离（单位像素）。\nheight：新窗口内容区域的高度（单位像素），不得小于100。\nwidth：新窗口内容区域的宽度（单位像素），不得小于100。\nouterHeight：整个浏览器窗口的高度（单位像素），不得小于100。\nouterWidth：整个浏览器窗口的宽度（单位像素），不得小于100。\nmenubar：是否显示菜单栏。\ntoolbar：是否显示工具栏。\nlocation：是否显示地址栏。\npersonalbar：是否显示用户自己安装的工具栏。\nstatus：是否显示状态栏。\ndependent：是否依赖父窗口。如果依赖，那么父窗口最小化，该窗口也最小化；父窗口关闭，该窗口也关闭。\nminimizable：是否有最小化按钮，前提是dialog=yes。\nnoopener：新窗口将与父窗口切断联系，即新窗口的window.opener属性返回null，父窗口的window.open()方法也返回null。\nresizable：新窗口是否可以调节大小。\nscrollbars：是否允许新窗口出现滚动条。\ndialog：新窗口标题栏是否出现最大化、最小化、恢复原始大小的控件。\ntitlebar：新窗口是否显示标题栏。\nalwaysRaised：是否显示在所有窗口的顶部。\nalwaysLowered：是否显示在父窗口的底下。\nclose：新窗口是否显示关闭按钮。","reference":"MDN参考|https://developer.mozilla.org/zh-CN/docs/Web/API/Window/open","dot":""},{"prefix":"window","tag":".close()","suffix":"","desc":"关闭当前窗口，一般只用来关闭window.open方法新建的窗口。\n`popup.close()`\n该方法只对顶层窗口有效，iframe框架之中的窗口使用该方法无效。","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".stop()","suffix":"","desc":"完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。","url":"","summary":"","reference":"","dot":""}]},{"title":"视口","fold":false,"list":[{"prefix":"ele.on","tag":"scroll","suffix":"","desc":"页面或元素滚动时，会触发scroll事件，导致执行onscroll()","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/events/common.html","dot":""},{"prefix":"ele.on","tag":"resize","suffix":"","desc":"改变大小时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"document.on","tag":"fullscreenchange","suffix":"","desc":"进入或退出全屏状态时触发\nfullscreenerror事件在浏览器无法切换到全屏状态时触发","url":"","summary":"","reference":"","dot":""}]},{"title":"组件","fold":false,"list":[{"prefix":"window","tag":".print()","suffix":"","desc":"跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。\n桌面设备（比如手机）可能没有打印功能，这时可以这样判断。\n`typeof window.print === 'function'`","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".alert","suffix":"(msg)","desc":"弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。","url":"","summary":"用户只有点击“确定”按钮，对话框才会消失。对话框弹出期间，浏览器窗口处于冻结状态，如果不点“确定”按钮，用户什么也干不了。参数只能是字符串，没法使用 CSS 样式，但是可以用\\n指定换行。","reference":"","dot":""},{"prefix":"window","tag":".prompt","suffix":"(msg,default)","desc":"弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。\n# 返回值\n+ 用户输入信息，并点击“确定”，则用户输入的信息就是返回值。\n+ 用户没有输入信息，直接点击“确定”，则输入框的默认值就是返回值。\n+ 用户点击了“取消”（或者按了 ESC 按钮），则返回值是null。","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".confirm","suffix":"(msg)","desc":"弹出一个对话框\n返回一个布尔值，如果用户点击“确定”，返回true；如果用户点击“取消”，则返回false。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Frame","barcolor":"","fold":false,"box":[{"title":"父框架","fold":false,"list":[{"prefix":"window","tag":".self","suffix":"","desc":"window.self和window.window属性都指向窗口本身。这两个属性只读。","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".frames","suffix":"","desc":"返回一个类似数组的对象，成员为页面内所有框架窗口，包括frame元素和iframe元素。\n`window.frames[0]`表示页面中第一个框架窗口,是一个window对象","url":"","summary":"如果iframe元素设置了id或name属性，那么就可以用属性值，引用这个iframe窗口。比如`<iframe name=\"myIFrame\">`可以用frames['myIFrame']或者frames.myIFrame来引用。","reference":"","dot":""},{"prefix":"frame","tag":".contentWindow","suffix":"","desc":"获得iframe节点包含的window对象\n在满足同源限制的情况下，可以读取子窗口内部的属性。","url":"","summary":"","reference":"","dot":""},{"prefix":"frame","tag":".contentDocument","suffix":"","desc":"子窗口的document对象","url":"","summary":"","reference":"","dot":""}]},{"title":"子框架","fold":false,"list":[{"prefix":"window","tag":".parent","suffix":"","desc":"指向父窗口,如果当前窗口没有父窗口，window.parent指向自身。","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".top","suffix":"","desc":"指向最顶层窗口","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".frameElement","suffix":"","desc":"返回当前窗口所被嵌入的那个元素节点\n对于非嵌入的窗口，该属性等于null。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"postMessage","barcolor":"","fold":false,"box":[{"title":"postMessage","fold":false,"list":[{"prefix":"window","tag":".postMessage","suffix":"(val)","desc":"向window发送信息,不限制同源","url":"","summary":"","reference":"","dot":""},{"prefix":"on","tag":"message","suffix":"","desc":"双方监听消息事件","url":"","summary":"","reference":"","dot":""},{"prefix":"event","tag":".<prop>","suffix":"","desc":"event.data: 消息内容\nevent.source：发送消息的窗口\nevent.origin: 消息发向的网址","url":"","summary":"","reference":"","dot":""}]},{"title":"旧方案","fold":false,"list":[{"prefix":"iframe","tag":"#hash","suffix":"","desc":"片段标识符（fragment identifier）指的是，URL 的#号后面的部分，比如http://example.com/x.html#fragment的#fragment。如果只是改变片段标识符，页面不会重新刷新。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Document","barcolor":"","fold":false,"box":[{"title":"文档","fold":false,"list":[{"prefix":"document.on","tag":"DOMContentLoaded","suffix":"","desc":"DOMContentLoaded事件只有在 DOM 结构生成之后才会触发\n```\ndocument.addEventListener(\"DOMContentLoaded\", function(event) {\n    console.log(document.body.innerHTML);\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"document.on","tag":"readystatechange","suffix":"","desc":"当 Document 对象和 XMLHttpRequest 对象的readyState属性发生变化时触发。\n+ loading（网页正在加载）、\n+ interactive（网页已经解析完成，但是外部资源仍然处在加载状态）\n+ complete（网页和所有外部资源已经结束加载，load事件即将触发）。","url":"","summary":"","reference":"","dot":""},{"prefix":"window.","tag":"document","suffix":"","desc":"只有来自同源的脚本才能读取这个属性","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Source","barcolor":"","fold":false,"box":[{"title":"状态","fold":false,"list":[{"prefix":"source","tag":".complete","suffix":"","desc":"完成状态\n有时候，图片加载会在脚本运行之前就完成，尤其是当脚本放置在网页底部的时候，因此有可能load和error事件的监听函数根本不会执行。所以，比较可靠的方式，是用complete属性先判断一下是否加载完成。","url":"","summary":"","reference":"","dot":""}]},{"title":"进度","fold":false,"list":[{"prefix":"source.on","tag":"load","suffix":"","desc":"资源加载成功时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"source.on","tag":"loadstart","suffix":"","desc":"外部资源开始加载时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"source.on","tag":"progress","suffix":"","desc":"部资源加载过程中不断触发","url":"","summary":"","reference":"","dot":""},{"prefix":"source.on","tag":"loadend","suffix":"","desc":"外部资源停止加载时触发，发生顺序排在error、abort、load等事件的后面\n类似finally性质","url":"","summary":"","reference":"","dot":""}]},{"title":"异常","fold":false,"list":[{"prefix":"source.on","tag":"abort","suffix":"","desc":"资源中止加载时（比如用户取消）触发。\n如果发生错误导致中止，不会触发该事件。","url":"","summary":"ProgressEvent接口主要用来描述外部资源加载的进度，比如 AJAX 加载、img、video、style、link等外部资源加载。进度相关的事件都继承了这个接口。\n+ lengthComputable：布尔值，表示加载的总量是否可以计算，默认是false。\n+ loaded：整数，表示已经加载的量，默认是0。\n+ total：整数，表示需要加载的总量，默认是0。","reference":"","dot":""},{"prefix":"source.on","tag":"error","suffix":"","desc":"由于错误导致资源无法加载时触发。\nerror事件有一个特殊的性质，就是不会冒泡。所以，子元素的error事件，不会触发父元素的error事件监听函数。","url":"","summary":"","reference":"","dot":""},{"prefix":"source.on","tag":"timeout","suffix":"","desc":"加载超时时触发","url":"","summary":"","reference":"","dot":""}]}]},{"title":"交互事件","barcolor":"","fold":false,"box":[{"title":"编辑","fold":false,"list":[{"prefix":"ele","tag":".contenteditable","suffix":"","desc":"允许用户修改内容\n+ true或空字符串：内容可以编辑\n+ false：不可以编辑","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".getSelection()","suffix":"","desc":"返回一个Selection对象，表示用户现在选中的文本\n`selection.toString()` 得到选中的文本","url":"","summary":"","reference":"","dot":""}]},{"title":"解析","fold":false,"list":[]},{"title":"剪贴板","fold":false,"list":[{"prefix":"document.on","tag":"copy","suffix":"","desc":"用户拷贝元素上的内容时触发（包括img）","url":"","summary":"","reference":"","dot":""},{"prefix":"document.on","tag":"cut","suffix":"","desc":"将选中的内容从文档中移除，加入剪贴板时触发\n对于不可编辑的元素，除非设置contenteditable 为 \"true\"","url":"","summary":"","reference":"","dot":""},{"prefix":"document.on","tag":"paste","suffix":"","desc":"用户粘贴元素内容时触发\n对于不可编辑的元素，除非设置contenteditable 为 \"true\"","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".clipboardData","suffix":"","desc":"该属性存放剪贴的数据,只读属性\n是一个 DataTransfer 对象","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"clipboard.js","suffix":"","desc":"","url":"https://github.com/zenorocha/clipboard.js","summary":"","reference":"","dot":""}]},{"title":"焦点","fold":false,"list":[{"prefix":"ele.on","tag":"focus","suffix":"","desc":"获得焦点时,该事件不会冒泡,**只能在捕获阶段触发**\nfocusin：元素节点将要获得焦点时触发，发生在focus事件之前。该事件会冒泡。","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"blur","suffix":"","desc":"失去焦点时,该事件不会冒泡,只能在捕获阶段触发\nfocusout：元素节点将要失去焦点时触发，发生在blur事件之前。该事件会冒泡。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Event","barcolor":"","fold":false,"box":[{"title":"事件","fold":false,"list":[{"prefix":"","tag":"new Event","suffix":"(type,[opt])","desc":"Event对象本身就是一个构造函数，可以用来生成新的实例。\n```\nnew Event('custom',{\n    'bubbles': true,\n    'cancelable': true\n}\n```","url":"","summary":"# 事件传播\n第一阶段：从window对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。\n第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。\n第三阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。\n# 事件代理\n由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。","reference":"参考资料|https://wangdoc.com/javascript/events/model.html","dot":""},{"prefix":"","tag":"new CustomEvent","suffix":"(type,opt)","desc":"自定义的事件实例\nopt.detail：表示事件的附带数据，默认为null。","url":"","summary":"","reference":"","dot":""},{"prefix":"target","tag":".dispatchEvent","suffix":"(evt)","desc":"在当前节点上触发指定事件，从而触发监听函数的执行,参数是**事件对象**。\n该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。","url":"","summary":"```\npara.addEventListener('click', hello, false);\nvar event = new Event('click');\npara.dispatchEvent(event);\n```","reference":"","dot":""}]},{"title":"监听","fold":false,"list":[{"prefix":"target","tag":".addEventListener","suffix":"(type,fn,[opt])","desc":"# `target.addEventListener(type,fn)`\n添加事件监听,监听函数内部的this，指向当前事件所在的那个对象\n+ type：事件名称，大小写敏感。\n+ listener：监听函数。事件发生时，会调用该监听函数。\n第二种属性的值是将会执行的代码，而不是一个函数\n+ useCapture：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为false（监听函数只在冒泡阶段被触发）。\n可以为针对当前对象的同一个事件，添加多个不同的监听函数。这些函数按照添加顺序触发，即先添加先触发。如果为同一个事件多次添加同一个监听函数，该函数只会执行一次，多余的添加将自动被去除\n\n# `target.ontype = fn`\n它的值是函数名，只会在冒泡阶段触发。同一个事件只能定义一个监听函数\n\n# `ele ontype=\"fn()\"`\n属性的值是将会执行的代码，而不是一个函数。只会在冒泡阶段触发","url":"","summary":"第二个参数除了监听函数，还可以是一个具有handleEvent方法的对象\n```\nbuttonElement.addEventListener('click', {\n  handleEvent: function (event) {\n    console.log('click');\n  }\n});\n```\n第三个参数除了布尔值useCapture，还可以是一个属性配置对象。该对象有以下属性。\ncapture：布尔值，表示该事件是否在捕获阶段触发监听函数。\nonce：布尔值，表示监听函数是否只触发一次，然后就自动移除。\npassive：布尔值，表示监听函数不会调用事件的preventDefault方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。","reference":"","dot":""},{"prefix":"target","tag":".removeEventListener","suffix":"(type,fn)","desc":"移除addEventListener方法添加的事件监听函数","url":"","summary":"","reference":"","dot":""}]},{"title":"事件对象","fold":false,"list":[{"prefix":"e","tag":".<prop>","suffix":"","desc":"+ type 返回一个字符串，表示事件类型。事件的类型是在生成事件的时候指定的。该属性只读。\n+ timeStamp 返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。\n+ isTrusted 返回一个布尔值，表示该事件是否由真实的用户行为产生","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".cancelable","suffix":"","desc":"是否可以被取消，即能否用Event.preventDefault()取消这个事件，默认为false\n一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。\n","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".preventDefault()","suffix":"","desc":"取消这个事件，阻止浏览器对该事件的默认行为,不会阻止事件的传播","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".bubbles","suffix":"","desc":"是否冒泡,不影响目标本身触发该事件,默认为false\n如果不是显式指定bubbles属性为true，生成的事件就只能在“捕获阶段”触发监听函数\n`e.eventPhase` 事件的具体阶段","url":"","summary":"# Event.eventPhase\n0，事件目前没有发生。\n1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。\n2，事件到达目标节点，即Event.target属性指向的那个节点。\n3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。","reference":"","dot":""},{"prefix":"e","tag":".stopPropagation()","suffix":"","desc":"阻止冒泡.\n等同`e.cancelBubble = false`\niPhone默认阻止冒泡，故慎用事件委托，给指定元素添加手型样式可开启冒泡，让其认可该为一个可点击区域。","url":"","summary":"","reference":"","dot":""},{"prefix":"e.","tag":"stopImmediatePropagation()","suffix":"","desc":"彻底取消这个事件，使得后面绑定的所有监听函数都不再触发","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".target","suffix":"","desc":"`e.target` 返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。\n`e.currentTarget`属性返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。随着事件的传播，这个属性的值会变。","url":"","summary":"事件发生以后，会经过捕获和冒泡两个阶段，依次通过多个 DOM 节点。因此，任意时点都有两个与事件相关的节点，一个是事件的原始触发节点（Event.target），另一个是事件当前正在通过的节点（Event.currentTarget）。前者通常是后者的后代节点。","reference":"","dot":""},{"prefix":"e","tag":".composedPath()","suffix":"","desc":"返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"鼠标事件","barcolor":"","fold":false,"box":[{"title":"点击","fold":false,"list":[{"prefix":"ele.on","tag":"mousedown","suffix":"","desc":"按下鼠标键时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mouseup","suffix":"","desc":"释放按下的鼠标键时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"click","suffix":"","desc":"左|中键点击事件 onmousedown -> onmouseup -> onclick","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"contextmenu","suffix":"","desc":"右键点击事件 onmousedown -> onmouseup -> oncontextmenu\n指定return false，将不显示浏览器默认菜单","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"dblclick","suffix":"","desc":"左键双击事件 onmousedown -> onmouseup -> onclick -> dblclick","url":"","summary":"","reference":"","dot":""}]},{"title":"移动","fold":false,"list":[{"prefix":"ele.on","tag":"mouseenter","suffix":"","desc":"鼠标进入一个节点时触发，进入子节点不会触发这个事件","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mouseleave","suffix":"","desc":"鼠标离开一个节点时触发，离开父节点不会触发这个事件","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mouseover","suffix":"","desc":"mouseover事件和mouseenter事件，都是鼠标进入一个节点时触发。两者的区别是，mouseenter事件只触发一次，而只要鼠标在节点内部移动，mouseover事件会在子节点上触发多次。","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mouseout","suffix":"","desc":"鼠标离开一个节点时触发，离开父节点也会触发这个事件","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"mousemove","suffix":"","desc":"当鼠标在一个节点内部移动时触发。\n当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。","url":"","summary":"","reference":"","dot":""}]},{"title":"MouseEvent","fold":false,"list":[{"prefix":"e","tag":".<k>Key","suffix":"","desc":"+ ctrlKey：布尔值，是否同时按下了 Ctrl 键，默认值为false。\n+ shiftKey：布尔值，是否同时按下了 Shift 键，默认值为false。\n+ altKey：布尔值，是否同时按下 Alt 键，默认值为false。\n+ metaKey：布尔值，是否同时按下 Meta 键，默认值为false。","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".getModifierState","suffix":"(key)","desc":"返回一个布尔值，表示有没有按下特定的功能键。它的参数是一个表示功能键的字符串。","url":"","summary":"```\ndocument.addEventListener('click', function (e) {\n  console.log(e.getModifierState('CapsLock'));\n}, false);\n```\n上面的代码可以了解用户是否按下了大写键。","reference":"","dot":""},{"prefix":"e","tag":".button","suffix":"[s]","desc":"button：数值，表示按下了哪一个鼠标按键，默认值为0，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；1表示按下辅助键（通常是鼠标的中间键），2表示按下次要键（通常是鼠标的右键）。\nbuttons：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为0（没有按下任何键）。1（二进制001）表示按下主键（通常是左键），2（二进制010）表示按下次要键（通常是右键），4（二进制100）表示按下辅助键（通常是中间键）。因此，如果返回3（二进制011）就表示同时按下了左键和右键。","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".relatedTarget","suffix":"","desc":"节点对象，表示事件的相关节点，默认为null。\n<table><thead><tr><th>事件名称</th><th>target 属性</th><th>relatedTarget 属性</th></tr></thead><tbody><tr><td>focusin</td><td>接受焦点的节点</td><td>丧失焦点的节点</td></tr><tr><td>focusout</td><td>丧失焦点的节点</td><td>接受焦点的节点</td></tr><tr><td>mouseenter</td><td>将要进入的节点</td><td>将要离开的节点</td></tr><tr><td>mouseleave</td><td>将要离开的节点</td><td>将要进入的节点</td></tr><tr><td>mouseout</td><td>将要离开的节点</td><td>将要进入的节点</td></tr><tr><td>mouseover</td><td>将要进入的节点</td><td>将要离开的节点</td></tr><tr><td>dragenter</td><td>将要进入的节点</td><td>将要离开的节点</td></tr><tr><td>dragexit</td><td>将要离开的节点</td><td>将要进入的节点</td></tr></tbody></table>","url":"","summary":"","reference":"","dot":""}]},{"title":"滚轮","fold":false,"list":[{"prefix":"ele.on","tag":"wheel","suffix":"","desc":"滚动鼠标的滚轮时触发\n+ deltaX：数值，表示滚轮的水平滚动量，默认值是 0.0。\n+ deltaY：数值，表示滚轮的垂直滚动量，默认值是 0.0。\n+ deltaZ：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。\n+ deltaMode：数值，表示相关的滚动事件的单位，适用于上面三个属性。0表示滚动单位为像素，1表示单位为行，2表示单位为页，默认为0。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"键盘事件","barcolor":"","fold":false,"box":[{"title":"按键","fold":false,"list":[{"prefix":"ele.on","tag":"keydown","suffix":"","desc":"按下键盘时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"keypress","suffix":"","desc":"按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。\n有值键 onkeydown -> onkeypress -> onkeyup\n无值键 onkeydown -> onkeyup\n按键不松 (onkeydown -> onkeypress)*n -> onkeyup","url":"","summary":"","reference":"","dot":""},{"prefix":"ele.on","tag":"keyup","suffix":"","desc":"松开键盘时触发该事件","url":"","summary":"","reference":"","dot":""}]},{"title":"KeyboardEvent","fold":false,"list":[{"prefix":"e","tag":".key","suffix":"","desc":"字符串，当前按下的键，默认为空字符串。例如“a”","url":"","summary":"","reference":"code|https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code/code_values","dot":""},{"prefix":"e","tag":".repeat","suffix":"","desc":"返回一个布尔值，代表该键是否被按着不放，以便判断是否重复这个键，即浏览器会持续触发keydown和keypress事件，直到用户松开手为止。","url":"","summary":"","reference":"","dot":""},{"prefix":"e.","tag":"<key>Key","suffix":"","desc":"KeyboardEvent.altKey：是否按下 Alt 键\nKeyboardEvent.ctrlKey：是否按下 Ctrl 键\nKeyboardEvent.metaKey：是否按下 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键）\nKeyboardEvent.shiftKey：是否按下 Shift 键","url":"","summary":"","reference":"","dot":""},{"prefix":"e","tag":".getModifierState","suffix":"(key)","desc":"返回一个布尔值，表示是否按下或激活指定的功能键。它的常用参数如下。\nAlt：Alt 键\nCapsLock：大写锁定键\nControl：Ctrl 键\nMeta：Meta 键\nNumLock：数字键盘开关键\nShift：Shift 键","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Touch","barcolor":"","fold":false,"box":[]},{"title":"Drag","barcolor":"","fold":false,"box":[]}]},{"column":[{"title":"File","barcolor":"","fold":false,"box":[{"title":"路径","fold":false,"list":[{"prefix":"","tag":"file://","suffix":"url","desc":"本地文件系统里面的文件","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"data://","suffix":"value","desc":"URL 包含实际数据","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"blob://","suffix":"sign","desc":"表明对应一个 Blob 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象","url":"","summary":"浏览器处理 Blob URL 就跟普通的 URL 一样，如果 Blob 对象不存在，返回404状态码；如果跨域请求，返回403状态码。Blob URL 只对 GET 请求有效，如果请求成功，返回200状态码。由于 Blob URL 就是普通 URL，因此可以下载。","reference":"","dot":""},{"prefix":"URL","tag":".createObjectURL","suffix":"(fileblob)","desc":"为上传/下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了File对象或Blob对象的 URL。","url":"","summary":"```\n// HTML 代码如下\n// <div id=\"display\"/>\n// <input\n//   type=\"file\"\n//   id=\"fileElem\"\n//   multiple\n//   accept=\"image/*\"\n//   onchange=\"handleFiles(this.files)\"\n//  >\nvar div = document.getElementById('display');\n\nfunction handleFiles(files) {\n  for (var i = 0; i < files.length; i++) {\n    var img = document.createElement('img');\n    img.src = window.URL.createObjectURL(files[i]);\n    div.appendChild(img);\n  }\n}\n```\n上面代码中，URL.createObjectURL()方法用来为上传的文件生成一个 URL 字符串，作为img元素的图片来源。\n该方法生成的 URL 就像下面的样子。\n`blob:http://localhost/c745ef73-ece9-46da-8f66-ebes574789b1`","reference":"","dot":""},{"prefix":"URL","tag":".revokeObjectURL","suffix":"(src)","desc":"释放URL.createObjectURL()方法生成的 URL 实例。它的参数就是URL.createObjectURL()方法返回的 URL 字符串。","url":"","summary":"```\nvar div = document.getElementById('display');\n\nfunction handleFiles(files) {\n  for (var i = 0; i < files.length; i++) {\n    var img = document.createElement('img');\n    img.src = window.URL.createObjectURL(files[i]);\n    div.appendChild(img);\n    img.onload = function() {\n      window.URL.revokeObjectURL(this.src);\n    }\n  }\n}\n```\n上面代码中，一旦图片加载成功以后，为本地文件生成的 URL 字符串就没用了，于是可以在img.onload回调函数里面，通过URL.revokeObjectURL()方法卸载这个 URL 实例。","reference":"","dot":""},{"prefix":"FileSaver","tag":" ","suffix":"","desc":"","url":"https://github.com/eligrey/FileSaver.js","summary":"","reference":"","dot":""}]},{"title":"Blob","fold":false,"list":[{"prefix":"","tag":"new Blob","suffix":"(arr,opt)","desc":"表示一个二进制文件的数据内容 `new Blob(arr,{type:'text/html'})`\n第一个参数：数组，成员是字符串或二进制对象\n第二个参数，MIME类型","url":"","summary":"Blob 对象表示一个二进制文件的数据内容，比如一个图片文件的内容就可以通过 Blob 对象读写。它通常用来读写文件，它的名字是 Binary Large Object （二进制大型对象）的缩写。它与 ArrayBuffer 的区别在于，它用于操作二进制文件，而 ArrayBuffer 用于操作内存。\nBlob构造函数接受两个参数。第一个参数是数组，成员是字符串或二进制对象，表示新生成的Blob实例对象的内容；第二个参数是可选的，是一个配置对象，目前只有一个属性type，它的值是一个字符串，表示数据的 MIME 类型，默认是空字符串。","reference":"","dot":""},{"prefix":"blob","tag":".size","suffix":"","desc":"返回数据的大小\nUTF-8编码：一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。 \nUnicode编码：一个英文等于两个字节，一个中文（含繁体）等于两个字节。","url":"","summary":"","reference":"","dot":""},{"prefix":"blob","tag":".type","suffix":"","desc":"返回数据的类型","url":"","summary":"","reference":"","dot":""},{"prefix":"blob","tag":".slice","suffix":"[start,end)","desc":"拷贝原来的数据，返回的也是一个Blob实例","url":"","summary":"","reference":"","dot":""}]},{"title":"FileList","fold":false,"list":[{"prefix":"filelist","tag":".item","suffix":"(i)","desc":"FileList 对象，该对象是一个类似数组的成员，每个成员都是一个 File 实例对象\nFile 实例对象是一个特殊的 Blob 实例\n+ 文件选择器 ele.files[0]\n+ 拖放 dataTransfer.files[i]","url":"","summary":"文件选择器<input type=\"file\">用来让用户选取文件。出于安全考虑，浏览器不允许脚本自行设置这个控件的value属性，即文件必须是用户手动选取的，不能是脚本指定的。一旦用户选好了文件，脚本就可以读取这个文件。\n文件选择器返回一个 FileList 对象，该对象是一个类似数组的成员，每个成员都是一个 File 实例对象。File 实例对象是一个特殊的 Blob 实例，增加了name和lastModifiedDate属性。\n除了文件选择器，拖放 API 的dataTransfer.files返回的也是一个FileList 对象，它的成员因此也是 File 实例对象","reference":"","dot":""},{"prefix":"fileblob","tag":".name","suffix":"","desc":"文件名，不含路径","url":"","summary":"","reference":"","dot":""},{"prefix":"fileblob","tag":".lastModifiedDate","suffix":"","desc":"文件的最后修改时间","url":"","summary":"","reference":"","dot":""}]},{"title":"FileReader","fold":false,"list":[{"prefix":"","tag":"new FileReader()","suffix":"","desc":"通过FileReader对象，读取 Blob 对象的内容，即文件内容","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".readAsText","suffix":"(data,[encoding])","desc":"返回文本，需要指定文本编码，默认为 UTF-8。\n根据特殊的编码格式转化为内容(字符串形式),这个方法是异步的，也就是说，只有当执行完成后才能够查看到结果，如果直接查看是无结果的，并返回undefined","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".readAsArrayBuffer","suffix":"(data)","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".readAsDataURL","suffix":"(data)","desc":"开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的Base64字符串以表示所读取文件的内容。","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".onload","suffix":" = fn","desc":"该事件在读取操作完成时触发\n+ onabort 在读取操作被中断时触发。\n+ onerror 在读取操作发生错误时触发。\n+ onload 在读取操作完成时触发。\n+ onloadstart 在读取操作开始时触发。\n+ onloadend 在读取操作结束时（要么成功，要么失败）触发。\n+ onprogress 在读取Blob时触发。\n+ readyState：整数，表示读取文件时的当前状态。一共有三种可能的状态，0表示尚未加载任何数据，1表示数据正在加载，2表示加载完成。","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader","dot":""},{"prefix":"reader","tag":".result","suffix":"","desc":"文件的内容,该属性仅在读取操作完成后才有效\n数据的格式取决于使用哪个方法来启动读取操作。","url":"","summary":"","reference":"","dot":""},{"prefix":"reader","tag":".abort()","suffix":"","desc":"中止读取操作","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Form","barcolor":"","fold":false,"box":[{"title":"文件","fold":false,"list":[{"prefix":"","tag":"accept","suffix":"","desc":"input type=\"file\"的accept属性表示允许选择的文件类型，使用逗号分隔。\n+ 可以使用 MIME 类型（比如`image/jpeg`）\n+ 也可以使用后缀名（比如`.doc`）\n+ 还可以使用`audio/*`（任何音频文件）、`video/*`（任何视频文件）、`image/*`（任何图像文件）等表示法","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"Web Worker","barcolor":"","fold":false,"box":[{"title":"主线程","fold":false,"list":[{"prefix":"","tag":"new Worker","suffix":"(path.js,[opt])","desc":"新建一个 Worker 线程,必须同源\n也可以是一个blob url","url":"","summary":"通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。\n```\n<script id=\"worker\" type=\"app/worker\">\n  addEventListener('message', function () {\n    postMessage('some message');\n  }, false);\n</script>\n```\n上面是一段嵌入网页的脚本，注意必须指定<script>标签的type属性是一个浏览器不认识的值，上例是app/worker。\n然后，读取这一段嵌入页面的脚本，用 Worker 来处理。\n```\nvar blob = new Blob([document.querySelector('#worker').textContent]);\nvar url = window.URL.createObjectURL(blob);\nvar worker = new Worker(url);\n\nworker.onmessage = function (e) {\n  // e.data === 'some message'\n};\n```","reference":"","dot":""},{"prefix":"worker","tag":".postMessage","suffix":"(data)","desc":"参数可以是各种数据类型，包括二进制数据。\n这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。","url":"","summary":"","reference":"","dot":""},{"prefix":"worker","tag":".postMessage","suffix":"(buf,[buf])","desc":"快速转移arrayBuffer数据，主线程将失去控制权，非拷贝方式。\n```\nvar a = new ArrayBuffer(1);\nworker.postMessage(a, [a]);\nvar b = new Uint8Array(1);\nworker.postMessage({x:y,b:b.buffer}, [b.buffer])\n```","url":"","summary":"拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。","reference":"","dot":""},{"prefix":"worker","tag":".onmessage","suffix":"","desc":"主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息\ne.data 获取数据","url":"","summary":"","reference":"","dot":""},{"prefix":"worker","tag":".terminate()","suffix":"","desc":"关闭worker线程","url":"","summary":"","reference":"","dot":""},{"prefix":"worker","tag":".onerror","suffix":"","desc":"线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的error事件\nWorker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。","url":"","summary":"","reference":"","dot":""}]},{"title":"Worker线程","fold":false,"list":[{"prefix":"","tag":"self","suffix":"","desc":"代表子线程自身，即子线程的全局对象\n无法使用document、window、parent这些对象,但是，Worker 线程可以使用navigator对象和location对象。","url":"","summary":"","reference":"","dot":""},{"prefix":"self","tag":".postMessage","suffix":"(data)","desc":"向产生这个 Worker 线程发送消息","url":"","summary":"","reference":"","dot":""},{"prefix":"self","tag":".onmessage","suffix":"","desc":"根据主线程发来的数据，Worker 线程可以调用不同的方法","url":"","summary":"```\nself.addEventListener('message', function (e) {\n  var data = e.data;\n  switch (data.cmd) {\n    case 'start':\n      self.postMessage('WORKER STARTED: ' + data.msg);\n      break;\n    case 'stop':\n      self.postMessage('WORKER STOPPED: ' + data.msg);\n      self.close(); // Terminates the worker.\n      break;\n    default:\n      self.postMessage('Unknown command: ' + data.msg);\n  };\n}, false);\n```","reference":"","dot":""},{"prefix":"","tag":"importScripts","suffix":"(mod.js,..)","desc":"加载其他脚本","url":"","summary":"","reference":"","dot":""},{"prefix":"self","tag":".close()","suffix":"","desc":"在 Worker 内部关闭自身","url":"","summary":"","reference":"","dot":""}]}]},{"title":"Perfomance","barcolor":"","fold":false,"box":[{"title":"重排回调","fold":false,"list":[{"prefix":"window","tag":".requestAnimationFrame","suffix":"(fn)","desc":"在下次重绘之前调用指定的回调函数更新动画。\n该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行\n返回一个ID","url":"","summary":"window.requestAnimationFrame()方法跟setTimeout类似，都是推迟某个函数的执行。不同之处在于，setTimeout必须指定推迟的时间，window.requestAnimationFrame()则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。重绘通常是 16ms 执行一次，不过浏览器会自动调节这个速率，比如网页切换到后台 Tab 页时，requestAnimationFrame()会暂停执行。","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame","dot":""},{"prefix":"window","tag":".cancelAnimationFrame","suffix":"(id)","desc":"取消回调函数的执行","url":"","summary":"","reference":"MDN参考|https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame","dot":""}]},{"title":"空闲回调","fold":false,"list":[{"prefix":"window","tag":".requestIdleCallback","suffix":"(fn,deadline)","desc":"将某个函数推迟执行，但是它保证将回调函数推迟到系统资源空闲时执行\n`requestIdleCallback(callback, { timeout: 2000 });` 设定最大死线","url":"","summary":"","reference":"","dot":""},{"prefix":"window","tag":".cancelIdleCallback","suffix":"(id)","desc":"取消回调函数","url":"","summary":"","reference":"","dot":""}]}]}]}]}