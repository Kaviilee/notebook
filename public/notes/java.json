{"version":1581327972990,"name":"java","data":[{"column":[{"title":"数据类型","barcolor":"","fold":false,"box":[{"title":"数据类型","fold":false,"list":[{"prefix":"","tag":"整型 ","suffix":"int","desc":"byte,short,int,long\n默认值0,0,0,0L","url":"","summary":"byte：\nbyte 数据类型是8位、有符号的，以二进制补码表示的整数；\n最小值是 -128（-2^7）；\n最大值是 127（2^7-1）；\n默认值是 0；\nbyte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n例子：byte a = 100，byte b = -50。\n---------------\nshort：\nshort 数据类型是 16 位、有符号的以二进制补码表示的整数\n最小值是 -32768（-2^15）；\n最大值是 32767（2^15 - 1）；\nShort 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n默认值是 0；\n例子：short s = 1000，short r = -20000。\n---------------\nint：\nint 数据类型是32位、有符号的以二进制补码表示的整数；\n最小值是 -2,147,483,648（-2^31）；\n最大值是 2,147,483,647（2^31 - 1）；\n一般地整型变量默认为 int 类型；\n默认值是 0 ；\n例子：int a = 100000, int b = -200000。\n---------------\nlong：\nlong 数据类型是 64 位、有符号的以二进制补码表示的整数；\n最小值是 -9,223,372,036,854,775,808（-2^63）；\n最大值是 9,223,372,036,854,775,807（2^63 -1）；\n这种类型主要使用在需要比较大整数的系统上；\n默认值是 0L；\n例子： long a = 100000L，Long b = -200000L。\n\"L\"理论上不分大小写，但是若写成\"l\"容易与数字\"1\"混淆，不容易分辩。所以最好大写。","reference":"","dot":""},{"prefix":"","tag":"浮点型 ","suffix":"float / double","desc":"float,默认值是 0.0f\ndouble,默认值是 0.0d","url":"","summary":"float：\nfloat 数据类型是单精度、32位、符合IEEE 754标准的浮点数；\nfloat 在储存大型浮点数组的时候可节省内存空间；\n默认值是 0.0f；\n浮点数不能用来表示精确的值，如货币；\n例子：float f1 = 234.5f。\n----------------\ndouble：\ndouble 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；\n浮点数的默认类型为double类型；\ndouble类型同样不能表示精确的值，如货币；\n默认值是 0.0d；\n例子：double d1 = 123.4。","reference":"","dot":""},{"prefix":"","tag":"布尔型 ","suffix":"boolean","desc":"值：true,false","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"字符型 ","suffix":"char","desc":"默认值：'u0000'","url":"","summary":"字节型，byte 数据类型是8位、有符号的，以二进制补码表示的整数\n字符型，char类型是一个单一的 16 位 Unicode 字符","reference":"","dot":""},{"prefix":"","tag":"字符串 ","suffix":"String","desc":"默认值null","url":"","summary":"","reference":"","dot":""}]},{"title":"类型检测","fold":false,"list":[{"prefix":"x ","tag":"instanceof ","suffix":"y","desc":"检查该对象是否是一个特定类型（类类型或接口类型）","url":"","summary":"","reference":"","dot":""}]},{"title":"类型转换","fold":false,"list":[{"prefix":"","tag":"(type) ","suffix":"x","desc":"强制类型转换条件是转换的数据类型必须是兼容的","url":"","summary":"自动类型转换中必须满足转换前的数据类型的位数要低于转换后的数据类型。\n整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。转换从低级到高级。\nbyte,short,char—> int —> long—> float —> double \n-----------\n1. 不能对boolean类型进行类型转换。\n2. 不能把对象类型转换成不相关类的对象。\n3. 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。\n4. 转换过程中可能导致溢出或损失精度\n5. **浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入**","reference":"","dot":""}]}]},{"title":"语法","barcolor":"","fold":false,"box":[{"title":"声明与作用域","fold":false,"list":[{"prefix":"","tag":"type ","suffix":"x = val","desc":"声明变量","url":"","summary":"# 局部变量\n局部变量声明在方法、构造方法或者语句块中；\n局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；\n**访问修饰符不能用于局部变量；**\n局部变量只在声明它的方法、构造方法或者语句块中可见；\n局部变量是在栈上分配的。\n**局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。**\n\n---------------\n\n# 实例变量\n实例变量声明在一个类中，但在方法、构造方法和语句块之外；\n当一个对象被实例化之后，每个实例变量的值就跟着确定；\n实例变量在对象创建的时候创建，在对象被销毁的时候销毁；\n实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；\n实例变量可以声明在使用前或者使用后；\n访问修饰符可以修饰实例变量；\n实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\n实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；\n实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。\n\n---------------\n\n# 类变量（静态变量）\n类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。\n无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。\n静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。\n静态变量在第一次被访问时创建，在程序结束时销毁。\n与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。\n默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n静态变量可以通过：ClassName.VariableName的方式访问。\n类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。","reference":"","dot":""},{"prefix":"","tag":"final ","suffix":"x = val","desc":"声明常量","url":"","summary":"","reference":"","dot":""}]},{"title":"访问修饰符","fold":true,"list":[{"prefix":"","tag":"default","suffix":"","desc":"在同一包内可见，不使用任何修饰符。\n使用对象：类、接口、变量、方法。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"public","suffix":"","desc":"对所有类可见。\n使用对象：类、接口、变量、方法","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"protected","suffix":"","desc":"对同一包内的类和所有子类可见。\n使用对象：变量、方法。 注意：不能修饰类（外部类）。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"private","suffix":"","desc":"在同一类内可见。\n使用对象：变量、方法。 注意：不能修饰类（外部类）","url":"","summary":"","reference":"","dot":""}]},{"title":"非访问修饰符","fold":true,"list":[{"prefix":"","tag":"static","suffix":"","desc":"用来修饰类方法和类变量。\n无论一个类实例化多少对象，它的静态变量只有一份拷贝。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"final","suffix":"","desc":"用来修饰类、方法和变量\nfinal 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。\n被 final 修饰的实例变量必须显式指定初始值。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"abstract","suffix":"","desc":"用来创建抽象类和抽象方法","url":"","summary":"抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。\n一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。","reference":"","dot":""},{"prefix":"","tag":"synchronized","suffix":"","desc":"同一时间只能被一个线程访问","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"volatile","suffix":"","desc":"volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"transient","suffix":"","desc":"序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。\n该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。","url":"","summary":"","reference":"","dot":""}]},{"title":"运算符","fold":false,"list":[{"prefix":"","tag":"算术运算符","suffix":"","desc":"加法运算符：x + y\n减法运算符： x - y\n乘法运算符： x * y\n除法运算符：x / y\n余数运算符：x % y\n自增运算符：++x 或者 x++\n自减运算符：--x 或者 x--","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"关系运算符","suffix":"","desc":"\\> 大于运算符\n\\< 小于运算符\n>= 大于或等于运算符\n<= 小于或等于运算符\n== 相等运算符\n!= 不相等运算符","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"逻辑运算符","suffix":"","desc":"取反运算符：!\n且运算符：&&\n或运算符：||","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"位运算符","suffix":"","desc":"| 按位或\n& 按位与\n~ 按位取反\n^ 按位异或\n\\<< 左移运算符 \n\n>> 右移运算符\n\n\\>>> 头部补零的右移运算符","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"赋值运算符","suffix":"","desc":"+= -= *= **= /= %= &= |= ^= <<= >>=","url":"","summary":"","reference":"","dot":""}]},{"title":"流程控制","fold":false,"list":[{"prefix":"","tag":"if..else","suffix":"","desc":"if(exp){...} \nif(exp){...}else{...}\nif(exp){...}else if(exp){...}","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"switch","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"循环语句","fold":false,"list":[{"prefix":"","tag":"while","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"do..while","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"for","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"break","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"continue","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]}]},{"title":"其它","barcolor":"","fold":false,"box":[{"title":"安装与编译","fold":false,"list":[{"prefix":"","tag":"javac ","suffix":"file","desc":"编译file.java\njava文件需以gbk编码保存","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"java ","suffix":"file","desc":"执行file.class","url":"","summary":"","reference":"","dot":""}]}]}]}]}