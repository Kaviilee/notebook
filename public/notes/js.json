{"version":1582037646835,"name":"js","data":[{"column":[{"title":"数据类型","barcolor":"","fold":false,"box":[{"title":"数据类型","fold":false,"list":[{"prefix":"","tag":"number","suffix":"","desc":"基本类型，数字类型只有一个整数: 0","url":"","summary":"根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(263 -1) 到 263 -1） ","reference":"","dot":""},{"prefix":"","tag":"boolean","suffix":"","desc":"基本类型，值true,false","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"string ","suffix":"+","desc":"基本类型，字符串连接符 +\n模板字符串\\`${var}\\`\n使用str.concat(str,..)方法时，如果参数不是字符串，concat方法会将其先转为字符串，然后再连接。","url":"","summary":"如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。\n```javascript\nvar longString = 'Long \\\nlong \\\nlong \\\nstring';\n\nlongString\n// \"Long long long string\"\n```","reference":"","dot":""},{"prefix":"","tag":"array","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"enum ","suffix":"","desc":"枚举\nenum Color {Red, Green, Blue}\nlet c: Color = Color.Green;","url":"","summary":"","reference":"","dot":"#ffa500"},{"prefix":"","tag":"object","suffix":"","desc":"对象：引用类型（包括数组、函数、标准对象等）","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"symbol","suffix":"","desc":"符号类型是唯一的并且是不可修改的,可以用来作为Object的key的值","url":"","summary":"如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。","reference":"","dot":""},{"prefix":"","tag":"undefined","suffix":"","desc":"一个没有被赋值的变量会有个默认值 undefined","url":"","summary":"不存在的变量与未声明的变量typeof检测均为undefined，但两者其实不同，故建议总是初始化。 ","reference":"","dot":""},{"prefix":"","tag":"null","suffix":"","desc":"空：原始类型\nNull 类型只有一个值： null","url":"","summary":"1.判断null请使用myVar === null。Null 类型是一个只有一个值的数据类型，即特殊的值 null。它表示一个空对象引用(指针)，而 typeof 操作符检测 null 会返回 object。如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null。这样，当检查 null 值就知道是否已经变量是否已经分配了对象引用了。\n2.undefined 是派生自 null 的，因此 ECMA-262 规定对它们的相等性测试返回 true。alert(undefined == null);但typeof数据类型不等。","reference":"内存优化|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management","dot":""}]},{"title":"类型检测","fold":false,"list":[{"prefix":"","tag":"typeof ","suffix":"val","desc":"返回类型字符串 ","url":"","summary":"可通过Object.prototype.toString.call(o)测试\n<table>\n    <tr>\n        <th>类型</th>\n        <th>结果</th>\n    </tr>\n    <tr>\n        <td>数值/NaN</td>\n        <td>number</td>\n    </tr>\n    <tr>\n        <td>BigInt</td>\n        <td>bigint</td>\n    </tr>\n    <tr>\n        <td>true/false</td>\n        <td>boolean</td>\n    </tr>\n    <tr>\n        <td>字符串/JSON</td>\n        <td>string</td>\n    </tr>\n    <tr>\n        <td>fn</td>\n        <td>function</td>\n    </tr>\n    <tr>\n        <td>obj/数组/null</td>\n        <td>object</td>\n    </tr>\n    <tr>\n        <td>Symbol</td>\n        <td>symbol</td>\n    </tr>\n    <tr>\n        <td>undefined/不存在的属性或方法</td>\n        <td>undefined</td>\n    </tr>\n</table>","reference":"Lodash-Lang|https://www.lodashjs.com/docs/latest","dot":""},{"prefix":"val ","tag":"instanceof ","suffix":"type","desc":"instanceof运算符返回一个布尔值，表示某个对象是否为指定的构造函数的实例。","url":"","summary":"<table>\n    <tr>\n        <th>测试目标</th>\n        <th>测试结果</th>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>arr instanceof Array</td>\n    </tr>\n    <tr>\n        <td>函数/构造函数</td>\n        <td>fn instanceof Function</td>\n    </tr>\n    <tr>\n        <td>构造函数实例</td>\n        <td>child instanceof parent</td>\n    </tr>\n    <tr>\n        <td>泛对象</td>\n        <td>obj instanceof Object</td>\n    </tr>\n    <tr>\n        <td>日期</td>\n        <td>value instanceof Date</td>\n    </tr>\n    <tr>\n        <td>正则表达式</td>\n        <td>value instanceof RegExp</td>\n    </tr>\n    <tr>\n        <td>数学</td>\n        <td>value instanceof Math</td>\n    </tr>\n</table>","reference":"","dot":""},{"prefix":"","tag":"(val as type) ","suffix":"","desc":"类型断言","url":"","summary":"","reference":"","dot":"#ffa500"}]},{"title":"类型转换/创建","fold":false,"list":[{"prefix":"","tag":"Number","suffix":"(val)","desc":"+数值运算符,-负值运算符,~~取整运算","url":"","summary":"<table>\n    <tr>\n        <th>value</th>\n        <th>返回值</th>\n    </tr>\n    <tr>\n        <td>number/包含单个数值的数组</td>\n        <td>number</td>\n    </tr>\n    <tr>\n        <td>boolean</td>\n        <td>1 / 0</td>\n    </tr>\n    <tr>\n        <td>null/空字符串/空数组</td>\n        <td>0</td>\n    </tr>\n    <tr>\n        <td>undefined/string/object</td>\n        <td>NaN</td>\n    </tr>\n</table>","reference":"","dot":""},{"prefix":"","tag":"Boolean","suffix":"(val)","desc":"!取反运算符 !!布尔运算","url":"","summary":"0、-0、null、false、NaN、undefined、空字符串（\"\"）、document.all\n以上均生成值为false的Boolean对象\n注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。","reference":"","dot":""},{"prefix":"","tag":"String","suffix":"(val)","desc":"+''加空字符串，toString()方法","url":"","summary":"<table>\n    <tr>\n        <th>value</th>\n        <th>返回值</th>\n    </tr>\n    <tr>\n        <td>数值</td>\n        <td>转为相应的字符串</td>\n    </tr>\n    <tr>\n        <td>字符串</td>\n        <td>转换后还是原来的值</td>\n    </tr>\n    <tr>\n        <td>布尔值</td>\n        <td>true转为\"true\"，false转为\"false\"</td>\n    </tr>\n    <tr>\n        <td>undefined</td>\n        <td>转为\"undefined\"</td>\n    </tr>\n    <tr>\n        <td>null</td>\n        <td>转为\"null\"</td>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>返回该数组的字符串形式  \"1,2,3\"</td>\n    </tr>\n    <tr>\n        <td>对象</td>\n        <td>返回一个类型字符串 \"[object Object]\" <br>可通过toString方法来设置修改</td>\n    </tr>\n</table>","reference":"","dot":""},{"prefix":"","tag":"类型转换表","suffix":"","desc":"1.空数组/对象转为布尔为true\n2.字符串“0”转为布尔为true","url":"","summary":"<table>\n <tbody><tr>\n  <th>原始值</th>\n  <th>转换为数字</th>\n  <th>转换为字符串</th>\n  <th>转换为布尔值</th>\n </tr>\n <tr>\n  <td>false</td>\n  <td>0</td>\n  <td>\"false\"</td>\n  <td>false</td>\n </tr>\n <tr>\n  <td>true</td>\n  <td>1</td>\n  <td>\"true\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>0</td>\n  <td>0</td>\n  <td>\"0\"</td>\n  <td>false</td>\n </tr>\n <tr>\n  <td>1</td>\n  <td>1</td>\n  <td>\"1\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>\"0\"</td>\n  <td>0</td>\n  <td>\"0\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>\"000\"</td>\n  <td>0</td>\n  <td>\"000\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>\"1\"</td>\n  <td>1</td>\n  <td>\"1\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>NaN</td>\n  <td>NaN</td>\n  <td>\"NaN\"</td>\n  <td>false</td>\n </tr>\n <tr>\n  <td>Infinity</td>\n  <td>Infinity</td>\n  <td>\"Infinity\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>-Infinity</td>\n  <td>-Infinity</td>\n  <td>\"-Infinity\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>\"\"</td>\n  <td>0</td>\n  <td>\"\"</td>\n  <td>false</td>\n </tr>\n <tr>\n  <td>\"20\"</td>\n  <td>20</td>\n  <td>\"20\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>\"Runoob\"</td>\n  <td>NaN</td>\n  <td>\"Runoob\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>[ ]</td>\n  <td>0</td>\n  <td>\"\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>[20]</td>\n  <td>20</td>\n  <td>\"20\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>[10,20]</td>\n  <td>NaN</td>\n  <td>\"10,20\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>[\"Runoob\"]</td>\n  <td>NaN</td>\n  <td>\"Runoob\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>[\"Runoob\",\"Google\"]</td>\n  <td>NaN</td>\n  <td>\"Runoob,Google\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>function(){}</td>\n  <td>NaN</td>\n  <td>\"function(){}\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>{ }</td>\n  <td>NaN</td>\n  <td>\"[object Object]\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>null</td>\n  <td>0</td>\n  <td>\"null\"</td>\n  <td>false</td>\n </tr>\n <tr>\n  <td>undefined</td>\n  <td>NaN</td>\n  <td>\"undefined\"</td>\n  <td>false</td>\n </tr>\n</tbody></table>","reference":"类型转换表|https://www.runoob.com/js/js-type-conversion.html","dot":""}]}]},{"title":"语法","barcolor":"","fold":false,"box":[{"title":"声明与作用域","fold":false,"list":[{"prefix":"","tag":"var ","suffix":"x = val","desc":"1.变量会提升，在没有声明前调用，会输出undefined\n2.假设声明a、b、c,且c=a+b，且均为非引用类型，当ab发生变化时，c不会改变，应设为c=fn(return a+b)","url":"","summary":"","reference":"3种全局变量的异同|http://snandy.iteye.com/blog/720816","dot":""},{"prefix":"","tag":"let ","suffix":"x = val","desc":"申明一个块级作用域的变量 let i = 1;\n不能使用let重复定义一个变量 ","url":"","summary":"只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响，暂时性死区。","reference":"","dot":""},{"prefix":"","tag":"let x:type ","suffix":"= val","desc":"ts强类型：number,boolean,string,$enum\n数组：type[],Array<type>\n元组：[type1,type2]\n任意：any\n空值：void\n特殊：never","url":"","summary":"---------------\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 \n比如，你可以定义一对值分别为string和number类型的元组。\n```typescript\n// Declare a tuple type\nlet x: [string, number];\n// Initialize it\nx = ['hello', 10]; // OK\n// Initialize it incorrectly\nx = [10, 'hello']; // Error\n```\n\n某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是void\n```typescript\nfunction warnUser(): void {\n    alert(\"This is my warning message\");\n}\n```\n\nnever类型表示的是那些永不存在的值的类型。 例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。\n```typescript\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// 推断的返回值类型为never\nfunction fail() {\n    return error(\"Something failed\");\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n    while (true) {\n    }\n}\n```","reference":"","dot":"#ffa500"},{"prefix":"","tag":"const ","suffix":"x = val","desc":"const PI = 3.14\n一旦声明，常量的指针就不能改变（仅指针，非值本身）                   ","url":"","summary":"1.const来定义常量，在声明时就必须赋值。\n2.const与let都具有块级作用域。","reference":"","dot":""},{"prefix":"Destructuring","tag":" ","suffix":"解构","desc":"解构赋值允许指定默认值。\nlet [x, y = 'b'] = ['a']; // x='a', y='b'","url":"http://es6.ruanyifeng.com/#docs/destructuring#%E7%94%A8%E9%80%94","summary":"","reference":"","dot":""}]},{"title":"运算符","fold":true,"list":[{"prefix":"","tag":"算术运算符","suffix":"","desc":"加法运算符：x + y\n减法运算符： x - y\n乘法运算符： x * y\n指数运算符：x ** y\n除法运算符：x / y\n余数运算符：x % y\n自增运算符：++x 或者 x++\n自减运算符：--x 或者 x--\n数值运算符： +x\n负数值运算符：-x","url":"","summary":"# + 加法\n1. 有字符串参与的都转为字符串拼接\n2. 对象的转换会先调用valueOf方法（返回自身），再调用toString方法\n特例：如果运算子是一个Date对象的实例，那么会优先执行toString方法。\n\n# % 余数\n运算结果的正负号由第一个运算子的正负号决定\n为了得到负数的正确余数值，可以先使用绝对值函数\n```javascript\n-1 % 2 // -1\n1 % -2 // 1\n```\n\n# ++ -- 自增/减运算符\n自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。\n```javascript\nvar x = 1;\nvar y = 1;\nx++ // 1\n++y // 2\n```\nx是先返回当前值，然后自增，所以得到1；y是先自增，然后返回新的值，所以得到2。\n\n# 指数运算符\n注意，指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。\n```javascript\n// 相当于 2 ** (3 ** 2)\n2 ** 3 ** 2\n// 512\n```","reference":"","dot":""},{"prefix":"","tag":"关系运算符","suffix":"","desc":"\\> 大于运算符\n\\< 小于运算符\n>= 大于或等于运算符\n<= 小于或等于运算符\n== 相等运算符\n=== 严格相等运算符\n!= 不相等运算符\n!== 严格不相等运算符","url":"","summary":"# 特殊\n任何值（包括NaN本身）与NaN比较，返回的都是false。\n\n# 非严格比较\n1. 先将数据进行类型转换，然后再用严格相等运算符比较。\n2. 对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；\n3. 否则，将两个运算子都转成数值，再比较数值的大小。\n4. 对于两个对象的比较，大于或小于运算符比较的是值。（算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法）\n\n# 严格比较\n1. 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。\n2. 特殊类型总是使用严格比较","reference":"特殊类型比较|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness\n比较运算符|http://wangdoc.com/javascript/operators/comparison.html","dot":""},{"prefix":"","tag":"逻辑运算符","suffix":"","desc":"取反运算符：!\n且运算符：&&\n或运算符：||\n三元运算符：?:","url":"","summary":"# 且运算符 && \n如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；\n如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。\n且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。如果所有表达式的布尔值都为true，则返回最后一个表达式的值。\n短路：多个接力执行\n\n# 或运算符 ||\n如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；\n如果第一个运算子的布尔值为false，则返回第二个运算子的值。\n或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值。如果所有表达式都为false，则返回最后一个表达式的值。\n短路：备用默认值\n\n# 三元运算符 ?:\n通常来说，三元条件表达式与if...else语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，if...else是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合（赋值），只能使用三元条件表达式，而不能使用if..else。在需要复杂的语句和逻辑时，使用流程控制而不是三元表达式。\n","reference":"布尔运算符|http://wangdoc.com/javascript/operators/boolean.html","dot":""},{"prefix":"","tag":"位运算符","suffix":"","desc":"| 按位或\n& 按位与\n~ 按位取反\n^ 按位异或\n\\<< 左移运算符 \n\n>> 右移运算符\n\n\\>>> 头部补零的右移运算符","url":"","summary":"1. 位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。\n2. 在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。\n```javascript\ni = i | 0; //将任意数值转为32位整数,舍去大于32位的数位,舍去小数\n~~2.9 //舍去小数取整\n```\n3. 左移运算符乘以2的指定次方，右移运算符除以2的指定次方\n4. >>> 查看一个负整数在计算机内部的储存形式\n\n----------------\n\n正整数的补码是其二进制表示，与原码相同\n求负整数的补码，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1\n已知一个数的补码，求原码的操作其实就是对该补码再求补码","reference":"原码，反码，补码详解|https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html","dot":""},{"prefix":"","tag":"赋值运算符","suffix":"","desc":"+= -= *= **= /= %= &= |= ^= <<= >>=","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"逗号运算符","suffix":"","desc":"逗号运算符用于对两个表达式求值，并返回后一个表达式的值。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"void","suffix":"(exp)","desc":"void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined","url":"","summary":"","reference":"","dot":""}]},{"title":"流程控制","fold":true,"list":[{"prefix":"","tag":"if..else..","suffix":"","desc":"if(exp){...} //仅有一个语句时，可省略{}\nif(exp){...}else{...}\nif(exp){...}else if(exp){...}","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"switch","suffix":"","desc":"1.switch中的case为全等判断\n2.多个case使用同一个执行块应写为case 1: case2: ... \n3.每个case代码块内部的break不能少，否则会接着执行下一个case\n4.default用于在上面所有 case 都不为真时执行一个任务。\n```javascript\nswitch(x){\n    case val1 :\n        ...\n        break;\n    default :\n        ...\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"x?y:z","suffix":"","desc":"仅可连接表达式，最终有一个返回值","url":"","summary":"","reference":"","dot":""}]},{"title":"循环语句","fold":true,"list":[{"prefix":"","tag":"while","suffix":"","desc":"while(exp){...}//仅有一个语句时，可省略{}","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"do..while","suffix":"","desc":"该循环会在检查条件是否为真之前执行一次代码块\n```javascript\ndo{\n    需要执行的代码\n}while(条件);\n```\nwhile语句后面的分号注意不要省略。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"for","suffix":"","desc":"设置循环变量的部分和循环体内部有各自单独的作用域，变量彼此不影响（使用let时）。\n```javascript\nfor (初始化表达式; 条件; 递增表达式) {\n    语句\n}\n```","url":"","summary":"初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。\n条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。\n递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。","reference":"","dot":""},{"prefix":"","tag":"break ","suffix":"[label]","desc":"不带参数时：break终止内层循环\n带参数时：break终止label处后面全部循环","url":"","summary":"标签也可以用于跳出代码块。\n```javascript\nfoo: {\n  console.log(1);\n  break foo;\n  console.log('本行不会输出');\n}\nconsole.log(2);\n// 1\n// 2\n```","reference":"","dot":""},{"prefix":"","tag":"continue ","suffix":"[label]","desc":"不带参数时：continue终止本轮循环（内层），返回循环结构的头部，开始下一轮循环\n带参数时：跳转至label后紧接的循环\n","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"label:","suffix":"","desc":"使用 break 或者 continue 来指出程序是否该停止循环还是继续循环","url":"","summary":"```javascript\ntop:\n  for (var i = 0; i < 3; i++){\n    for (var j = 0; j < 3; j++){\n      if (i === 1 && j === 1) continue top;\n      console.log('i=' + i + ', j=' + j);\n    }\n  }\n```","reference":"","dot":""}]}]},{"title":"全局","barcolor":"","fold":false,"box":[{"title":"属性","fold":false,"list":[{"prefix":"","tag":"globalThis ","suffix":"","desc":"JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域）\n1. 浏览器里面，顶层对象是**window**，但 Node 和 Web Worker 没有window。\n2. 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。\n3. Node 里面，顶层对象是**global**，但其他环境都不支持。","url":"","summary":"同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用**this**变量，但是有局限性。\n1. 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。\n2. 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。\n3. 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。\n\n-------------------\n\nES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。","reference":"全局对象|http://es6.ruanyifeng.com/#docs/let#globalThis-%E5%AF%B9%E8%B1%A1","dot":""}]},{"title":"方法","fold":false,"list":[{"prefix":"","tag":"eval","suffix":"(str)","desc":"将传入的字符串当做 JavaScript 代码进行执行\n返回值：返回字符串中代码的返回值。如果返回值为空，则返回 undefined。","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval","dot":""}]}]},{"title":"其它","barcolor":"","fold":false,"box":[{"title":"参考资料","fold":false,"list":[{"prefix":"","tag":"BOM","suffix":"","desc":"","url":"https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model","summary":"","reference":"","dot":""},{"prefix":"","tag":"DOM","suffix":"","desc":"","url":"https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model","summary":"","reference":"","dot":""},{"prefix":"","tag":"Web API","suffix":"","desc":"","url":"https://developer.mozilla.org/zh-CN/docs/Web/API","summary":"","reference":"","dot":""},{"prefix":"","tag":"Standard built-in objects","suffix":"","desc":"","url":"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects","summary":"","reference":"","dot":""},{"prefix":"","tag":"ES compatibility table","suffix":"","desc":"","url":"http://kangax.github.io/compat-table/es6/","summary":"","reference":"","dot":""},{"prefix":"","tag":"ECMAScript","suffix":"","desc":"","url":"https://tc39.es/ecma262/","summary":"","reference":"","dot":""}]},{"title":"教程指南","fold":false,"list":[{"prefix":"","tag":"ES5教程","suffix":"","desc":"","url":"https://wangdoc.com/javascript/index.html","summary":"","reference":"","dot":""},{"prefix":"","tag":"ES6教程","suffix":"","desc":"","url":"http://es6.ruanyifeng.com/","summary":"","reference":"","dot":""},{"prefix":"","tag":"TS教程","suffix":"","desc":"","url":"https://typescript.bootcss.com/","summary":"","reference":"","dot":""}]},{"title":"其它链接","fold":false,"list":[{"prefix":"","tag":"Awesome Libs","suffix":"","desc":"","url":"https://www.awesomes.cn/repos?c=2619450","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"数值","barcolor":"","fold":false,"box":[{"title":"值","fold":true,"list":[{"prefix":"","tag":"字面量","suffix":"","desc":"BigInt型：1n（BigInt 类型的数据必须添加后缀n，任何进制数都可以）\n十进制数：01、1 \n二进制数：0b01、0B10 （只能为0和1）\n八进制数：0o777 （小于8）\n十六进制数：0x10、0XAB （0~9A~F）\n指数计数法：1E2、1e2、0.1e2","url":"","summary":"JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity。\nBigInt 可以使用负号（-），但是不能使用正号（+）\nJavaScript 以前不能计算70的阶乘（即70!），现在可以通过BigInt来实现了\nBigInt 不能与普通数值进行混合运算。","reference":"BigInt|http://es6.ruanyifeng.com/#docs/number#BigInt-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B","dot":""},{"prefix":"","tag":"Infinity","suffix":"","desc":"无穷大","url":"","summary":"<table>\n<thead>\n    <tr>\n        <th scope=\"col\">属性</th>\n        <th scope=\"col\">描述</th>\n    </tr>\n</thead>\n<tbody>\n<tr>\n    <td>Number.MAX_VALUE</td>\n    <td>可表示的最大值 1.79e+308</td>\n</tr>\n<tr>\n    <td>Number.MIN_VALUE</td>\n    <td>可表示的最小值 5e-324</td>\n</tr>\n<tr>\n    <td>Number.NEGATIVE_INFINITY</td>\n    <td>特指“负无穷”;在溢出时返回</td>\n</tr>\n<tr>\n    <td>Number.POSITIVE_INFINITY</td>\n    <td>特指“正无穷”;在溢出时返回</td>\n</tr>\n<tr>\n    <td>Number.EPSILON</td>\n    <td>表示1和比最接近1且大于1的最小Number之间的差别</td>\n</tr>\n<tr>\n    <td>Number.MIN_SAFE_INTEGER</td>\n    <td>JavaScript最小安全整数.</td>\n</tr>\n<tr>\n    <td>Number.MAX_SAFE_INTEGER</td>\n    <td>JavaScript最大安全整数.</td>\n</tr>\n</tbody>\n</table>\n0/0=NaN，正数/0=正无穷，负数/0=负无穷 \n正无穷+正无穷=正无穷，负无穷+负无穷=负无穷，正无穷+负无穷=NaN\n无穷乘法操作得到无穷，无穷除法与求余操作得到NaN","reference":"","dot":""},{"prefix":"","tag":"NaN","suffix":"","desc":"非数值","url":"","summary":"任何与 NaN 进行运算的结果均为 NaN \nNaN 与自身不相等(NaN 不与任何值相等) ","reference":"","dot":""}]},{"title":"检测","fold":false,"list":[{"prefix":"","tag":"isNaN","suffix":"(val)","desc":"判断传递的值是否为 NaN\n全局isNaN会自动转换参数为数值再做判断，Number.isNaN不会自动转换","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"isFinite","suffix":"(val)","desc":"判断传递的值是否为有限数字\n全局的isFinite会自动转换参数为数值再作判断，Number.isFinite不会自动转换","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Number.isInteger","suffix":"(val)","desc":"判断传递的值是否为整数\nIE不支持","url":"","summary":"","reference":"polyfill|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger","dot":""},{"prefix":"","tag":"Number.isSafeInteger","suffix":"(val)","desc":"判断传递的值是否为安全整数","url":"","summary":"一个安全整数是一个符合下面条件的整数：\n1. 可以准确地表示为一个IEEE-754双精度数字\n2. 其IEEE-754表示不能是舍入任何其他整数以适应IEEE-754表示的结果。.","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger","dot":""}]},{"title":"转换","fold":false,"list":[{"prefix":"(num).","tag":"toString","suffix":"([rad])","desc":"将一个10进制数转为指定进制表示的字符串，范围[2~36]。\n```(2).toString(2) -> 10```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"parseInt","suffix":"(val[,rad])","desc":"将一个字符串(非字符串先转为字符串)根据指定的进制转为一个十进制整数（默认10进制）\n```parseInt('10',2) -> 2```\nBigInt.parseInt(string[, radix])：近似于Number.parseInt()，将一个字符串转换成指定进制的 BigInt。","url":"","summary":"<table>\n    <tr>\n        <th>value</th>\n        <th>结果</th>\n    </tr>\n    <tr>\n        <td>空字符串</td>\n        <td>NaN</td>\n    </tr>\n    <tr>\n        <td>第一个非空字符不是数值或负号</td>\n        <td>NaN</td>\n    </tr>\n    <tr>\n        <td>第一个非空字符是数值，遇到非数值时停止解析</td>\n        <td>number</td>\n    </tr>\n</table>\n","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt","dot":""},{"prefix":"","tag":"parseFloat","suffix":"(val)","desc":"把字符串参数解析成浮点数\n第一个小数点有效，第二个无效","url":"","summary":"","reference":"","dot":""}]},{"title":"表示","fold":false,"list":[{"prefix":"(num).","tag":"toFixed","suffix":"([n])","desc":"指定小数点后位数，小数位数[0 ~ 20]\n会四舍五入，返回的是一个字符串\nMath.trunc(val) 将数字的小数部分去掉，只保留整数部分","url":"","summary":"","reference":"","dot":""},{"prefix":"(num).","tag":"toPrecision","suffix":"([n])","desc":"四舍五入到参数指定的显示数字位数，包括小数前的位数。\n无参数时等同转为字符串","url":"","summary":"","reference":"","dot":""},{"prefix":"(num).","tag":"toExponential","suffix":"([n])","desc":"使用科学计数法，小数位数[0~20]\n对基于n位进行四舍五入，返回的是一个字符串","url":"","summary":"一个用幂的形式 (科学记数法 e+n = *10^n) 来表示Number 对象的字符串。小数点后以fractionDigits 提供的值来四舍五入。如果 fractionDigits 参数被忽略了，小数点后的将尽可能用最多的位数来表示该数值。","reference":"","dot":""},{"prefix":"(num).","tag":"toLocaleString","suffix":"([local],[opt])","desc":"返回一个语言环境下的表示字符串\n仅浏览器中有效","url":"","summary":"```javascript\n$num.toLocaleString() //自动根据千位周期加逗号\n$num.toLocaleString('zh-Hans-CN-u-nu-hanidec')  //中文数字\n$num.toLocaleString('cn-ZH',{\n    style:'currency',\n    currency:'CNY',\n    currencyDisplay:'symbol'\n}) //人民币货币\n//en-US、USD  美元\n//en-JP、JPY  日元\n//EUR 欧元","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString","dot":""},{"prefix":"numObj.","tag":"valueOf()","suffix":"","desc":"返回一个被 Number 对象包装的原始值","url":"","summary":"","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/valueOf","dot":""}]}]},{"title":"数学","barcolor":"","fold":false,"box":[{"title":"随机数","fold":false,"list":[{"prefix":"","tag":"Math.random()","suffix":"","desc":"返回一个浮点,  伪随机数在范围[0，1)\n也就是说，从0（包括0）往上，但是不包括1（排除1）","url":"","summary":"不能提供像密码一样安全的随机数字，不能使用它们来处理有关安全的事情。使用Web Crypto API 来代替, 和更精确的window.crypto.getRandomValues() 方法.","reference":"","dot":""}]},{"title":"常用方法","fold":false,"list":[{"prefix":"","tag":"Math.max","suffix":"(val..|...arr)","desc":"返回一组数中最大值\n解构数组","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.min","suffix":"(val..|...arr)","desc":"返回一组数中最小值","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.abs","suffix":"(val)","desc":"返回绝对值","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.ceil","suffix":"(val)","desc":"向上取整","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.floor","suffix":"(val)","desc":"向下取整","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.round","suffix":"(val)","desc":"返回一个数字四舍五入后最接近的整数\nMath.fround() 可以将任意的数字转换为离它最近的单精度浮点数形式的数字。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.pow","suffix":"(x,n)","desc":"返回x的n次方","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.sqrt","suffix":"(val)","desc":"返回一个数的平方根","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.cbrt","suffix":"(val)","desc":"返回任意数字的立方根","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.hypot","suffix":"(x,y,z..)","desc":"返回它的所有参数的平方和的平方根\n如果有参数不能转换为数字，则返回 NaN","url":"","summary":"","reference":"","dot":""}]},{"title":"其它","fold":true,"list":[{"prefix":"","tag":"预定义常量","suffix":"","desc":"Math 适用于 Number 类型。它不支持 BigInt。\nMath.E  欧拉常数，自然对数的底数, 约等于 2.718。\nMath.LN2  2的自然对数, 约等于 0.693。\nMath.LN10  10的自然对数, 约等于 2.303。\nMath.LOG2E  以2为底E的对数, 约等于 1.443。\nMath.LOG10E  以10为底E的对数, 约等于 0.434。\nMath.PI  圆周率，一个圆的周长和直径之比，约等于 3.14159。\nMath.SQRT1_2  1/2的平方根, 约等于 0.707。\nMath.SQRT2  2的平方根,约等于 1.414。","url":"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math","summary":"","reference":"","dot":""},{"prefix":"","tag":"指数对数","suffix":"","desc":"Math.log(val)\t返回一个数的自然对数\nMath.log10(val)\t返回一个数以10位底的对数\nMath.log1p(val)\t返回一个数字加1后的自然对数 (底为 E), 既log(x+1).\nMath.log2(val)\t返回一个数以2位底的对数\nMath.exp(val)\t返回一个数以e位底的val次方\nMath.expm1(val)\t返回一个数以e位底的val次方-1","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"三角函数","suffix":"","desc":"Math.cos(val)\t返回一个数的余弦。\nMath.cosh(val)\t返回一个数的双曲余弦。\nMath.acos(val)\t返回一个数的反余弦。\nMath.acosh(val)\t返回一个数的反双曲余弦。\n\nMath.sin(val)\t返回一个数的正弦。\nMath.sinh(val)\t返回一个数的双曲正弦。\nMath.asin(val)\t返回一个数的反正弦。\nMath.asinh(val)\t返回一个数的反双曲正弦。\n\nMath.tan(val)\t返回一个数的正切。\nMath.tanh(val)\t返回一个数的双曲正切。\nMath.atan(val)\t返回一个数的反正切。\nMath.atan2(val)\t返回两个变量 x 和 y 的反正切。\nMath.atanh(val)\t返回一个数的反双曲正切。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"其它","suffix":"","desc":"+ Math.clz32(val) 返回一个数字在转换成 32 无符号整形数字的二进制形式后, 开头的 0 的个数\n+ Math.imul(a, b) 将两个参数分别转换为 32 位整数，相乘后返回 32 位结果，类似 C 语言的 32 位整数相乘。\n+ Math.sign(val) 返回一个数字的符号, 指示数字是正数，负数还是零。此函数共有5种返回值, 分别是 1, -1, 0, -0, NaN. 代表的各是正数, 负数, 正零, 负零, NaN。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"日期和时间","barcolor":"","fold":false,"box":[{"title":"创建","fold":false,"list":[{"prefix":"","tag":"Date()","suffix":"","desc":"返回一个代表当前时间的字符串\nSun Feb 16 2020 15:59:35 GMT+0800 (GMT+08:00)\n无论有没有参数，直接调用Date总是返回当前时间。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"new Date()","suffix":"","desc":"返回值：Date对象的实例\n实例代表的就是当前时间","url":"","summary":"其他对象求值的时候，都是默认调用.valueOf()方法，但是Date实例求值的时候，默认调用的是toString()方法。这导致对Date实例求值，返回的是一个字符串，代表该实例对应的时间。","reference":"","dot":""},{"prefix":"","tag":"new Date","suffix":"(timestamp)","desc":"指定时间戳的时间对象\n参数可以是负整数，代表1970年元旦之前的时间","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"new Date","suffix":"(yyyy-mm-dd)","desc":"只要是能被Date.parse()方法解析的字符串，都可以当作参数。\nnew Date('2013-2-15')\nnew Date('2013/2/15')","url":"","summary":"```javascript\nnew Date('02/15/2013')\nnew Date('2013-FEB-15')\nnew Date('FEB, 15, 2013')\nnew Date('FEB 15, 2013')\nnew Date('February, 15, 2013')\nnew Date('February 15, 2013')\nnew Date('15 Feb 2013')\nnew Date('15, February, 2013')\n```\n表示日期的字符串值。该字符串应该能被 Date.parse() 正确方法识别（即符合 IETF-compliant RFC 2822 timestamps 或 version of ISO8601）。","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date","dot":""},{"prefix":"","tag":"new Date","suffix":"(y,m[,d,h,m,s,ms])","desc":"日期索引从1开始，其余从0开始\n年和月是不能省略的，其他参数都可以省略的，否则将作为timestamp解析\n参数还可以使用负数，表示扣去的时间。","url":"","summary":"年：使用四位数年份，比如2000。如果写成两位数或个位数，则加上1900，即10代表1910年。如果是负数，表示公元前。\n月：0表示一月，依次类推，11表示12月。\n日：1到31。\n小时：0到23。\n分钟：0到59。\n秒：0到59\n毫秒：0到999。\n\n---------------\n\n这些参数如果超出了正常范围，会被自动折算。比如，如果月设为15，就折算为下一年的4月。\n日期设为0，就代表上个月的最后一天。\n```javascript\nnew Date(2013, 15)\n// Tue Apr 01 2014 00:00:00 GMT+0800 (CST)\nnew Date(2013, 0, 0)\n// Mon Dec 31 2012 00:00:00 GMT+0800 (CST)\n```\n","reference":"参考资料|https://wangdoc.com/javascript/stdlib/date.html","dot":""},{"prefix":"","tag":"Date.UTC","suffix":"(y,m[,d,h,m,s,ms])","desc":"与构造方法的区别为：被解释为 UTC 时间（世界标准时间）\nDate构造函数的参数会被解释为当前时区的时间。","url":"","summary":"","reference":"","dot":""}]},{"title":"时间戳","fold":false,"list":[{"prefix":"","tag":"Date.now()","suffix":"","desc":"返回值：数值\n返回自 1970 年 1 月 1 日 00:00:00 (UTC) 到当前时间的毫秒数。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Date.parse","suffix":"(str)","desc":"返回值：数字\n解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。\n如果解析失败，返回NaN。\nDate.parse('2020-2-16')\nDate.parse('2020/2/16')","url":"","summary":"","reference":"","dot":""}]},{"title":"计算","fold":false,"list":[{"prefix":"","tag":"dt2 - dt1","suffix":"","desc":"间隔的毫秒数","url":"","summary":"如果使用+号，则为拼接2个求值字符串","reference":"","dot":""},{"prefix":"dt.","tag":"get[UTC]*()","suffix":"","desc":"返回值：对应值整数\ngetFullYear()：返回四位的年份。\ngetMonth()：返回月份（0表示1月，11表示12月）。\ngetDate()：返回实例对象对应每个月的几号（从1开始）。\ngetDay()：返回星期几，星期日为0，星期一为1，以此类推。\ngetHours()：返回小时（0-23）。\ngetMinutes()：返回分钟（0-59）。\ngetSeconds()：返回秒（0-59）。\ngetMilliseconds()：返回毫秒（0-999）。\ngetTime()：返回实例距离1970年1月1日00:00:00的毫秒数，等同于valueOf方法。\ngetTimezoneOffset()：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。","url":"","summary":"","reference":"","dot":""},{"prefix":"dt.","tag":"set[UTC]*","suffix":"(val)","desc":"返回值：新的日期对象的时间戳\nsetFullYear(year [, month, date])：设置四位年份。\nsetMonth(month [, date])：设置月份（0-11）。\nsetDate(date)：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。\nsetHours(hour [, min, sec, ms])：设置小时（0-23）。\nsetMinutes(min [, sec, ms])：设置分钟（0-59）。\nsetSeconds(sec [, ms])：设置秒（0-59）。\nsetMilliseconds()：设置毫秒（0-999）。\nsetTime(milliseconds)：设置毫秒时间戳。\n","url":"","summary":"","reference":"","dot":""},{"prefix":"dt.","tag":"set","suffix":"(getv + diff)","desc":"```javascript\nvar d = new Date();\n// 将日期向后推1000天\nd.setDate(d.getDate() + 1000);\n// 将时间设为6小时后\nd.setHours(d.getHours() + 6);\n// 将年份设为去年\nd.setFullYear(d.getFullYear() - 1);\n```","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"字符串","barcolor":"","fold":false,"box":[{"title":"基础","fold":false,"list":[{"prefix":"str.","tag":"length","suffix":"","desc":"返回字符串的长度，该属性也是无法改变的","url":"","summary":"","reference":"","dot":""},{"prefix":"str","tag":"[n]","suffix":"","desc":"等同str.charAt(n) 返回索引上的字符\n\n字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。\n如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。\n但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"repeat","suffix":"(n)","desc":"参数：重复次数(包含原) \n返回值：新的字符串 \n原对象：不变\n会向下取整，当为0时变为空字符串\n\nstr.padStart(len,val) 使用val补齐str长度至len，补前\nstr.padEnd(len,val) 使用val补齐str长度至len，补后","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"trim()","suffix":"","desc":"返回值：新字符串\n原对象：不变 \n移除字符串的两端删除空白字符。\n空白字符包括所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。\n\nstr.trimStart() 消除字符串头部的空格\nstr.trimEnd() 消除尾部的空格","url":"","summary":"","reference":"","dot":""}]},{"title":"转换","fold":false,"list":[{"prefix":"str.","tag":"toUpperCase()","suffix":"","desc":"返回值：新字符串\n原对象：不变\n转为大写","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"toLowerCase()","suffix":"","desc":"返回值：新字符串\n原对象：不变\n转为小写 ","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"normalize()","suffix":"","desc":"按指定Unicode正规形式将当前字符串正规化。\n参数：四种 Unicode 正规形式 \"NFC\", \"NFD\", \"NFKC\", 以及 \"NFKD\" 其中的一个, 默认值为 \"NFC\"","url":"","summary":"","reference":"参考资料|http://es6.ruanyifeng.com/#docs/string#normalize","dot":""},{"prefix":"","tag":"String.raw","suffix":"(str)","desc":"会对斜杠进行转义","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/raw","dot":""}]},{"title":"切片","fold":false,"list":[{"prefix":"str.","tag":"slice","suffix":"[start,end)","desc":"参数：起始位置，末尾位置（不包含）\n返回值：被截取得到的新字符串\n原对象：不变\n当只有1个参数时，则为起始位置到末尾全部，且包含末尾元素（即m=arr.length）。\nn和m可为负值，-1 指最后一个元素，-2 指倒数第二个元素。","url":"","summary":"str.substring[n,m) 参数不接受负数","reference":"","dot":""},{"prefix":"str.","tag":"substr","suffix":"(start,len)","desc":"参数：开始提取字符的位置（如为负数，则用len+n），提取的字符数\n返回值：新字符串 \n原对象：不变\n如果第二个参数是负数，将被自动转为0，因此会返回空字符串。","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"split","suffix":"(reg,[len])","desc":"参数1：字符串或正则表达式 \n参数2：最大的数组长度 \n返回值：数组 \n原对象：不变 \n把字符串按指定符号或正则分割为字符串数组","url":"","summary":"","reference":"","dot":""}]},{"title":"查找","fold":false,"list":[{"prefix":"str.","tag":"indexOf","suffix":"(val,[i])","desc":"参数：正向查找指定值,i为起始索引\n返回值：第一个出现的索引位置；如查找不到则返回-1","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"lastIndexOf","suffix":"(val,[i])","desc":"参数：逆向查找指定值,i为起始索引 \n返回值：最后一个出现的索引位置；如查找不到则返回-1 ","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"includes","suffix":"(val,[i])","desc":"返回布尔值，表示是否找到了参数字符串\n第二个参数，表示开始搜索的位置","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"startsWith","suffix":"(val,[i])","desc":"返回布尔值，表示参数字符串是否在原字符串的头部。\n第二个参数，表示开始搜索的位置","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"endsWidth","suffix":"(val,[i])","desc":"返回布尔值，表示参数字符串是否在原字符串的尾部。\n第二个参数表示针对前n个字符","url":"","summary":"","reference":"","dot":""}]}]},{"title":"正则表达式","barcolor":"","fold":false,"box":[{"title":"匹配","fold":false,"list":[{"prefix":"str.","tag":"match","suffix":"(re)","desc":"求匹配到的次数\n\n匹配返回：子串数组\n未匹配返回：null","url":"","summary":"如果传入非正则，会隐式地转换为正则表达式；\n如果没有参数，会返回空数组；\n数组： \n1.进行匹配完整的字符串 \n2.圆括号捕获的结果 \n3.index: 0，匹配结果在原字符串中的索引 \n4.input: \"原字符串\" ","reference":"","dot":""},{"prefix":"str.","tag":"search","suffix":"(re)","desc":"可第一个匹配到的索引位置\n\n匹配返回：第一个子串的索引\n未匹配返回：-1\t\t\t","url":"","summary":"始终从头开始找，找到一个即返回，正则无需全局设置","reference":"","dot":""},{"prefix":"str.","tag":"replace","suffix":"(re,val|fn)","desc":"替换匹配内容\n\n返回值：新的字符串\n原对象：不变 ","url":"","summary":"参数1：需要替换的字符或正则表达式，没有全局标识时只替换一次 \n参数2：替换成的字符串或生成字符串的函数，用return返回","reference":"指定一个函数作为参数|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace\n示例资料|https://wangdoc.com/javascript/stdlib/regexp.html#stringprototypereplace","dot":""},{"prefix":"str.","tag":"matchAll","suffix":"(re)","desc":"一次性取出所有匹配（g 修饰符加不加都可以）\n返回值：遍历器，可通过for..of遍历，或使用[...ite]或Array.from(ite)转为数组\n","url":"","summary":"```javascript\n// 转为数组方法一\n[...string.matchAll(regex)]\n\n// 转为数组方法二\nArray.from(string.matchAll(regex))\n```","reference":"","dot":""}]},{"title":"正则表达式","fold":false,"list":[{"prefix":"","tag":"/pattern/","suffix":"flag","desc":"字面量 ```var regex = /xyz/flag```\n构造函数 ```var regex = new RegExp('xyz',flag)```\n前者在引擎编译代码时，就会新建正则表达式，效率较高\n后者在运行时新建正则表达式，必须引入字符串时使用\n\n-------------\n\n修饰符：gis\ng：全局匹配。 \ni：忽略大小写。 \nm：多行模式。\ny：执行“粘性”搜索,匹配从目标字符串的当前位置开始。 \nu：正确处理大于\\uFFFF的 Unicode 字符（点.字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。）\ns：让.可匹配行终止符","url":"","summary":"re.prototype.global：返回一个布尔值，表示是否设置了g修饰符，只读。\nre.ignoreCase：返回一个布尔值，表示是否设置了i修饰符，只读。\nre.prototype.multiline：返回一个布尔值，表示是否设置了m修饰符，只读。\nre.prototype.sticky：返回一个布尔值，表示是否设置了y修饰符，只读。\nre.prototype.unicode：返回一个布尔值，表示是否设置了u修饰符，只读。\nre.prototype.dotAll：返回一个布尔值，表示是否设置了s修饰符，只读。\nre.prototype.flags：返回一个字符串，包含了已经设置的所有修饰符，按字母排序，只读。\nre.lastIndex：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义。\nre.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。\n\ny修饰符确保匹配必须从剩余的第一个位置开始\ny修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。\ny修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。\ng修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误","reference":"","dot":""},{"prefix":"re.","tag":"test","suffix":"(str)","desc":"是否存在匹配返回布尔值\n匹配返回：true\n未匹配返回：false","url":"","summary":"带有g修饰符时，可以通过正则对象的lastIndex属性指定开始搜索的位置。","reference":"","dot":""},{"prefix":"re.","tag":"exec","suffix":"(str)","desc":"当结果为真时循环执行，可捕获分组结果\n```var result = re.exec(str)```\n\n匹配返回：结果组\n未匹配返回：null\n\n[1]是第一个圆括号匹配的结果 $1 \nindex：该次匹配成功的开始位置（从0开始计数），需多次执行\ngroups：具名组匹配结果","url":"","summary":"```javascript\nvar regex = /t(e)(st(\\d?))/g;\nvar string = 'test1test2test3';\n\nvar matches = [];\nvar match;\nwhile (match = regex.exec(string)) {\n  matches.push(match);\n}\n\nmatches\n// [\n//   [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"],\n//   [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"],\n//   [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"]\n// ]\n```","reference":"","dot":""},{"prefix":"result.","tag":"$n","suffix":"","desc":"指定分组部分结果\n等同```result[n]```","url":"","summary":"","reference":"","dot":""},{"prefix":"result.","tag":"groups","suffix":".gname","desc":"具名组匹配\n分组具名 ```(?<gname>exp)```\n在正则表达式内部引用某个“具名组匹配” ```\\k<gname>exp```\n在exec方法返回结果的groups属性上引用该组名","url":"","summary":"```javascript\nconst RE_DATE = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n\nconst matchObj = RE_DATE.exec('1999-12-31');\nconst year = matchObj.groups.year; // 1999\nconst month = matchObj.groups.month; // 12\nconst day = matchObj.groups.day; // 31\n```","reference":"参考资料|http://es6.ruanyifeng.com/#docs/regex#%E5%85%B7%E5%90%8D%E7%BB%84%E5%8C%B9%E9%85%8D","dot":""}]}]},{"title":"编码解码","barcolor":"","fold":false,"box":[{"title":"字符","fold":false,"list":[{"prefix":"","tag":"\\u{xxxx}","suffix":"","desc":"JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。\n每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。","url":"","summary":"（1）\\HHH\n反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点，比如\\251表示版权符号。显然，这种方法只能输出256种字符。\n\n（2）\\xHH\n\\x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\\xA9表示版权符号。这种方法也只能输出256种字符。\n\n（3）\\uXXXX\n\\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\\u00A9表示版权符号。","reference":"参考资料|https://wangdoc.com/javascript/types/string.html#%E8%BD%AC%E4%B9%89\nES6改进|http://es6.ruanyifeng.com/#docs/string#%E5%AD%97%E7%AC%A6%E7%9A%84-Unicode-%E8%A1%A8%E7%A4%BA%E6%B3%95","dot":""},{"prefix":"str.","tag":"charCodeAt","suffix":"(i)","desc":"参数：查找的索引位置\n返回值：unicode码点(十进制) (0~65535 2个字节16位)\n如果索引超出范围，则返回 NaN。","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"codePointAt","suffix":"(i)","desc":"参数：查找的索引位置\n返回值：unicode码点（十进制）\n支持大于2个字节的Uniode编码\nIE11+","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"String.fromCharCode","suffix":"(n,..)","desc":"参数：unicode码点\n返回值：字符串","url":"","summary":"一系列UTF-16代码单元的数字。 范围介于0到65535（0xFFFF）之间。 大于0xFFFF的数字将被截断。 不进行有效性检查。","reference":"","dot":""},{"prefix":"","tag":"String.fromCodePoint","suffix":"(n,..)","desc":"参数：unicode码点\n返回值：字符串\n支持大于2个字节的Uniode编码","url":"","summary":"","reference":"","dot":""}]},{"title":"URI","fold":false,"list":[{"prefix":"","tag":"URI","suffix":"","desc":"将字符编码为URL合法字符。非合法字符使用% + UTF-8编码(十六进制)表示。","url":"","summary":"网页的 URL 只能包含合法的字符。合法字符分成两类。\n# URL 元字符：\n分号（;），逗号（,），斜杠（/），问号（?），冒号（:），at（@），&，等号（=），加号（+），美元符号（$），井号（#）\n# 语义字符：\na-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（'），圆括号（()）\n除了以上字符，其他字符出现在 URL 之中都必须转义，规则是根据操作系统的默认编码，将每个字节转为百分号（%）加上两个大写的十六进制字母。\n\n“春”的 UTF-8 编码分别是E6 98 A5\nURI即%E6%98%A5","reference":"","dot":""},{"prefix":"","tag":"encodeURI","suffix":"(str)","desc":"转码整个 URL。它的参数是一个字符串，代表整个 URL。\n它会将元字符和语义字符之外的字符，都进行转义。","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI","dot":""},{"prefix":"","tag":"encodeURIComponent","suffix":"(str)","desc":"用于转码 URL 的组成部分，会转码除了语义字符之外的所有字符，即元字符也会被转码。\n所以，它不能用于转码整个 URL。它接受一个参数，就是 URL 的片段。\nURL建议手动拼接，推荐使用encodeURIComponent编码用户内容","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent","dot":""},{"prefix":"","tag":"decodeURI","suffix":"(code)","desc":"用于整个 URL 的解码。它是encodeURI()方法的逆运算。\n它接受一个参数，就是转码后的 URL。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"decodeURIComponent","suffix":"(code)","desc":"用于URL 片段的解码。它是encodeURIComponent()方法的逆运算。\n它接受一个参数，就是转码后的 URL 片段。","url":"","summary":"","reference":"","dot":""}]},{"title":"Base64","fold":false,"list":[{"prefix":"","tag":"base64","suffix":"","desc":"每3个字节将会被编码成四个字符, 如果不足3个字节, 则补上垫字符=, 缺几个就补几个。","url":"","summary":"# 编码 \n1. 每三个字节作为一组，每个字节8bit, 一共是24个二进制位。\n2. 将每组的24个二进制位再细分为四组，每组有6个二进制位, 此时为二维数组。\n3. 在每组前面加两个00，扩展成32个二进制位，即四个字节。\n4. 将每组对应的二进制转成十进制, 在base64char字符集中找到对应的字符。\n5. 将最后的结果连接成字符串, 则为最终编码结果。\n\n# 解码\n1. 每四个字节分为一组。\n2. 将每组的中除了垫字符=外的字符, 在base64char字符集中找到所在下标。\n3. 将十进制下标转成二进制, 如果不够6位（一定不会超过6位）, 则在前面补0。\n    + 如果遇到垫字符=, 说明其明文不足3字节, 则根据垫字符=的数量, 在该组最后一项中去掉对应个数的0\n    + 一个垫字符, 则去掉两个0\n    + 两个垫字符, 则去掉四个0\n4. 将每组中的二进制字符串连接，此时字符串长度一定是8的倍数，然后每8位分割成一个字节。\n5. 通过String.fromCharCode将二进制转成字符, 然后拼接\n6. 将各个字符连接, 为最终解码结果。","reference":"参考资料|https://juejin.im/post/5ccf01d5e51d453a363848d6","dot":""},{"prefix":"","tag":"btoa(str)|atob(base64)","suffix":"","desc":"浏览器自带的base64编码解码方法，但不支持ASCII以外字符\n编码 ```let encodedData = btoa(stringToEncode)```\n解码 ```var decodedData = atob(encodedData)```","url":"","summary":"对于中文，需要先用encodeURIComponent进行编码","reference":"btoa|https://developer.mozilla.org/zh-CN/docs/Web/API/WindowBase64/btoa\natob|https://developer.mozilla.org/zh-CN/docs/Web/API/WindowBase64/atob","dot":""},{"prefix":"","tag":"Buffer.from(str|base64).toString('base64'|)","suffix":"","desc":"Nodejs中的实现\n编码 ```Buffer.from(str).toString('base64')```\n解码 ```Buffer.from(b64Encoded, 'base64').toString()```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"js-base64","suffix":"","desc":"npm install --save js-base64\nvar Base64 = require('js-base64').Base64;\n编码 Base64.encode(str) | Base64.encodeURI('中文')\n解码 Base64.decode(base64) | Base64.atob(图片Base64)","url":"","summary":"","reference":"","dot":""}]}]},{"title":"国际化","barcolor":"","fold":false,"box":[]}]},{"column":[{"title":"对象","barcolor":"","fold":false,"box":[{"title":"内置方法","fold":false,"list":[{"prefix":"","tag":"[Symbol.hasInstance]","suffix":"(obj)","desc":"使用内置instanceof时执行的方法","url":"","summary":"```javascript\nclass Even {\n  static [Symbol.hasInstance](obj) {\n    return Number(obj) % 2 === 0;\n  }\n}\n1 instanceof Even // false\n```","reference":"内置Symbol|http://es6.ruanyifeng.com/#docs/symbol#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%A8%A1%E5%9D%97%E7%9A%84-Singleton-%E6%A8%A1%E5%BC%8F","dot":""}]}]}]},{"column":[{"title":"Symbol","barcolor":"","fold":false,"box":[{"title":"创建","fold":false,"list":[{"prefix":"","tag":"Symbol","suffix":"([desc])","desc":"生成一个symbol，没有new操作符，const mySymbol = Symbol();\nSymbol 值作为对象属性名时，不能用点运算符，必须用方括号","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Symbol.for","suffix":"(desc)","desc":"返回值：返回或创建一个新的symbol（全局特性）\n","url":"","summary":"它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。\n注意，Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。\nSymbol.for()的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。\n```javascript\nlet s1 = Symbol.for('foo');\nlet s2 = Symbol.for('foo');\n\ns1 === s2 // true\n```\n\nSymbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(\"cat\")30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(\"cat\")30 次，会返回 30 个不同的 Symbol 值。","reference":"参考资料|http://es6.ruanyifeng.com/#docs/symbol","dot":""},{"prefix":"","tag":"Symbol.keyFor","suffix":"(sym)","desc":"返回值：一个已登记的 Symbol 类型值的desc","url":"","summary":"","reference":"","dot":""}]},{"title":"属性/方法","fold":false,"list":[{"prefix":"sym","tag":".description","suffix":"","desc":"Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。\nSymbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。 ","url":"","summary":"\n","reference":"","dot":""},{"prefix":"sym","tag":".toString()","suffix":"","desc":"转为字符串 String(x) 或 x.toString()\nSymbol 值也可以转为布尔值（总为true），但是不能转为数值\nSymbol 值不能与其他类型的值进行运算","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Object.getOwnPropertySymbols","suffix":"(obj)","desc":"返回一个symbol keys的数组","url":"","summary":"Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。\n\n由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。","reference":"","dot":""}]}]}]},{"column":[]}]}