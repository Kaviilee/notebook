{"version":1584851575786,"name":"js","data":[{"column":[{"title":"数据类型","barcolor":"","fold":false,"box":[{"title":"数据类型","fold":false,"list":[{"prefix":"","tag":"number","suffix":"","desc":"基本类型，数字类型只有一个整数: 0\n__哈哈__","url":"","summary":"根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(263 -1) 到 263 -1） ","reference":"","dot":""},{"prefix":"","tag":"bigint","suffix":"","desc":"基本类型，BigInt 类型的数据必须添加后缀n","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"boolean","suffix":"","desc":"基本类型，值true,false","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"string ","suffix":"+","desc":"基本类型，具有Iterator接口\n字符串连接符 +\n模板字符串*\\`${var}`*\n","url":"","summary":"如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。\n```javascript\nvar longString = 'Long \\\nlong \\\nlong \\\nstring';\n\nlongString\n// \"Long long long string\"\n```","reference":"","dot":""},{"prefix":"","tag":"array","suffix":"","desc":"引用类型，具有Iterator接口\n字面量 ```var arr = [v1,v2..]```\n构造函数 ```var arr = [new] Array(arg[s])```\n无参数空数组,多个参数形成成员,单个正整数参数为长度,单个非正整数参数为单个值\n数组方法 ```var arr = Array.of(val,..)```","url":"","summary":"# 构造函数法\n```\nvar arr = new Array(2);\n// 等同于\nvar arr = Array(2);\n```\n无参数空数组,多个参数形成成员,单个正整数参数为长度,单个非正整数参数为单个值\n```\n// 无参数时，返回一个空数组\nnew Array() // []\n\n// 单个正整数参数，表示返回的新数组的长度\nnew Array(1) // [ empty ]\nnew Array(2) // [ empty x 2 ]\n\n// 非正整数的数值作为参数，会报错\nnew Array(3.2) // RangeError: Invalid array length\nnew Array(-3) // RangeError: Invalid array length\n\n// 单个非数值（比如字符串、布尔值、对象等）作为参数，\n// 则该参数是返回的新数组的成员\nnew Array('abc') // ['abc']\nnew Array([1]) // [Array[1]]\n\n// 多参数时，所有参数都是返回的新数组的成员\nnew Array(1, 2) // [1, 2]\nnew Array('a', 'b', 'c') // ['a', 'b', 'c']\n```","reference":"","dot":""},{"prefix":"","tag":"set","suffix":"","desc":"引用类型，具有Iterator接口\n构造函数 ```new Set([ite])```\n类似于数组，但是成员的值都是唯一的，没有重复的值（包括对象保留唯一引用地址）","url":"","summary":"1. 向 Set 加入值的时候，不会发生类型转换\n2. Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符\n3. 但向 Set 加入值时认为NaN等于自身","reference":"","dot":""},{"prefix":"","tag":"map","suffix":"","desc":"引用类型，具有Iterator接口\n构造函数 ```new Map([ite])``` ```new Map([[k1,v1],..])```\n可通过二维数组快速生成一个哈希表\n键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。\nMap 的键是跟内存地址绑定的，只要内存地址不一样，就视为两个键。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"enum ","suffix":"","desc":"枚举（Typescript）\n```enum Color {Red, Green, Blue}```\n当前枚举成员的值为上一个枚举成员的值加1。\n第一个枚举元素是个例外，如果它没有初始化方法，那么它的初始值为0","url":"","summary":"```let c:Color = Color.Green;```","reference":"","dot":"#ffa500"},{"prefix":"","tag":"object","suffix":"","desc":"引用类型（包括数组、函数、标准对象等）\n字面量 ```{key:val,..}```\n构造函数 ```var obj = new Object()```","url":"","summary":"1.对象有时也被叫作关联数组。对象的属性之间用逗号分隔，最后一个属性后面可以加逗号，也可以不加。\n2.对象的所有键名都是字符串，可以不加引号。但如果不符合表示名的条件，则需要加引号。\n3.如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。\n4.如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号，确保eval解析正确。","reference":"参考资料|https://wangdoc.com/javascript/types/object.html","dot":""},{"prefix":"","tag":"symbol","suffix":"","desc":"基本类型\n本地symbol `const mySymbol = Symbol(desc)` 外部无法引用\n全局symbol `const mySymbol = Symbol.for(desc)`  可全局登记不重名\n1.生成一个symbol，没有new操作符\n2.符号类型是唯一的并且是不可修改的\n3.Symbol 值作为对象属性名时，不能用点运算符，必须用方括号\n\n`sym.description` 或 `sym.toString()` 获取描述\n`Symbol.keyFor(sym)` 是否有全局登记，有返回desc，没有返回undefined。","url":"","summary":"如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。\nSymbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。 \nSymbol 值也可以转为布尔值（总为true），但是不能转为数值\nSymbol 值不能与其他类型的值进行运算\n\n---\n\nSymbol.for它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。\n注意，Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。\nSymbol.for()的这个全局登记特性，可以用在不同的 iframe 或 service worker 中取到同一个值。\n```javascript\nlet s1 = Symbol.for('foo');\nlet s2 = Symbol.for('foo');\n\ns1 === s2 // true\n```\n\nSymbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(\"cat\")30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(\"cat\")30 次，会返回 30 个不同的 Symbol 值。\n\n","reference":"","dot":""},{"prefix":"","tag":"undefined","suffix":"","desc":"一个没有被赋值的变量会有个默认值 undefined\n函数没有设置返回值时，返回undefined","url":"","summary":"不存在的变量与未声明的变量typeof检测均为undefined，但两者其实不同，故建议总是初始化。 ","reference":"","dot":""},{"prefix":"","tag":"null","suffix":"","desc":"空：原始类型\nNull 类型只有一个值： null","url":"","summary":"1.判断null请使用myVar === null。Null 类型是一个只有一个值的数据类型，即特殊的值 null。它表示一个空对象引用(指针)，而 typeof 操作符检测 null 会返回 object。如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null。这样，当检查 null 值就知道是否已经变量是否已经分配了对象引用了。\n2.undefined 是派生自 null 的，因此 ECMA-262 规定对它们的相等性测试返回 true。alert(undefined == null);但typeof数据类型不等。","reference":"内存优化|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management","dot":""},{"prefix":"","tag":"weakset|weakmap","suffix":"","desc":"构造函数 ```new WeakSet([ite])```\n构造函数 ```new WeakMap([ite])```\n成员|键只能是对象，而不能是其他类型的值\n不可遍历，可用于临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet|WeakMap 里面的引用就会自动消失。","url":"","summary":"WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。\n这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。","reference":"参考资料|http://es6.ruanyifeng.com/#docs/set-map","dot":""}]},{"title":"类型检测","fold":false,"list":[{"prefix":"","tag":"typeof ","suffix":"val","desc":"返回类型字符串 \n<table>\n    <tr>\n        <th>类型</th>\n        <th>结果</th>\n    </tr>\n    <tr>\n        <td>数值/NaN</td>\n        <td>number</td>\n    </tr>\n    <tr>\n        <td>BigInt</td>\n        <td>bigint</td>\n    </tr>\n    <tr>\n        <td>true/false</td>\n        <td>boolean</td>\n    </tr>\n    <tr>\n        <td>字符串/JSON</td>\n        <td>string</td>\n    </tr>\n    <tr>\n        <td>fn</td>\n        <td>function</td>\n    </tr>\n    <tr>\n        <td>array/set/map/obj/null</td>\n        <td>object</td>\n    </tr>\n    <tr>\n        <td>Symbol</td>\n        <td>symbol</td>\n    </tr>\n    <tr>\n        <td>undefined/不存在的属性或方法</td>\n        <td>undefined</td>\n    </tr>\n</table>","url":"","summary":"可通过Object.prototype.toString.call(o)测试\n数值：返回[object Number]。\n字符串：返回[object String]。\n布尔值：返回[object Boolean]。\nundefined：返回[object Undefined]。\nnull：返回[object Null]。\n数组：返回[object Array]。\narguments 对象：返回[object Arguments]。\n函数：返回[object Function]。\nError 对象：返回[object Error]。\nDate 对象：返回[object Date]。\nRegExp 对象：返回[object RegExp]。\n其他对象：返回[object Object]。\n```javascript\nvar type = function (o){\n  var s = Object.prototype.toString.call(o);\n  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();\n};\n```","reference":"Lodash-Lang|https://www.lodashjs.com/docs/latest","dot":""},{"prefix":"","tag":"Array.isArray","suffix":"(arr)","desc":"typeof运算符只能显示数组的类型是Object，而Array.isArray方法可以识别数组。","url":"","summary":"","reference":"","dot":""},{"prefix":"val ","tag":"instanceof ","suffix":"type","desc":"instanceof运算符返回一个布尔值，表示某个对象是否为指定的构造函数的实例。","url":"","summary":"let x = new Map([[1,1],[2,2],[3,3]])\n\nlet y = new Map(x)\nconsole.log(x instanceof Map)\n\n<table>\n    <tr>\n        <th>测试目标</th>\n        <th>测试结果</th>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>arr instanceof Array</td>\n    </tr>\n    <tr>\n        <td>构造函数实例</td>\n        <td>child instanceof parent</td>\n    </tr>\n    <tr>\n        <td>函数/构造函数</td>\n        <td>fn instanceof Function</td>\n    </tr>\n    <tr>\n        <td>日期</td>\n        <td>value instanceof Date</td>\n    </tr>\n    <tr>\n        <td>正则表达式</td>\n        <td>value instanceof RegExp</td>\n    </tr>\n    <tr>\n        <td>Map|Set</td>\n        <td>value instanceof Map|Set</td>\n    </tr>\n    <tr>\n        <td>泛对象</td>\n        <td>obj instanceof Object</td>\n    </tr>\n</table>","reference":"","dot":""},{"prefix":"","tag":"[Symbol.hasInstance]","suffix":"(obj)","desc":"使用内置instanceof时执行的方法","url":"","summary":"```javascript\nclass Even {\n  static [Symbol.hasInstance](obj) {\n    return Number(obj) % 2 === 0;\n  }\n}\n1 instanceof Even // false\n```","reference":"内置Symbol|http://es6.ruanyifeng.com/#docs/symbol#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%A8%A1%E5%9D%97%E7%9A%84-Singleton-%E6%A8%A1%E5%BC%8F","dot":""},{"prefix":"","tag":"ArrayBuffer.isView","suffix":"(v)","desc":"是否为ArrayBuffer的视图实例。\n这个方法大致相当于判断参数，是否为TypedArray实例或DataView实例。","url":"","summary":"","reference":"","dot":""}]},{"title":"类型转换/创建","fold":false,"list":[{"prefix":"","tag":"Number","suffix":"(val)","desc":"+数值运算符,-负值运算符,~~取整运算","url":"","summary":"<table>\n    <tr>\n        <th>value</th>\n        <th>返回值</th>\n    </tr>\n    <tr>\n        <td>number/包含单个数值的数组</td>\n        <td>number</td>\n    </tr>\n    <tr>\n        <td>boolean</td>\n        <td>1 / 0</td>\n    </tr>\n    <tr>\n        <td>null/空字符串/空数组</td>\n        <td>0</td>\n    </tr>\n    <tr>\n        <td>undefined/string/object</td>\n        <td>NaN</td>\n    </tr>\n</table>","reference":"","dot":""},{"prefix":"","tag":"Boolean","suffix":"(val)","desc":"!取反运算符 !!布尔运算","url":"","summary":"0、-0、null、false、NaN、undefined、空字符串（\"\"）、document.all\n以上均生成值为false的Boolean对象\n注意，空数组（[]）和空对象（{}）对应的布尔值，都是true。","reference":"","dot":""},{"prefix":"","tag":"String","suffix":"(val)","desc":"+''加空字符串，toString()方法","url":"","summary":"<table>\n    <tr>\n        <th>value</th>\n        <th>返回值</th>\n    </tr>\n    <tr>\n        <td>数值</td>\n        <td>转为相应的字符串</td>\n    </tr>\n    <tr>\n        <td>字符串</td>\n        <td>转换后还是原来的值</td>\n    </tr>\n    <tr>\n        <td>布尔值</td>\n        <td>true转为\"true\"，false转为\"false\"</td>\n    </tr>\n    <tr>\n        <td>undefined</td>\n        <td>转为\"undefined\"</td>\n    </tr>\n    <tr>\n        <td>null</td>\n        <td>转为\"null\"</td>\n    </tr>\n    <tr>\n        <td>数组</td>\n        <td>返回该数组的字符串形式  \"1,2,3\"</td>\n    </tr>\n    <tr>\n        <td>对象</td>\n        <td>返回一个类型字符串 \"[object Object]\" <br>可通过toString方法来设置修改</td>\n    </tr>\n</table>","reference":"","dot":""},{"prefix":"","tag":"类型转换表","suffix":"","desc":"1.空数组/对象转为布尔为true\n2.字符串“0”转为布尔为true","url":"","summary":"<table>\n <tbody><tr>\n  <th>原始值</th>\n  <th>转换为数字</th>\n  <th>转换为字符串</th>\n  <th>转换为布尔值</th>\n </tr>\n <tr>\n  <td>false</td>\n  <td>0</td>\n  <td>\"false\"</td>\n  <td>false</td>\n </tr>\n <tr>\n  <td>true</td>\n  <td>1</td>\n  <td>\"true\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>0</td>\n  <td>0</td>\n  <td>\"0\"</td>\n  <td>false</td>\n </tr>\n <tr>\n  <td>1</td>\n  <td>1</td>\n  <td>\"1\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>\"0\"</td>\n  <td>0</td>\n  <td>\"0\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>\"000\"</td>\n  <td>0</td>\n  <td>\"000\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>\"1\"</td>\n  <td>1</td>\n  <td>\"1\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>NaN</td>\n  <td>NaN</td>\n  <td>\"NaN\"</td>\n  <td>false</td>\n </tr>\n <tr>\n  <td>Infinity</td>\n  <td>Infinity</td>\n  <td>\"Infinity\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>-Infinity</td>\n  <td>-Infinity</td>\n  <td>\"-Infinity\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>\"\"</td>\n  <td>0</td>\n  <td>\"\"</td>\n  <td>false</td>\n </tr>\n <tr>\n  <td>\"20\"</td>\n  <td>20</td>\n  <td>\"20\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>\"Runoob\"</td>\n  <td>NaN</td>\n  <td>\"Runoob\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>[ ]</td>\n  <td>0</td>\n  <td>\"\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>[20]</td>\n  <td>20</td>\n  <td>\"20\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>[10,20]</td>\n  <td>NaN</td>\n  <td>\"10,20\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>[\"Runoob\"]</td>\n  <td>NaN</td>\n  <td>\"Runoob\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>[\"Runoob\",\"Google\"]</td>\n  <td>NaN</td>\n  <td>\"Runoob,Google\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>function(){}</td>\n  <td>NaN</td>\n  <td>\"function(){}\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>{ }</td>\n  <td>NaN</td>\n  <td>\"[object Object]\"</td>\n  <td>true</td>\n </tr>\n <tr>\n  <td>null</td>\n  <td>0</td>\n  <td>\"null\"</td>\n  <td>false</td>\n </tr>\n <tr>\n  <td>undefined</td>\n  <td>NaN</td>\n  <td>\"undefined\"</td>\n  <td>false</td>\n </tr>\n</tbody></table>","reference":"类型转换表|https://www.runoob.com/js/js-type-conversion.html","dot":""}]}]},{"title":"语法","barcolor":"","fold":false,"box":[{"title":"声明与作用域","fold":false,"list":[{"prefix":"","tag":"var ","suffix":"x = val","desc":"1.变量会提升，在没有声明前调用，会输出undefined\n2.假设声明a、b、c,且c=a+b，且均为非引用类型，当ab发生变化时，c不会改变，应设为c=fn(return a+b)","url":"","summary":"","reference":"3种全局变量的异同|http://snandy.iteye.com/blog/720816","dot":""},{"prefix":"","tag":"let ","suffix":"x = val","desc":"申明一个块级作用域的变量 let i = 1;\n不能使用let重复定义一个变量 ","url":"","summary":"只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响，暂时性死区。","reference":"","dot":""},{"prefix":"","tag":" let [x, y = 'b'] = ['a']","suffix":"","desc":"解构赋值允许指定默认值。\n数组、对象、函数参数均可广泛应用解构。","url":"http://es6.ruanyifeng.com/#docs/destructuring#%E7%94%A8%E9%80%94","summary":"","reference":"","dot":""},{"prefix":"","tag":"let x:type ","suffix":"= val","desc":"ts强类型：number,boolean,string,$enum\n数组：type[],Array\\<type>\n元组：[type1,type2]\n任意：any\n空值：void\n特殊：never","url":"","summary":"---------------\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 \n比如，你可以定义一对值分别为string和number类型的元组。\n```typescript\n// Declare a tuple type\nlet x: [string, number];\n// Initialize it\nx = ['hello', 10]; // OK\n// Initialize it incorrectly\nx = [10, 'hello']; // Error\n```\n\n某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是void\n```typescript\nfunction warnUser(): void {\n    alert(\"This is my warning message\");\n}\n```\n\nnever类型表示的是那些永不存在的值的类型。 例如，never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是never类型，当它们被永不为真的类型保护所约束时。\n```typescript\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// 推断的返回值类型为never\nfunction fail() {\n    return error(\"Something failed\");\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n    while (true) {\n    }\n}\n```","reference":"","dot":"#ffa500"},{"prefix":"","tag":"const ","suffix":"x = val","desc":"const PI = 3.14\n一旦声明，常量的指针就不能改变（仅指针，非值本身）                   ","url":"","summary":"1.const来定义常量，在声明时就必须赋值。\n2.const与let都具有块级作用域。","reference":"","dot":""},{"prefix":"","tag":"delete ","suffix":"ele","desc":"删除一个变量、元素、对象键\n```delete obj.key``` 注：delete命令只能删除对象本身的属性，无法删除继承的属性\n```delete arr[i]```\n\n删除一个不存在的属性，delete不报错，而且返回true。\n只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。","url":"","summary":"","reference":"","dot":""}]},{"title":"运算符","fold":true,"list":[{"prefix":"","tag":"算术运算符","suffix":"","desc":"加法运算符：x + y\n减法运算符： x - y\n乘法运算符： x * y\n指数运算符：x ** y\n除法运算符：x / y\n余数运算符：x % y\n自增运算符：++x 或者 x++\n自减运算符：--x 或者 x--\n数值运算符： +x\n负数值运算符：-x","url":"","summary":"# + 加法\n1. 有字符串参与的都转为字符串拼接\n2. 对象的转换会先调用valueOf方法（返回自身），再调用toString方法\n特例：如果运算子是一个Date对象的实例，那么会优先执行toString方法。\n\n# % 余数\n运算结果的正负号由第一个运算子的正负号决定\n为了得到负数的正确余数值，可以先使用绝对值函数\n```javascript\n-1 % 2 // -1\n1 % -2 // 1\n```\n\n# ++ -- 自增/减运算符\n自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。\n```javascript\nvar x = 1;\nvar y = 1;\nx++ // 1\n++y // 2\n```\nx是先返回当前值，然后自增，所以得到1；y是先自增，然后返回新的值，所以得到2。\n\n# 指数运算符\n注意，指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算。\n```javascript\n// 相当于 2 ** (3 ** 2)\n2 ** 3 ** 2\n// 512\n```","reference":"","dot":""},{"prefix":"","tag":"关系运算符","suffix":"","desc":"\\> 大于运算符\n\\< 小于运算符\n>= 大于或等于运算符\n<= 小于或等于运算符\n== 相等运算符\n=== 严格相等运算符\n!= 不相等运算符\n!== 严格不相等运算符","url":"","summary":"# 特殊\n任何值（包括NaN本身）与NaN比较，返回的都是false。\n\n# 非严格比较\n1. 先将数据进行类型转换，然后再用严格相等运算符比较。\n2. 对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；\n3. 否则，将两个运算子都转成数值，再比较数值的大小。\n4. 对于两个对象的比较，大于或小于运算符比较的是值。（算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法）\n\n# 严格比较\n1. 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。\n2. 特殊类型总是使用严格比较","reference":"特殊类型比较|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness\n比较运算符|http://wangdoc.com/javascript/operators/comparison.html","dot":""},{"prefix":"","tag":"逻辑运算符","suffix":"","desc":"取反运算符：!\n且运算符：&&\n或运算符：||\nnull运算符：?? \n三元运算符：?:","url":"","summary":"# 且运算符 && \n如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；\n如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。\n且运算符可以多个连用，这时返回第一个布尔值为false的表达式的值。如果所有表达式的布尔值都为true，则返回最后一个表达式的值。\n短路：多个接力执行\n\n# 或运算符 ||\n如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；\n如果第一个运算子的布尔值为false，则返回第二个运算子的值。\n或运算符可以多个连用，这时返回第一个布尔值为true的表达式的值。如果所有表达式都为false，则返回最后一个表达式的值。\n短路：备用默认值\n\n# Null运算符 ??\n它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值。\n这样当默认值为false或0时不会失效\n\n# 三元运算符 ?:\n通常来说，三元条件表达式与if...else语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，if...else是语句，没有返回值；三元条件表达式是表达式，具有返回值。所以，在需要返回值的场合（赋值），只能使用三元条件表达式，而不能使用if..else。在需要复杂的语句和逻辑时，使用流程控制而不是三元表达式。\n","reference":"布尔运算符|http://wangdoc.com/javascript/operators/boolean.html","dot":""},{"prefix":"","tag":"位运算符","suffix":"","desc":"| 按位或\n& 按位与\n~ 按位取反\n^ 按位异或\n\\<< 左移运算符 \n\n>> 右移运算符\n\n\\>>> 头部补零的右移运算符","url":"","summary":"1. 位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。\n2. 在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。\n```javascript\ni = i | 0; //将任意数值转为32位整数,舍去大于32位的数位,舍去小数\n~~2.9 //舍去小数取整\n```\n3. 左移运算符乘以2的指定次方，右移运算符除以2的指定次方\n4. >>> 查看一个负整数在计算机内部的储存形式\n\n----------------\n\n正整数的补码是其二进制表示，与原码相同\n求负整数的补码，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1\n已知一个数的补码，求原码的操作其实就是对该补码再求补码","reference":"原码，反码，补码详解|https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html","dot":""},{"prefix":"","tag":"赋值运算符","suffix":"","desc":"+= -= *= **= /= %= &= |= ^= <<= >>=","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"逗号运算符","suffix":"","desc":"逗号运算符用于对两个表达式求值，并返回后一个表达式的值。","url":"","summary":"","reference":"","dot":""}]},{"title":"流程控制","fold":true,"list":[{"prefix":"","tag":"if..else..","suffix":"","desc":"if(exp){...} //仅有一个语句时，可省略{}\nif(exp){...}else{...}\nif(exp){...}else if(exp){...}","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"switch","suffix":"","desc":"1.switch中的case为全等判断\n2.多个case使用同一个执行块应写为case 1: case2: ... \n3.每个case代码块内部的break不能少，否则会接着执行下一个case\n4.default用于在上面所有 case 都不为真时执行一个任务。\n```javascript\nswitch(x){\n    case val1 :\n        ...\n        break;\n    default :\n        ...\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"x?y:z","suffix":"","desc":"仅可连接表达式，最终有一个返回值","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"do","suffix":"{exp}","desc":"返回块级作用域内部最后执行的表达式的值","url":"","summary":"","reference":"","dot":""}]},{"title":"循环语句","fold":true,"list":[{"prefix":"","tag":"while","suffix":"","desc":"while(exp){...}//仅有一个语句时，可省略{}","url":"","summary":"```javascript\nvar l = a.length;\nwhile (l--) {\n  console.log(a[l]);\n}\n```","reference":"","dot":""},{"prefix":"","tag":"do..while","suffix":"","desc":"该循环会在检查条件是否为真之前执行一次代码块\n```javascript\ndo{\n    需要执行的代码\n}while(条件);\n```\nwhile语句后面的分号注意不要省略。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"for","suffix":"","desc":"设置循环变量的部分和循环体内部有各自单独的作用域，变量彼此不影响（使用let时）。\n```javascript\nfor (初始化表达式; 条件; 递增表达式) {\n    语句\n}\n```","url":"","summary":"初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。\n条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。\n递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。","reference":"","dot":""},{"prefix":"","tag":"break ","suffix":"[label]","desc":"不带参数时：break终止内层循环\n带参数时：break终止label处后面全部循环","url":"","summary":"标签也可以用于跳出代码块。\n```javascript\nfoo: {\n  console.log(1);\n  break foo;\n  console.log('本行不会输出');\n}\nconsole.log(2);\n// 1\n// 2\n```","reference":"","dot":""},{"prefix":"","tag":"continue ","suffix":"[label]","desc":"不带参数时：continue终止本轮循环（内层），返回循环结构的头部，开始下一轮循环\n带参数时：跳转至label后紧接的循环\n","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"label:","suffix":"","desc":"使用 break 或者 continue 来指出程序是否该停止循环还是继续循环","url":"","summary":"```javascript\ntop:\n  for (var i = 0; i < 3; i++){\n    for (var j = 0; j < 3; j++){\n      if (i === 1 && j === 1) continue top;\n      console.log('i=' + i + ', j=' + j);\n    }\n  }\n```","reference":"","dot":""}]}]},{"title":"全局","barcolor":"","fold":false,"box":[{"title":"属性","fold":false,"list":[{"prefix":"","tag":"globalThis ","suffix":"","desc":"JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域）\n1. 浏览器里面，顶层对象是**window**，但 Node 和 Web Worker 没有window。\n2. 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。\n3. Node 里面，顶层对象是**global**，但其他环境都不支持。","url":"","summary":"同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用**this**变量，但是有局限性。\n1. 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。\n2. 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。\n3. 不管是严格模式，还是普通模式，new Function('return this')()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么eval、new Function这些方法都可能无法使用。\n\n-------------------\n\nES2020 在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。","reference":"全局对象|http://es6.ruanyifeng.com/#docs/let#globalThis-%E5%AF%B9%E8%B1%A1","dot":""}]},{"title":"方法","fold":false,"list":[{"prefix":"","tag":"eval","suffix":"(str)","desc":"将传入的字符串当做 JavaScript 代码进行执行\n返回值：返回字符串中代码的返回值。如果返回值为空，则返回 undefined。\n1.eval没有自己的作用域，都在当前作用域内执行。可以读写当前作用域。\n2.在严格模式，eval内部*声明*的变量，不会影响到外部作用域。（仅为自身声明的）。\n3.eval“间接调用”时作用域总是全局作用域，凡是使用别名执行eval，eval内部一律是全局作用域。","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval","dot":""},{"prefix":"","tag":"void","suffix":"(exp)","desc":"void运算符对给定的表达式进行求值，然后返回 undefined\n在使用立即执行的函数表达式时，可以利用 void 运算符让 JavaScript 引擎把一个function关键字识别成函数表达式而不是函数声明（语句）","url":"","summary":"","reference":"","dot":""},{"prefix":"all.","tag":"valueOf()","suffix":"","desc":"自动类型转换时会默认调用这个方法\n默认返回自身","url":"","summary":"","reference":"","dot":""}]}]},{"title":"其它","barcolor":"","fold":false,"box":[{"title":"参考资料","fold":false,"list":[{"prefix":"","tag":"BOM","suffix":"","desc":"","url":"https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model","summary":"","reference":"","dot":""},{"prefix":"","tag":"DOM","suffix":"","desc":"","url":"https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model","summary":"","reference":"","dot":""},{"prefix":"","tag":"Web API","suffix":"","desc":"","url":"https://developer.mozilla.org/zh-CN/docs/Web/API","summary":"","reference":"","dot":""},{"prefix":"","tag":"Standard built-in objects","suffix":"","desc":"","url":"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects","summary":"","reference":"","dot":""},{"prefix":"","tag":"ES compatibility table","suffix":"","desc":"","url":"http://kangax.github.io/compat-table/es6/","summary":"","reference":"","dot":""},{"prefix":"","tag":"ECMAScript","suffix":"","desc":"","url":"https://tc39.es/ecma262/","summary":"","reference":"","dot":""}]},{"title":"教程指南","fold":false,"list":[{"prefix":"","tag":"ES5教程","suffix":"","desc":"","url":"https://wangdoc.com/javascript/index.html","summary":"","reference":"","dot":""},{"prefix":"","tag":"ES6教程","suffix":"","desc":"","url":"http://es6.ruanyifeng.com/","summary":"","reference":"","dot":""}]},{"title":"资源链接","fold":false,"list":[{"prefix":"","tag":"NPM","suffix":"","desc":"","url":"https://www.npmjs.com/","summary":"","reference":"","dot":""},{"prefix":"","tag":"Lodash","suffix":"","desc":"","url":"https://www.lodashjs.com/docs/latest","summary":"","reference":"","dot":""},{"prefix":"","tag":"Awesome Libs","suffix":"","desc":"","url":"https://www.awesomes.cn/repos?c=2619450","summary":"","reference":"","dot":""}]},{"title":"Node","fold":false,"list":[{"prefix":"","tag":"nvm","suffix":"","desc":"安装多个node版本","url":"","summary":"# 安装最新版本\n$ nvm install node\n\n# 安装指定版本\n$ nvm install 0.12.1\n\n# 使用已安装的最新版本\n$ nvm use node\n\n# 使用指定版本的node\n$ nvm use 0.12","reference":"github|https://github.com/nvm-sh/nvm\n参考资料|https://javascript.ruanyifeng.com/nodejs/basic.html#","dot":""},{"prefix":"","tag":"pm2","suffix":"","desc":"自动启动\n```\npm2 startup\npm2 save\n```","url":"","summary":"","reference":"github|https://github.com/Unitech/pm2","dot":""},{"prefix":"","tag":"nodemon","suffix":"","desc":"热启动 `nodemon app.js`","url":"https://www.npmjs.com/package/nodemon","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"数值","barcolor":"","fold":false,"box":[{"title":"值","fold":true,"list":[{"prefix":"","tag":"字面量","suffix":"","desc":"BigInt型：1n（BigInt 类型的数据必须添加后缀n，任何进制数都可以）\n十进制数：01、1 \n二进制数：0b01、0B10 （只能为0和1）\n八进制数：0o777 （小于8）\n十六进制数：0x10、0XAB （0~9A~F）\n指数计数法：1E2、1e2、0.1e2","url":"","summary":"JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回Infinity。\nBigInt 可以使用负号（-），但是不能使用正号（+）\nJavaScript 以前不能计算70的阶乘（即70!），现在可以通过BigInt来实现了\nBigInt 不能与普通数值进行混合运算。","reference":"BigInt|http://es6.ruanyifeng.com/#docs/number#BigInt-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B","dot":""},{"prefix":"","tag":"Infinity","suffix":"","desc":"无穷大","url":"","summary":"<table>\n<thead>\n    <tr>\n        <th scope=\"col\">属性</th>\n        <th scope=\"col\">描述</th>\n    </tr>\n</thead>\n<tbody>\n<tr>\n    <td>Number.MAX_VALUE</td>\n    <td>可表示的最大值 1.79e+308</td>\n</tr>\n<tr>\n    <td>Number.MIN_VALUE</td>\n    <td>可表示的最小值 5e-324</td>\n</tr>\n<tr>\n    <td>Number.NEGATIVE_INFINITY</td>\n    <td>特指“负无穷”;在溢出时返回</td>\n</tr>\n<tr>\n    <td>Number.POSITIVE_INFINITY</td>\n    <td>特指“正无穷”;在溢出时返回</td>\n</tr>\n<tr>\n    <td>Number.EPSILON</td>\n    <td>表示1和比最接近1且大于1的最小Number之间的差别</td>\n</tr>\n<tr>\n    <td>Number.MIN_SAFE_INTEGER</td>\n    <td>JavaScript最小安全整数.</td>\n</tr>\n<tr>\n    <td>Number.MAX_SAFE_INTEGER</td>\n    <td>JavaScript最大安全整数.</td>\n</tr>\n</tbody>\n</table>\n0/0=NaN，正数/0=正无穷，负数/0=负无穷 \n正无穷+正无穷=正无穷，负无穷+负无穷=负无穷，正无穷+负无穷=NaN\n无穷乘法操作得到无穷，无穷除法与求余操作得到NaN","reference":"","dot":""},{"prefix":"","tag":"NaN","suffix":"","desc":"非数值","url":"","summary":"任何与 NaN 进行运算的结果均为 NaN \nNaN 与自身不相等(NaN 不与任何值相等) ","reference":"","dot":""}]},{"title":"检测","fold":false,"list":[{"prefix":"","tag":"isNaN","suffix":"(val)","desc":"判断传递的值是否为 NaN\n全局isNaN会自动转换参数为数值再做判断，Number.isNaN不会自动转换","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"isFinite","suffix":"(val)","desc":"判断传递的值是否为有限数字\n全局的isFinite会自动转换参数为数值再作判断，Number.isFinite不会自动转换","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Number.isInteger","suffix":"(val)","desc":"判断传递的值是否为整数\nIE不支持","url":"","summary":"","reference":"polyfill|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger","dot":""},{"prefix":"","tag":"Number.isSafeInteger","suffix":"(val)","desc":"判断传递的值是否为安全整数","url":"","summary":"一个安全整数是一个符合下面条件的整数：\n1. 可以准确地表示为一个IEEE-754双精度数字\n2. 其IEEE-754表示不能是舍入任何其他整数以适应IEEE-754表示的结果。.","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger","dot":""}]},{"title":"转换","fold":false,"list":[{"prefix":"(num).","tag":"toString","suffix":"([rad])","desc":"将一个10进制数转为指定进制表示的字符串，范围[2~36]。\n```(2).toString(2) -> 10```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"parseInt","suffix":"(val[,rad])","desc":"将一个字符串(非字符串先转为字符串)根据指定的进制转为一个十进制整数（默认10进制）\n```parseInt('10',2) -> 2```\nBigInt.parseInt(string[, radix])：近似于Number.parseInt()，将一个字符串转换成指定进制的 BigInt。","url":"","summary":"<table>\n    <tr>\n        <th>value</th>\n        <th>结果</th>\n    </tr>\n    <tr>\n        <td>空字符串</td>\n        <td>NaN</td>\n    </tr>\n    <tr>\n        <td>第一个非空字符不是数值或负号</td>\n        <td>NaN</td>\n    </tr>\n    <tr>\n        <td>第一个非空字符是数值，遇到非数值时停止解析</td>\n        <td>number</td>\n    </tr>\n</table>\n","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/parseInt","dot":""},{"prefix":"","tag":"parseFloat","suffix":"(val)","desc":"把字符串参数解析成浮点数\n第一个小数点有效，第二个无效","url":"","summary":"","reference":"","dot":""}]},{"title":"表示","fold":false,"list":[{"prefix":"(num).","tag":"toFixed","suffix":"([n])","desc":"指定小数点后位数，小数位数[0 ~ 20]\n会四舍五入，返回的是一个字符串\nMath.trunc(val) 将数字的小数部分去掉，只保留整数部分","url":"","summary":"","reference":"","dot":""},{"prefix":"(num).","tag":"toPrecision","suffix":"([n])","desc":"四舍五入到参数指定的显示数字位数，包括小数前的位数。\n无参数时等同转为字符串","url":"","summary":"","reference":"","dot":""},{"prefix":"(num).","tag":"toExponential","suffix":"([n])","desc":"使用科学计数法，小数位数[0~20]\n对基于n位进行四舍五入，返回的是一个字符串","url":"","summary":"一个用幂的形式 (科学记数法 e+n = *10^n) 来表示Number 对象的字符串。小数点后以fractionDigits 提供的值来四舍五入。如果 fractionDigits 参数被忽略了，小数点后的将尽可能用最多的位数来表示该数值。","reference":"","dot":""},{"prefix":"(num).","tag":"toLocaleString","suffix":"([local],[opt])","desc":"返回一个语言环境下的表示字符串\n仅浏览器中有效","url":"","summary":"```javascript\n$num.toLocaleString() //自动根据千位周期加逗号\n$num.toLocaleString('zh-Hans-CN-u-nu-hanidec')  //中文数字\n$num.toLocaleString('cn-ZH',{\n    style:'currency',\n    currency:'CNY',\n    currencyDisplay:'symbol'\n}) //人民币货币\n//en-US、USD  美元\n//en-JP、JPY  日元\n//EUR 欧元","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString","dot":""}]}]},{"title":"数学","barcolor":"","fold":false,"box":[{"title":"随机数","fold":false,"list":[{"prefix":"","tag":"Math.random()","suffix":"","desc":"返回一个浮点,  伪随机数在范围[0，1)\n也就是说，从0（包括0）往上，但是不包括1（排除1）","url":"","summary":"不能提供像密码一样安全的随机数字，不能使用它们来处理有关安全的事情。使用Web Crypto API 来代替, 和更精确的window.crypto.getRandomValues() 方法.","reference":"","dot":""},{"prefix":"","tag":"_.range","suffix":"([start],end,[step=1])","desc":"创建一个包含从 start 到 end，但不包含 end 本身范围数字的数组。\n如果 start 是负数，而 end 或 step 没有指定，那么 step 从 -1 为开始。\n如果 end 没有指定，start 设置为 0。\n如果 end 小于 start ，会创建一个空数组，除非指定了 step。","url":"","summary":"","reference":"","dot":""}]},{"title":"常用方法","fold":false,"list":[{"prefix":"","tag":"Math.max","suffix":"(val..|...arr)","desc":"返回一组数中最大值\n解构数组","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.min","suffix":"(val..|...arr)","desc":"返回一组数中最小值","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.abs","suffix":"(val)","desc":"返回绝对值","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.ceil","suffix":"(val)","desc":"向上取整","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.floor","suffix":"(val)","desc":"向下取整","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.round","suffix":"(val)","desc":"返回一个数字四舍五入后最接近的整数\nMath.fround() 可以将任意的数字转换为离它最近的单精度浮点数形式的数字。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.pow","suffix":"(x,n)","desc":"返回x的n次方","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.sqrt","suffix":"(val)","desc":"返回一个数的平方根","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.cbrt","suffix":"(val)","desc":"返回任意数字的立方根","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Math.hypot","suffix":"(x,y,z..)","desc":"返回它的所有参数的平方和的平方根\n如果有参数不能转换为数字，则返回 NaN","url":"","summary":"","reference":"","dot":""}]},{"title":"其它","fold":true,"list":[{"prefix":"","tag":"预定义常量","suffix":"","desc":"Math 适用于 Number 类型。它不支持 BigInt。\nMath.E  欧拉常数，自然对数的底数, 约等于 2.718。\nMath.LN2  2的自然对数, 约等于 0.693。\nMath.LN10  10的自然对数, 约等于 2.303。\nMath.LOG2E  以2为底E的对数, 约等于 1.443。\nMath.LOG10E  以10为底E的对数, 约等于 0.434。\nMath.PI  圆周率，一个圆的周长和直径之比，约等于 3.14159。\nMath.SQRT1_2  1/2的平方根, 约等于 0.707。\nMath.SQRT2  2的平方根,约等于 1.414。","url":"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math","summary":"","reference":"","dot":""},{"prefix":"","tag":"指数对数","suffix":"","desc":"Math.log(val)\t返回一个数的自然对数\nMath.log10(val)\t返回一个数以10位底的对数\nMath.log1p(val)\t返回一个数字加1后的自然对数 (底为 E), 既log(x+1).\nMath.log2(val)\t返回一个数以2位底的对数\nMath.exp(val)\t返回一个数以e位底的val次方\nMath.expm1(val)\t返回一个数以e位底的val次方-1","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"三角函数","suffix":"","desc":"Math.cos(val)\t返回一个数的余弦。\nMath.cosh(val)\t返回一个数的双曲余弦。\nMath.acos(val)\t返回一个数的反余弦。\nMath.acosh(val)\t返回一个数的反双曲余弦。\n\nMath.sin(val)\t返回一个数的正弦。\nMath.sinh(val)\t返回一个数的双曲正弦。\nMath.asin(val)\t返回一个数的反正弦。\nMath.asinh(val)\t返回一个数的反双曲正弦。\n\nMath.tan(val)\t返回一个数的正切。\nMath.tanh(val)\t返回一个数的双曲正切。\nMath.atan(val)\t返回一个数的反正切。\nMath.atan2(val)\t返回两个变量 x 和 y 的反正切。\nMath.atanh(val)\t返回一个数的反双曲正切。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"其它","suffix":"","desc":"+ Math.clz32(val) 返回一个数字在转换成 32 无符号整形数字的二进制形式后, 开头的 0 的个数\n+ Math.imul(a, b) 将两个参数分别转换为 32 位整数，相乘后返回 32 位结果，类似 C 语言的 32 位整数相乘。\n+ Math.sign(val) 返回一个数字的符号, 指示数字是正数，负数还是零。此函数共有5种返回值, 分别是 1, -1, 0, -0, NaN. 代表的各是正数, 负数, 正零, 负零, NaN。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"日期和时间","barcolor":"","fold":false,"box":[{"title":"创建","fold":false,"list":[{"prefix":"","tag":"Date()","suffix":"","desc":"返回一个代表当前时间的字符串\nSun Feb 16 2020 15:59:35 GMT+0800 (GMT+08:00)\n无论有没有参数，直接调用Date总是返回当前时间。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"new Date()","suffix":"","desc":"返回值：Date对象的实例\n实例代表的就是当前时间","url":"","summary":"其他对象求值的时候，都是默认调用.valueOf()方法，但是Date实例求值的时候，默认调用的是toString()方法。这导致对Date实例求值，返回的是一个字符串，代表该实例对应的时间。","reference":"","dot":""},{"prefix":"","tag":"new Date","suffix":"(timestamp)","desc":"指定时间戳的时间对象\n参数可以是负整数，代表1970年元旦之前的时间","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"new Date","suffix":"(yyyy-mm-dd)","desc":"只要是能被Date.parse()方法解析的字符串，都可以当作参数。\nnew Date('2013-2-15')\nnew Date('2013/2/15')","url":"","summary":"```javascript\nnew Date('02/15/2013')\nnew Date('2013-FEB-15')\nnew Date('FEB, 15, 2013')\nnew Date('FEB 15, 2013')\nnew Date('February, 15, 2013')\nnew Date('February 15, 2013')\nnew Date('15 Feb 2013')\nnew Date('15, February, 2013')\n```\n表示日期的字符串值。该字符串应该能被 Date.parse() 正确方法识别（即符合 IETF-compliant RFC 2822 timestamps 或 version of ISO8601）。","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date","dot":""},{"prefix":"","tag":"new Date","suffix":"(y,m[,d,h,m,s,ms])","desc":"日期索引从1开始，其余从0开始\n年和月是不能省略的，其他参数都可以省略的，否则将作为timestamp解析\n参数还可以使用负数，表示扣去的时间。","url":"","summary":"年：使用四位数年份，比如2000。如果写成两位数或个位数，则加上1900，即10代表1910年。如果是负数，表示公元前。\n月：0表示一月，依次类推，11表示12月。\n日：1到31。\n小时：0到23。\n分钟：0到59。\n秒：0到59\n毫秒：0到999。\n\n---------------\n\n这些参数如果超出了正常范围，会被自动折算。比如，如果月设为15，就折算为下一年的4月。\n日期设为0，就代表上个月的最后一天。\n```javascript\nnew Date(2013, 15)\n// Tue Apr 01 2014 00:00:00 GMT+0800 (CST)\nnew Date(2013, 0, 0)\n// Mon Dec 31 2012 00:00:00 GMT+0800 (CST)\n```\n","reference":"参考资料|https://wangdoc.com/javascript/stdlib/date.html","dot":""},{"prefix":"","tag":"Date.UTC","suffix":"(y,m[,d,h,m,s,ms])","desc":"与构造方法的区别为：被解释为 UTC 时间（世界标准时间）\nDate构造函数的参数会被解释为当前时区的时间。","url":"","summary":"","reference":"","dot":""}]},{"title":"时间戳","fold":false,"list":[{"prefix":"","tag":"Date.now()","suffix":"","desc":"返回值：数值\n返回自 1970 年 1 月 1 日 00:00:00 (UTC) 到当前时间的毫秒数。\n**其它大部分编程接口提供的为秒数，需要*1000**","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Date.parse","suffix":"(str)","desc":"返回值：数字\n解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。\n如果解析失败，返回NaN。\nDate.parse('2020-2-16')\nDate.parse('2020/2/16')","url":"","summary":"","reference":"","dot":""}]},{"title":"计算","fold":false,"list":[{"prefix":"","tag":"dt2 - dt1","suffix":"","desc":"间隔的毫秒数","url":"","summary":"如果使用+号，则为拼接2个求值字符串","reference":"","dot":""},{"prefix":"dt.","tag":"get[UTC]*()","suffix":"","desc":"返回值：对应值整数\ngetFullYear()：返回四位的年份。\ngetMonth()：返回月份（0表示1月，11表示12月）。\ngetDate()：返回实例对象对应每个月的几号（从1开始）。\ngetDay()：返回星期几，星期日为0，星期一为1，以此类推。\ngetHours()：返回小时（0-23）。\ngetMinutes()：返回分钟（0-59）。\ngetSeconds()：返回秒（0-59）。\ngetMilliseconds()：返回毫秒（0-999）。\ngetTime()：返回实例距离1970年1月1日00:00:00的毫秒数，等同于valueOf方法。\ngetTimezoneOffset()：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。","url":"","summary":"","reference":"","dot":""},{"prefix":"dt.","tag":"set[UTC]*","suffix":"(val)","desc":"返回值：新的日期对象的时间戳\nsetFullYear(year [, month, date])：设置四位年份。\nsetMonth(month [, date])：设置月份（0-11）。\nsetDate(date)：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。\nsetHours(hour [, min, sec, ms])：设置小时（0-23）。\nsetMinutes(min [, sec, ms])：设置分钟（0-59）。\nsetSeconds(sec [, ms])：设置秒（0-59）。\nsetMilliseconds()：设置毫秒（0-999）。\nsetTime(milliseconds)：设置毫秒时间戳。\n","url":"","summary":"","reference":"","dot":""},{"prefix":"dt.","tag":"set","suffix":"(getv + diff)","desc":"```javascript\nvar d = new Date();\n// 将日期向后推1000天\nd.setDate(d.getDate() + 1000);\n// 将时间设为6小时后\nd.setHours(d.getHours() + 6);\n// 将年份设为去年\nd.setFullYear(d.getFullYear() - 1);\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"Moment","fold":false,"list":[{"prefix":"","tag":"moment","suffix":"","desc":"npm install moment","url":"http://momentjs.cn/","summary":"","reference":"","dot":""},{"prefix":"","tag":"moment","suffix":"([val])","desc":"解析一个时间对象或使用当前时间","url":"","summary":"","reference":"参考资料|http://momentjs.cn/docs/#/parsing/defaults/","dot":""},{"prefix":"moment.","tag":"get|set","suffix":"([val])","desc":"取值/赋值\n星期从星期天0开始，日期从1开始，月份从0开始","url":"","summary":"","reference":"参考资料|http://momentjs.cn/docs/#/get-set/get/","dot":""},{"prefix":"moment.","tag":"add|subtract","suffix":"(n,unit)","desc":"加减\n```moment().add(7, 'd');```\n<table class=\"table table-striped table-bordered\">\n  <tbody>\n    <tr>\n      <th>键</th>\n      <th>快捷键</th>\n    </tr>\n    <tr>\n      <td>years</td>\n      <td>y</td>\n    </tr>\n    <tr>\n      <td>quarters</td>\n      <td>Q</td>\n    </tr>\n    <tr>\n      <td>months</td>\n      <td>M</td>\n    </tr>\n    <tr>\n      <td>weeks</td>\n      <td>w</td>\n    </tr>\n    <tr>\n      <td>days</td>\n      <td>d</td>\n    </tr>\n    <tr>\n      <td>hours</td>\n      <td>h</td>\n    </tr>\n    <tr>\n      <td>minutes</td>\n      <td>m</td>\n    </tr>\n    <tr>\n      <td>seconds</td>\n      <td>s</td>\n    </tr>\n    <tr>\n      <td>milliseconds</td>\n      <td>ms</td>\n    </tr>\n  </tbody>\n</table>","url":"","summary":"","reference":"参考资料|http://momentjs.cn/docs/#/manipulating/add/","dot":""},{"prefix":"moment.","tag":"format","suffix":"(YYYY-MM-DD)","desc":"符号|说明|补充\n---|:--:|---:\nYYYY|年份|\nM MM|月份数字|MMMM 语言环境中的月份\nD DD|日期|\nE|星期几|e 语言环境的星期几\nH HH|24 小时制|h hh 12 小时制\nm mm|分钟|\ns ss|秒钟|\nQ|季度|\nDDDD|年的某天|\nWW|年的第几周|","url":"","summary":"","reference":"参考资料|http://momentjs.cn/docs/#/displaying/format/","dot":""},{"prefix":"moment.","tag":"fromNow()","suffix":"","desc":"```moment([2007, 0, 29]).fromNow(); // 4 年前```","url":"","summary":"","reference":"参考资料|http://momentjs.cn/docs/#/displaying/fromnow/","dot":""},{"prefix":"","tag":"moment.locale('zh-cn')","suffix":"","desc":"","url":"","summary":"```javascript\nimport moment from 'moment'\n// 里面的字符可以根据自己的需要进行调整\nmoment.locale('zh-cn', {\n    months: '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),\n    monthsShort: '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),\n    weekdays: '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),\n    weekdaysShort: '周日_周一_周二_周三_周四_周五_周六'.split('_'),\n    weekdaysMin: '日_一_二_三_四_五_六'.split('_'),\n    longDateFormat: {\n        LT: 'HH:mm',\n        LTS: 'HH:mm:ss',\n        L: 'YYYY-MM-DD',\n        LL: 'YYYY年MM月DD日',\n        LLL: 'YYYY年MM月DD日Ah点mm分',\n        LLLL: 'YYYY年MM月DD日ddddAh点mm分',\n        l: 'YYYY-M-D',\n        ll: 'YYYY年M月D日',\n        lll: 'YYYY年M月D日 HH:mm',\n        llll: 'YYYY年M月D日dddd HH:mm'\n    },\n    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,\n    meridiemHour: function (hour, meridiem) {\n        if (hour === 12) {\n            hour = 0;\n        }\n        if (meridiem === '凌晨' || meridiem === '早上' ||\n            meridiem === '上午') {\n            return hour;\n        } else if (meridiem === '下午' || meridiem === '晚上') {\n            return hour + 12;\n        } else {\n            // '中午'\n            return hour >= 11 ? hour : hour + 12;\n        }\n    },\n    meridiem: function (hour, minute, isLower) {\n        const hm = hour * 100 + minute;\n        if (hm < 600) {\n            return '凌晨';\n        } else if (hm < 900) {\n            return '早上';\n        } else if (hm < 1130) {\n            return '上午';\n        } else if (hm < 1230) {\n            return '中午';\n        } else if (hm < 1800) {\n            return '下午';\n        } else {\n            return '晚上';\n        }\n    },\n    calendar: {\n        sameDay: '[今天]LT',\n        nextDay: '[明天]LT',\n        nextWeek: '[下]ddddLT',\n        lastDay: '[昨天]LT',\n        lastWeek: '[上]ddddLT',\n        sameElse: 'L'\n    },\n    dayOfMonthOrdinalParse: /\\d{1,2}(日|月|周)/,\n    ordinal: function (number, period) {\n        switch (period) {\n            case 'd':\n            case 'D':\n            case 'DDD':\n                return number + '日';\n            case 'M':\n                return number + '月';\n            case 'w':\n            case 'W':\n                return number + '周';\n            default:\n                return number;\n        }\n    },\n    relativeTime: {\n        future: '%s内',\n        past: '%s前',\n        s: '几秒',\n        ss: '%d秒',\n        m: '1分钟',\n        mm: '%d分钟',\n        h: '1小时',\n        hh: '%d小时',\n        d: '1天',\n        dd: '%d天',\n        M: '1个月',\n        MM: '%d个月',\n        y: '1年',\n        yy: '%d年'\n    },\n    week: {\n        // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效\n        dow: 1, // Monday is the first day of the week.\n        doy: 4  // The week that contains Jan 4th is the first week of the year.\n    }\n})\n```","reference":"参考资料|https://www.jianshu.com/p/5715f4bad95c","dot":""}]}]}]},{"column":[{"title":"字符串","barcolor":"","fold":false,"box":[{"title":"基本","fold":false,"list":[{"prefix":"str","tag":"[i]","suffix":"","desc":"等同str.charAt(n) 返回索引上的字符\n\n字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。\n如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined。\n但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"length","suffix":"","desc":"返回字符串的长度，该属性也是无法改变的","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"repeat","suffix":"(n)","desc":"参数：重复次数(包含原) \n返回值：新的字符串 \n原对象：不变\n会向下取整，当为0时变为空字符串","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"padStart|End","suffix":"(len,val)","desc":"str.padStart(len,val) 使用val补齐str长度至len，补前\nstr.padEnd(len,val) 使用val补齐str长度至len，补后","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"trim()","suffix":"","desc":"返回值：新字符串\n原对象：不变 \n移除字符串的两端删除空白字符。\n空白字符包括所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。\n\nstr.trimStart|trimLeft() 消除字符串头部的空格\nstr.trimEnd|trimRight() 消除尾部的空格","url":"","summary":"","reference":"","dot":""}]},{"title":"转换","fold":false,"list":[{"prefix":"str.","tag":"toUpperCase()","suffix":"","desc":"返回值：新字符串\n原对象：不变\n转为大写","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"toLowerCase()","suffix":"","desc":"返回值：新字符串\n原对象：不变\n转为小写 ","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"normalize()","suffix":"","desc":"按指定Unicode正规形式将当前字符串正规化。\n参数：四种 Unicode 正规形式 \"NFC\", \"NFD\", \"NFKC\", 以及 \"NFKD\" 其中的一个, 默认值为 \"NFC\"","url":"","summary":"","reference":"参考资料|http://es6.ruanyifeng.com/#docs/string#normalize","dot":""},{"prefix":"","tag":"String.raw","suffix":"(str)","desc":"会对斜杠进行转义","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/raw","dot":""}]},{"title":"拼割","fold":false,"list":[{"prefix":"str.","tag":"slice","suffix":"[start,end)","desc":"参数：起始位置，末尾位置（不包含）\n返回值：被截取得到的新字符串\n原对象：不变\n当只有1个参数时，则为起始位置到末尾全部，且包含末尾元素（即m=arr.length）。\nn和m可为负值，-1 指最后一个元素，-2 指倒数第二个元素。","url":"","summary":"str.substring[n,m) 参数不接受负数","reference":"","dot":""},{"prefix":"str.","tag":"substr","suffix":"(start,len)","desc":"参数：开始提取字符的位置（如为负数，则用len+n），提取的字符数\n返回值：新字符串 \n原对象：不变\n如果第二个参数是负数，将被自动转为0，因此会返回空字符串。","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"split","suffix":"(re,[len])","desc":"参数1：字符串或正则表达式 \n参数2：最大的数组长度 \n返回值：数组 \n原对象：不变 \n把字符串按指定符号或正则分割为字符串数组\n亦可通过...扩展运算符直接转为无符号分割的数组","url":"","summary":"","reference":"","dot":""},{"prefix":"arr.","tag":"join","suffix":"([sep])","desc":"使用指定符号把数组元素拼接为字符串\n参数：符号，默认为逗号,\n返回：新字符串\n原对象：不变\n如果元素是undefined 或者null，则会转化成空","url":"","summary":"","reference":"","dot":""}]},{"title":"查找","fold":false,"list":[{"prefix":"str.","tag":"includes","suffix":"(val,[i])","desc":"返回值：true/false\n参数：从i索引处开始查找val,默认为 0\n如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。\n当指定了i的时候升序查找到末端不会再从头查找","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"indexOf","suffix":"(val,[i])","desc":"参数：正向查找指定值,i为起始索引\n返回值：第一个出现的索引位置；如查找不到则返回-1","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"lastIndexOf","suffix":"(val,[i])","desc":"参数：逆向查找指定值,i为起始索引 \n返回值：最后一个出现的索引位置；如查找不到则返回-1 ","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"startsWith","suffix":"(val,[i])","desc":"返回布尔值，表示参数字符串是否在原字符串的头部。\n第二个参数，表示开始搜索的位置","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"endsWidth","suffix":"(val,[i])","desc":"返回布尔值，表示参数字符串是否在原字符串的尾部。\n第二个参数表示针对前n个字符","url":"","summary":"","reference":"","dot":""}]},{"title":"排序","fold":false,"list":[{"prefix":"str.","tag":"localeCompare","suffix":"(str)","desc":"比较两个字符串，它返回一个整数：\n如果小于0，表示第一个字符串小于第二个字符串；\n如果大于0，表示第一个字符串大于第二个字符串；\n如果等于0，表示两者相等。\n\na<A，你<我，不是按照码点，Safari不支持","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare","dot":""},{"prefix":"","tag":"new Intl.Collator(lang).compare(x,y)","suffix":"","desc":"字符对比 ```new Intl.Collator('zh-Hans-CN').compare(x,y)```\n数组排序 ```arr.sort(new Intl.Collator('zh-Hans-CN').compare)```\na<A，你<我，Safari支持","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Collator","dot":""}]}]},{"title":"正则表达式","barcolor":"","fold":false,"box":[{"title":"匹配","fold":false,"list":[{"prefix":"str.","tag":"search","suffix":"(re)","desc":"可第一个匹配到的索引位置\n\n匹配返回：第一个子串的索引\n未匹配返回：-1\t\t\t","url":"","summary":"始终从头开始找，找到一个即返回，正则无需全局设置","reference":"","dot":""},{"prefix":"str.","tag":"match","suffix":"(re)","desc":"求匹配到的次数\n\n匹配返回：子串数组\n未匹配返回：null","url":"","summary":"如果传入非正则，会隐式地转换为正则表达式；\n如果没有参数，会返回空数组；\n数组： \n1.进行匹配完整的字符串 \n2.圆括号捕获的结果 \n3.index: 0，匹配结果在原字符串中的索引 \n4.input: \"原字符串\" ","reference":"","dot":""},{"prefix":"str.","tag":"replace","suffix":"(re,val|fn)","desc":"替换匹配内容\n\n返回值：新的字符串\n原对象：不变 ","url":"","summary":"参数1：需要替换的字符或正则表达式，没有全局标识时只替换一次 \n参数2：替换成的字符串或生成字符串的函数，用return返回","reference":"指定一个函数作为参数|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace\n示例资料|https://wangdoc.com/javascript/stdlib/regexp.html#stringprototypereplace","dot":""},{"prefix":"str.","tag":"matchAll","suffix":"(re)","desc":"一次性取出所有匹配（g 修饰符加不加都可以）\n返回值：遍历器，可通过for..of遍历，或使用[...ite]或Array.from(ite)转为数组\n","url":"","summary":"```javascript\n// 转为数组方法一\n[...string.matchAll(regex)]\n\n// 转为数组方法二\nArray.from(string.matchAll(regex))\n```","reference":"","dot":""}]},{"title":"正则表达式","fold":false,"list":[{"prefix":"","tag":"/pattern/","suffix":"flag","desc":"字面量 ```var regex = /xyz/flag```\n构造函数 ```var regex = new RegExp('xyz',flag)```\n前者在引擎编译代码时，就会新建正则表达式，效率较高\n后者在运行时新建正则表达式，必须引入字符串时使用，但如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。```new RegExp('1\\\\+1')```\n\n-------------\n\n正则模式不含g修饰符，每次都是从字符串头部开始匹配。\n正则模式含有g修饰符，每次都是从上一次匹配成功处，开始向后匹配。\n\n-------------\n\n修饰符：gis\ng：全局匹配。 \ni：忽略大小写。 \nm：多行模式，自动识别换行符，按分割每个换行内容进行匹配。\ny：执行“粘性”搜索,匹配从目标字符串的当前位置开始。 \nu：正确处理大于\\uFFFF的 Unicode 字符（点.字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。）\ns：让.可匹配行终止符","url":"","summary":"re.prototype.global：返回一个布尔值，表示是否设置了g修饰符，只读。\nre.ignoreCase：返回一个布尔值，表示是否设置了i修饰符，只读。\nre.prototype.multiline：返回一个布尔值，表示是否设置了m修饰符，只读。\nre.prototype.sticky：返回一个布尔值，表示是否设置了y修饰符，只读。\nre.prototype.unicode：返回一个布尔值，表示是否设置了u修饰符，只读。\nre.prototype.dotAll：返回一个布尔值，表示是否设置了s修饰符，只读。\nre.prototype.flags：返回一个字符串，包含了已经设置的所有修饰符，按字母排序，只读。\nre.lastIndex：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义。\nre.source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。\n\ny修饰符确保匹配必须从剩余的第一个位置开始\ny修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。\ny修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。\ng修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误","reference":"","dot":""},{"prefix":"re.","tag":"test","suffix":"(str)","desc":"是否存在匹配返回布尔值\n匹配返回：true\n未匹配返回：false","url":"","summary":"带有g修饰符时，可以通过正则对象的lastIndex属性指定开始搜索的位置。","reference":"","dot":""},{"prefix":"re.","tag":"exec","suffix":"(str)","desc":"当结果为真时循环执行，可捕获分组结果\n```var result = re.exec(str)```\n\n匹配返回：结果组\n未匹配返回：null\n\n[1]是第一个圆括号匹配的结果 $1 \nindex：该次匹配成功的开始位置（从0开始计数），需多次执行\ngroups：具名组匹配结果","url":"","summary":"```javascript\nvar regex = /t(e)(st(\\d?))/g;\nvar string = 'test1test2test3';\n\nvar matches = [];\nvar match;\nwhile (match = regex.exec(string)) {\n  matches.push(match);\n}\n\nmatches\n// [\n//   [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"],\n//   [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"],\n//   [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"]\n// ]\n```","reference":"","dot":""},{"prefix":"result.","tag":"$n","suffix":"","desc":"指定分组部分结果\n等同```result[n]```","url":"","summary":"","reference":"","dot":""},{"prefix":"result.","tag":"groups","suffix":".gname","desc":"具名组匹配\n分组具名 ```(?<gname>exp)```\n在正则表达式内部引用某个“具名组匹配” ```\\k<gname>exp```\n在exec方法返回结果的groups属性上引用该组名","url":"","summary":"```javascript\nconst RE_DATE = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n\nconst matchObj = RE_DATE.exec('1999-12-31');\nconst year = matchObj.groups.year; // 1999\nconst month = matchObj.groups.month; // 12\nconst day = matchObj.groups.day; // 31\n```","reference":"参考资料|http://es6.ruanyifeng.com/#docs/regex#%E5%85%B7%E5%90%8D%E7%BB%84%E5%8C%B9%E9%85%8D","dot":""}]}]},{"title":"编码解码","barcolor":"","fold":false,"box":[{"title":"字符","fold":false,"list":[{"prefix":"","tag":"\\u{hhhh}","suffix":"","desc":"JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。\n每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。","url":"","summary":"（1）\\HHH\n反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的 Unicode 码点，比如\\251表示版权符号。显然，这种方法只能输出256种字符。\n\n（2）\\xHH\n\\x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的 Unicode 码点，比如\\xA9表示版权符号。这种方法也只能输出256种字符。\n\n（3）\\uXXXX\n\\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。XXXX对应该字符的 Unicode 码点，比如\\u00A9表示版权符号。","reference":"参考资料|https://wangdoc.com/javascript/types/string.html#%E8%BD%AC%E4%B9%89\nES6改进|http://es6.ruanyifeng.com/#docs/string#%E5%AD%97%E7%AC%A6%E7%9A%84-Unicode-%E8%A1%A8%E7%A4%BA%E6%B3%95\nutf-8 vs utf-16|https://www.cnblogs.com/kingcat/archive/2012/10/16/2726334.html","dot":""},{"prefix":"str.","tag":"charCodeAt","suffix":"(i)","desc":"参数：查找的索引位置\n返回值：unicode码点(十进制) (0~65535 2个字节16位)\n如果索引超出范围，则返回 NaN。","url":"","summary":"","reference":"","dot":""},{"prefix":"str.","tag":"codePointAt","suffix":"(i)","desc":"参数：查找的索引位置\n返回值：unicode码点（十进制）\n支持大于2个字节的Uniode编码\nIE11+","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"String.fromCharCode","suffix":"(n,..)","desc":"参数：unicode码点\n返回值：字符串","url":"","summary":"一系列UTF-16代码单元的数字。 范围介于0到65535（0xFFFF）之间。 大于0xFFFF的数字将被截断。 不进行有效性检查。","reference":"","dot":""},{"prefix":"","tag":"String.fromCodePoint","suffix":"(n,..)","desc":"参数：unicode码点\n返回值：字符串\n支持大于2个字节的Uniode编码","url":"","summary":"","reference":"","dot":""}]},{"title":"URI","fold":false,"list":[{"prefix":"","tag":"URI","suffix":"","desc":"将字符编码为URL合法字符。非合法字符使用% + UTF-8编码(十六进制)表示。","url":"","summary":"网页的 URL 只能包含合法的字符。合法字符分成两类。\n# URL 元字符：\n分号（;），逗号（,），斜杠（/），问号（?），冒号（:），at（@），&，等号（=），加号（+），美元符号（$），井号（#）\n# 语义字符：\na-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（'），圆括号（()）\n除了以上字符，其他字符出现在 URL 之中都必须转义，规则是根据操作系统的默认编码，将每个字节转为百分号（%）加上两个大写的十六进制字母。\n\n“春”的 UTF-8 编码分别是E6 98 A5\nURI即%E6%98%A5","reference":"","dot":""},{"prefix":"","tag":"encodeURI","suffix":"(str)","desc":"转码整个 URL。它的参数是一个字符串，代表整个 URL。\n它会将元字符和语义字符之外的字符，都进行转义。","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURI","dot":""},{"prefix":"","tag":"encodeURIComponent","suffix":"(str)","desc":"用于转码 URL 的组成部分，会转码除了语义字符之外的所有字符，即元字符也会被转码。\n所以，它不能用于转码整个 URL。它接受一个参数，就是 URL 的片段。\nURL建议手动拼接，推荐使用encodeURIComponent编码用户内容","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent","dot":""},{"prefix":"","tag":"decodeURI","suffix":"(code)","desc":"用于整个 URL 的解码。它是encodeURI()方法的逆运算。\n它接受一个参数，就是转码后的 URL。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"decodeURIComponent","suffix":"(code)","desc":"用于URL 片段的解码。它是encodeURIComponent()方法的逆运算。\n它接受一个参数，就是转码后的 URL 片段。","url":"","summary":"","reference":"","dot":""}]},{"title":"Base64","fold":false,"list":[{"prefix":"","tag":"base64","suffix":"","desc":"每3个字节将会被编码成四个字符, 如果不足3个字节, 则补上垫字符=, 缺几个就补几个。","url":"","summary":"# 编码 \n1. 每三个字节作为一组，每个字节8bit, 一共是24个二进制位。\n2. 将每组的24个二进制位再细分为四组，每组有6个二进制位, 此时为二维数组。\n3. 在每组前面加两个00，扩展成32个二进制位，即四个字节。\n4. 将每组对应的二进制转成十进制, 在base64char字符集中找到对应的字符。\n5. 将最后的结果连接成字符串, 则为最终编码结果。\n\n# 解码\n1. 每四个字节分为一组。\n2. 将每组的中除了垫字符=外的字符, 在base64char字符集中找到所在下标。\n3. 将十进制下标转成二进制, 如果不够6位（一定不会超过6位）, 则在前面补0。\n    + 如果遇到垫字符=, 说明其明文不足3字节, 则根据垫字符=的数量, 在该组最后一项中去掉对应个数的0\n    + 一个垫字符, 则去掉两个0\n    + 两个垫字符, 则去掉四个0\n4. 将每组中的二进制字符串连接，此时字符串长度一定是8的倍数，然后每8位分割成一个字节。\n5. 通过String.fromCharCode将二进制转成字符, 然后拼接\n6. 将各个字符连接, 为最终解码结果。","reference":"参考资料|https://juejin.im/post/5ccf01d5e51d453a363848d6","dot":""},{"prefix":"","tag":"btoa(str)|atob(base64)","suffix":"","desc":"浏览器自带的base64编码解码方法，但不支持ASCII以外字符\n对于中文，需要先用encodeURIComponent进行编码\n编码 ```let encodedData = btoa(stringToEncode)```\n解码 ```var decodedData = atob(encodedData)```\n浏览器的编码会使用 - 以及 _ 代替标准 Base64 字母表中的 + 和 /。","url":"","summary":"","reference":"btoa|https://developer.mozilla.org/zh-CN/docs/Web/API/WindowBase64/btoa\natob|https://developer.mozilla.org/zh-CN/docs/Web/API/WindowBase64/atob","dot":""},{"prefix":"","tag":"Buffer.from(str|base64).toString('base64'|)","suffix":"","desc":"Nodejs中的实现\n编码 ```Buffer.from(str).toString('base64')```\n解码 ```Buffer.from(b64Encoded, 'base64').toString()```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"js-base64","suffix":"","desc":"npm install --save js-base64\nvar Base64 = require('js-base64').Base64;\n编码 Base64.encode(str) | Base64.encodeURI('中文')\n解码 Base64.decode(base64) | Base64.atob(图片Base64)","url":"","summary":"","reference":"","dot":""}]},{"title":"HTML","fold":false,"list":[{"prefix":"","tag":"_.escape","suffix":"(str)","desc":"转义string中的 \"&\", \"<\", \">\", '\"', \"'\", 和 \"`\" 字符为HTML实体字符。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"_.unescape","suffix":"(str)","desc":"将html实体转为html标签","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"数组","barcolor":"","fold":false,"box":[{"title":"基本","fold":false,"list":[{"prefix":"arr","tag":"[i]","suffix":"","desc":"本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。\nJavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/types/array.html","dot":""},{"prefix":"arr.","tag":"length","suffix":"","desc":"数组的长度\n直接修改数组的length，会对数组内容进行修改，会形成“空位”\n设置length=0等同清空数组\nlength不会计算自定义key，但可通过Object.keys(arr)获取到相关key ","url":"","summary":"# 空位\n当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位\n如果最后一个元素后面有逗号，并不会产生空位。\n```javascript\nvar a = [1, 2, 3,];\na.length // 3\nvar a = [, , ,];\na.length // 3\n```\n**空位的数组的键也是undefined**","reference":"","dot":""},{"prefix":"arr.","tag":"toString()","suffix":"","desc":"转为字符串```\"v1,v2,v3\"```","url":"","summary":"","reference":"","dot":""}]},{"title":"转换","fold":false,"list":[{"prefix":"[","tag":"...","suffix":"ite]","desc":"返回值：数组\n将有Iterator接口的对象（不包括自定义类数组对象），都可以使用扩展运算符转为数组\n亦可用于快速拷贝数组","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Array.from","suffix":"(ite,[fn(val),this])","desc":"返回值：数组\n原对象：不变\n从一个类数组对象或可迭代对象中创建一个新的“浅拷贝”的数组实例\n**包括自定义的类数组对象**","url":"","summary":"mapFn 可选\n如果指定了该参数，新数组中的每个元素会执行该回调函数。\nthisArg 可选\n可选参数，执行回调函数 mapFn 时 this 对象。","reference":"","dot":""}]},{"title":"拼割","fold":false,"list":[{"prefix":"arr.","tag":"concat","suffix":"(val|arr,..)","desc":"参数：串联一个新的数组元素或数组内的元素（当串联的是一个新数组时，只取数组里的值）。\n返回值：一个新的数组\n原数组：不变\n如果数组成员包括对象，concat方法返回当前数组的一个**浅拷贝**。\n所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。","url":"","summary":"","reference":"","dot":""},{"prefix":"arr.","tag":"slice","suffix":"[start,end)","desc":"参数：起始位置，末尾位置（不包含）\n返回值：被截取得到的新数组\n原数组：不变\n当无参数时相当于一个浅拷贝的新数组（由于数组是引用对象，通过赋值方式只会传递引用地址）","url":"","summary":"当只有1个参数时，则为起始位置到末尾全部，且包含末尾元素（即m=arr.length）。\nn和m可为负值，-1 指最后一个元素，-2 指倒数第二个元素。","reference":"","dot":""},{"prefix":"arr.","tag":"flat","suffix":"([n])","desc":"参数：默认为1，可指定拉平层数或Infinity\n返回值：新的低一维数组\n原数组：不变\n“拉平”多层的嵌套数组，会跳过空位","url":"","summary":"","reference":"","dot":""},{"prefix":"arr.","tag":"flatMap","suffix":"(fn(val,[i,arr]),[this])","desc":"参数：可以生成一个新数组中的元素的函数，[回调函数this]\n返回值：新的数组\n回调返回值：[新值]\n原数组：不变\n\n----------\n\n返回一个1项元素数组以保留该项\n返回一个多元素数组以添加项\n返回一个0项元素数组以删除该项\n返回一个升维数组以提升数维","url":"","summary":"","reference":"","dot":""}]},{"title":"增加","fold":false,"list":[{"prefix":"arr.","tag":"push","suffix":"(val,..)","desc":"参数：在数组末端添加若干个元素\n返回值：数组的新长度\n原数组：改变","url":"","summary":"该方法和 call() 或 apply() 一起使用时，可应用在类似数组的对象上，但不适用于字符串，因为字符串是不可改变的。","reference":"","dot":""},{"prefix":"arr.","tag":"unshift","suffix":"(val,..)","desc":"参数：在数组最前方添加若干个元素\n返回值：数组的新长度\n原数组：改变","url":"","summary":"","reference":"","dot":""},{"prefix":"arr.","tag":"splice","suffix":"(i,0,val...)","desc":"参数：在数组指定的i索引位置添加若干个元素\n返回值：空数组\n原数组：改变","url":"","summary":"","reference":"","dot":""}]},{"title":"删除","fold":false,"list":[{"prefix":"arr.","tag":"pop()","suffix":"","desc":"参数：移除数组的最后一个元素，无参数\n返回值：被删除的元素\n原数组：改变","url":"","summary":"对空数组使用pop方法，不会报错，而是返回undefined。","reference":"","dot":""},{"prefix":"arr.","tag":"shift()","suffix":"","desc":"参数：移除数组的第一个元素，无参数\n返回值：被删除的元素\n原数组：改变","url":"","summary":"","reference":"","dot":""},{"prefix":"arr.","tag":"splice","suffix":"(i,[delnum])","desc":"参数：在数组指定的i索引位置删除指定个数\n返回值：被删除的元素组成的数组。\n原数组：改变。\ndelnum=空：如第2个参数缺省，则删除从索引位置起到数组末尾的全部元素\ndelnum=1：如第2个参数存在，且=1，则相当于删除索引位置的元素\ndelnum=n：如第2个参数存在，且>1，删除arr[i]~arr[i+n-1]的元素","url":"","summary":"","reference":"","dot":""}]},{"title":"修改","fold":false,"list":[{"prefix":"arr.","tag":"splice","suffix":"(i,[delnum],val..)","desc":"修改数组片段\n参数：在数组指定的i索引位置删除和添加若干个元素（用新的替换旧的）\n返回值：被删除的元素组成的数组\n原数组：改变\ndelnum=空：如第2个参数缺省，则删除从索引位置起到数组末尾的全部元素。\ndelnum=1：如第2个参数存在，且=1，则相当于删除索引位置的元素。\ndelnum=n：如第2个参数存在，且>1，删除arr[i]~arr[i+n-1]的元素。","url":"","summary":"","reference":"","dot":""},{"prefix":"arr.","tag":"copyWithin","suffix":"(i,[start,end))","desc":"替换数组片段\n参数：复制（索引n ~ 索引m-1）的元素，替换（索引i ~ 索引i+m-n-1）的元素。\n返回值：替换后数组\n原数组：改变\n","url":"","summary":"复制选取的部分包含start，但不包含end。如果m不定义，即到数组末端。\ni 为基底的索引，复制序列到该位置。\n如果 start 被忽略，copyWithin 将会从0开始复制。 \n如果 end 被忽略，copyWithin 将会复制到 arr.length。\n如果各个是负数，将从末尾开始计算","reference":"","dot":""},{"prefix":"arr.","tag":"fill","suffix":"(val,[start,end))","desc":"参数：用一个固定值替换数组的元素，如使用对象时为浅拷贝\n返回值：修改后的数组\n原数组：改变","url":"","summary":"","reference":"","dot":""}]},{"title":"查找","fold":false,"list":[{"prefix":"arr.","tag":"includes","suffix":"(val,[i])","desc":"返回值：true/false\n参数：从i索引处开始查找val,默认为 0\n如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。\n当指定了i的时候升序查找到末端不会再从头查找","url":"","summary":"","reference":"","dot":""},{"prefix":"arr.","tag":"indexOf","suffix":"(val,[i])","desc":"参数：正向查找指定值,i为起始索引\n返回值：第一个出现的索引位置；如查找不到则返回-1\n默认起始索引为0，如为-2则从倒数第二个元素开始查找\n该方法执行严格相等判断，不能用来搜索NaN的位置，NaN是唯一一个不等于自身的值。","url":"","summary":"","reference":"","dot":""},{"prefix":"arr.","tag":"lastIndexOf","suffix":"(val,[i])","desc":"参数：逆向查找指定值,i为起始索引\n返回值：第一个出现的索引位置；如查找不到则返回-1\n默认起始索引为arr.length - 1，从数组末尾往前开始查找\n该方法执行严格相等判断","url":"","summary":"","reference":"","dot":""},{"prefix":"arr.","tag":"find","suffix":"(fn(val,[i,arr]),[this])","desc":"查找数组中满足提供的测试函数的第一个元素的值\n返回：第一个满足的值 | undefined\n回调返回：true\n可通过函数去指定判断NaN","url":"","summary":"","reference":"","dot":""},{"prefix":"arr.","tag":"findIndex","suffix":"(fn(val,[i,arr]),[this])","desc":"查找数组中满足提供的测试函数的第一个元素的索引\n返回：第一个满足的值的索引 | -1\n回调返回：true","url":"","summary":"","reference":"","dot":""}]},{"title":"排序","fold":false,"list":[{"prefix":"arr.","tag":"sort","suffix":"([fn(a,b)])","desc":"对数组进行排序\n参数：空（如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序） | 指定按某种顺序进行排列的函数 \n返回：改变后的数组\n原对象：改变\n如果数组包含undefined元素，它们会被排到数组的尾部。","url":"","summary":"sort()方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以101排在11的前面。\n\n如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：\n如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；\n如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；\n如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。\ncompareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。","reference":"","dot":""},{"prefix":"arr.","tag":"reverse()","suffix":"","desc":"反转当前数组排序\n参数：无\n返回：改变后的数组\n原对象：改变","url":"","summary":"不可用于数组，因为数组不可变，此方法会改变原对象","reference":"","dot":""}]},{"title":"遍历","fold":false,"list":[{"prefix":"","tag":"for ","suffix":"(i in arr)","desc":"for...in不仅会遍历数组所有的数字键，还会遍历非数字键","url":"","summary":"```javascript\nvar a = [1, 2, 3];\na.foo = true;\n\nfor (var key in a) {\n  console.log(key);\n}\n```","reference":"","dot":""},{"prefix":"","tag":"for ","suffix":"(val of arr)","desc":"通过iterator接口遍历数组的值\n数组默认的[Symbol.iterator]是values()函数返回的遍历器","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"for ","suffix":"([i,v] of arr.entries())","desc":"快速遍历数组键值，数组entries方法返回一个[i,v]数组","url":"","summary":"","reference":"","dot":""},{"prefix":"arr.","tag":"forEach","suffix":"(fn(val,[i,arr]),[this])","desc":"对数组的每个元素执行一次提供的函数 \n返回值：无 \n原数组：不变\n回调返回：无 \n**必定会每个均遍历一次，无法中断** ","url":"","summary":"如果数组在迭代时被修改了，则其他元素会被跳过\n如果使用箭头函数表达式传入函数参数，thisArg 参数会被忽略，因为箭头函数在词法上绑定了this值。 \n会跳过空位\nIE9+","reference":"","dot":""},{"prefix":"arr.","tag":"map","suffix":"(fn(val,[i,arr]),[this])","desc":"创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果\n返回值：新数组\n原数组：不变\n回调返回：新值","url":"","summary":"map方法还可以接受第二个参数，用来绑定回调函数内部的this变量\n如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位\nIE9+\n\nES5跳过空位执行函数，但会保留该值","reference":"","dot":""}]},{"title":"遍历扩展","fold":false,"list":[{"prefix":"arr.","tag":"filter","suffix":"(fn(val,[i,arr]),[this])","desc":"创建一个过滤后的新数组\n返回值：新数组 \n原数组：不变\n回调返回：true/false","url":"","summary":"IE9+","reference":"","dot":""},{"prefix":"arr.","tag":"some","suffix":"(fn(val,[i,arr]),[this])","desc":"是否有满足条件的元素\n返回值：true/false\n原数组：不变\n回调返回：true/false\n对于空数组，some方法返回false，回调函数不会执行","url":"","summary":"","reference":"","dot":""},{"prefix":"arr.","tag":"every","suffix":"(fn(val,[i,arr]),[this])","desc":"是否所有元素全部满足条件\n返回值：true/false\n原数组：不变\n回调返回：true/false\n对于空数组，every方法返回true，回调函数不会执行","url":"","summary":"","reference":"","dot":""},{"prefix":"arr.","tag":"reduce","suffix":"(fn(acc,val,[i,arr]),init)","desc":"将数组中的元素通过回调函数累计处理\n返回值：最终累计处理结果\n原数组：不变\n回调返回：累计变量与当前变量的相对处理结果\n\n回调函数参数：\n+ 累积变量，默认为数组的第一个成员\n+ 当前变量，默认为数组的第二个成员\n+ 当前位置（从1开始），可选， 如果提供了初始值索引从0起始\n+ 原数组，可选\n\n第二参数：\n+ 初始值，可选","url":"","summary":"利用递归函数链式操作\n```\nvar pipe = (function () {\n  return function (value) {\n    var funcStack = [];\n    var oproxy = new Proxy({} , {\n      get : function (pipeObject, fnName) {\n        if (fnName === 'get') {\n          return funcStack.reduce(function (val, fn) {\n            return fn(val);\n          },value);\n        }\n        funcStack.push(window[fnName]);\n        return oproxy;\n      }\n    });\n\n    return oproxy;\n  }\n}());\n\nvar double = n => n * 2;\nvar pow    = n => n * n;\nvar reverseInt = n => n.toString().split(\"\").reverse().join(\"\") | 0;\n\npipe(3).double.pow.reverseInt.get; // 63\n```","reference":"","dot":""},{"prefix":"arr.","tag":"reduceRight","suffix":"(fn(acc,val,[i,arr]),init)","desc":"从右到左（从最后一个成员到第一个成员）","url":"","summary":"","reference":"","dot":""}]}]},{"title":"类数组对象","barcolor":"","fold":false,"box":[{"title":"类数组对象","fold":false,"list":[{"prefix":"arrayLike.","tag":"length","suffix":"","desc":"有“length”属性的对象，为类数组对象。例如：\n+ 字符串\n+ 函数的arguments对象\n+ 大多数 DOM 元素集\n+ 以及自定义类数组对象（含义length属性，[键名为正整数或0]）\n以i:v结构的为“标准”类数组对象。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Array.prototype.slice.call","suffix":"(arrayLike)","desc":"将“类似数组的对象”变成真正的数组\n根据length自动补充空位\n同Array.from，可用于自定义类数组对象","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Array.prototype.$fn.call","suffix":"(arrayLike,args);","desc":"将数组方法用于类数组对象，args用于传递原函数参数\n例如：\n```javascript\nArray.prototype.forEach.call(arrayLike, fn);\nArray.prototype.pop.call(arrayLike, i);\n```","url":"","summary":"","reference":"","dot":""}]}]},{"title":"集合","barcolor":"","fold":false,"box":[{"title":"基本","fold":false,"list":[{"prefix":"set.","tag":"size","suffix":"","desc":"成员总数","url":"","summary":"```javascript\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// 差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n```","reference":"","dot":""},{"prefix":"set.","tag":"values()","suffix":"","desc":"返回键名的遍历器\nSet的遍历顺序就是插入顺序。\nSet 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法\n//python取的key","url":"","summary":"Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。\n\n由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。\n\nentries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等","reference":"","dot":""},{"prefix":"set.","tag":"forEach","suffix":"(fn(val,[val,arr]),[this])","desc":"对每个成员执行某种操作，没有返回值。","url":"","summary":"","reference":"","dot":""}]},{"title":"操作","fold":false,"list":[{"prefix":"set.","tag":"add","suffix":"(val)","desc":"添加某个值\n返回值：Set结构本身","url":"","summary":"","reference":"","dot":""},{"prefix":"set.","tag":"delete","suffix":"(val)","desc":"删除某个值\n返回值：一个布尔值，表示删除是否成功。","url":"","summary":"","reference":"","dot":""},{"prefix":"set.","tag":"has","suffix":"(val)","desc":"该值是否为Set的成员\n返回值：布尔值","url":"","summary":"","reference":"","dot":""},{"prefix":"set.","tag":"clear()","suffix":"","desc":"清除所有成员\n返回值：无","url":"","summary":"","reference":"","dot":""}]}]},{"title":"ArrayBuffer","barcolor":"","fold":false,"box":[{"title":"基本","fold":false,"list":[{"prefix":"","tag":"new ArrayBuffer","suffix":"(len)","desc":"参数：需要的内存大小（单位字节）\n返回值：一个指定大小的 ArrayBuffer 对象，其内容被初始化为 0。\n","url":"","summary":"ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。","reference":"","dot":""},{"prefix":"buffer.","tag":"byteLength","suffix":"","desc":"所分配的内存区域的字节长度，只读\n如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存），所以有必要检查是否分配成功。","url":"","summary":"","reference":"","dot":""},{"prefix":"buffer.","tag":"slice","suffix":"[start,end)","desc":"允许将内存区域的一部分，拷贝生成一个新的ArrayBuffer对象。\n第一个参数表示拷贝开始的字节序号（含该字节），第二个参数表示拷贝截止的字节序号（不含该字节）。","url":"","summary":"","reference":"","dot":""},{"prefix":"v.","tag":"buffer","suffix":"","desc":"视图本身不储存数据，它的数据都储存在底层的ArrayBuffer对象之中，要获取底层对象必须使用buffer属性。","url":"","summary":"","reference":"","dot":""}]},{"title":"TypedArray","fold":false,"list":[{"prefix":"","tag":"new typedArray","suffix":"(buffer|arr|..)","desc":"new TypedArray();\nnew TypedArray(length); \nnew TypedArray(buffer [, byteOffset [, length]]);  \nnew TypedArray(arr); \nnew TypedArray(typedArray); \nnew TypedArray(object); \n\n\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>字节长度</th>\n<th>含义</th>\n<th>对应的 C 语言类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Int8</td>\n<td>1</td>\n<td>8 位带符号整数</td>\n<td>signed char</td>\n</tr>\n<tr>\n<td>Uint8</td>\n<td>1</td>\n<td>8 位不带符号整数</td>\n<td>unsigned char</td>\n</tr>\n<tr>\n<td>Uint8C</td>\n<td>1</td>\n<td>8 位不带符号整数（自动过滤溢出）</td>\n<td>unsigned char</td>\n</tr>\n<tr>\n<td>Int16</td>\n<td>2</td>\n<td>16 位带符号整数</td>\n<td>short</td>\n</tr>\n<tr>\n<td>Uint16</td>\n<td>2</td>\n<td>16 位不带符号整数</td>\n<td>unsigned short</td>\n</tr>\n<tr>\n<td>Int32</td>\n<td>4</td>\n<td>32 位带符号整数</td>\n<td>int</td>\n</tr>\n<tr>\n<td>Uint32</td>\n<td>4</td>\n<td>32 位不带符号的整数</td>\n<td>unsigned int</td>\n</tr>\n<tr>\n<td>Float32</td>\n<td>4</td>\n<td>32 位浮点数</td>\n<td>float</td>\n</tr>\n<tr>\n<td>Float64</td>\n<td>8</td>\n<td>64 位浮点数</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n","url":"","summary":"","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray","dot":""},{"prefix":"tparr.","tag":"$fn|prop","suffix":"","desc":"所有数组的方法，在它们上面都能使用\n但TypedArray 数组没有concat方法","url":"","summary":"TypedArray 数组的所有成员，都是同一种类型。\nTypedArray 数组的成员是连续的，不会有空位。\nTypedArray 数组成员的默认值为 0。","reference":"","dot":""}]},{"title":"DataView","fold":false,"list":[{"prefix":"","tag":"new DataView","suffix":"(buffer,[start,end)","desc":"创建DataView视图","url":"","summary":"","reference":"","dot":""},{"prefix":"dv.","tag":"getType","suffix":"(i,[true])","desc":"从第i个字节开始读取N个字节，返回对应类型\n\ngetInt8：读取 1 个字节，返回一个 8 位整数。\ngetUint8：读取 1 个字节，返回一个无符号的 8 位整数。\ngetInt16：读取 2 个字节，返回一个 16 位整数。\ngetUint16：读取 2 个字节，返回一个无符号的 16 位整数。\ngetInt32：读取 4 个字节，返回一个 32 位整数。\ngetUint32：读取 4 个字节，返回一个无符号的 32 位整数。\ngetFloat32：读取 4 个字节，返回一个 32 位浮点数。\ngetFloat64：读取 8 个字节，返回一个 64 位浮点数。\n\n默认情况下，DataView的get方法使用大端字节序解读数据，如果需要使用小端字节序解读，必须在get方法的第二个参数指定true。","url":"","summary":"","reference":"","dot":""},{"prefix":"dv.","tag":"setType","suffix":"(i,val,[true])","desc":"在第i个字节，默认以大端字节序写入值为val的type类型数据\nsetInt8：写入 1 个字节的 8 位整数。\nsetUint8：写入 1 个字节的 8 位无符号整数。\nsetInt16：写入 2 个字节的 16 位整数。\nsetUint16：写入 2 个字节的 16 位无符号整数。\nsetInt32：写入 4 个字节的 32 位整数。\nsetUint32：写入 4 个字节的 32 位无符号整数。\nsetFloat32：写入 4 个字节的 32 位浮点数。\nsetFloat64：写入 8 个字节的 64 位浮点数。","url":"","summary":"","reference":"","dot":""}]},{"title":"Atomics","fold":false,"list":[{"prefix":"","tag":"SharedArrayBuffer","suffix":"","desc":"","url":"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Atomics","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"映射","barcolor":"","fold":false,"box":[{"title":"基本","fold":false,"list":[{"prefix":"map.","tag":"get","suffix":"(key)","desc":"获取key的值\n返回值：val 或 undefined","url":"","summary":"","reference":"","dot":""},{"prefix":"map.","tag":"size","suffix":"","desc":"Map 结构的成员总数","url":"","summary":"","reference":"","dot":""}]},{"title":"操作","fold":false,"list":[{"prefix":"map.","tag":"set","suffix":"(key,val)","desc":"设置键名key对应的键值为value\n返回值：整个 Map 结构\n可以采用链式写法","url":"","summary":"","reference":"","dot":""},{"prefix":"map.","tag":"delete","suffix":"(key)","desc":"删除指定键\n返回值：布尔值","url":"","summary":"","reference":"","dot":""},{"prefix":"map.","tag":"has","suffix":"(key)","desc":"某个键是否在当前 Map 对象之中\n返回值：布尔值","url":"","summary":"","reference":"","dot":""},{"prefix":"map.","tag":"clear()","suffix":"","desc":"清除所有成员\n返回值：无","url":"","summary":"","reference":"","dot":""}]},{"title":"遍历","fold":false,"list":[{"prefix":"map.","tag":"keys()","suffix":"","desc":"返回键名的遍历器","url":"","summary":"","reference":"","dot":""},{"prefix":"map.","tag":"values()","suffix":"","desc":"返回键值的遍历器","url":"","summary":"","reference":"","dot":""},{"prefix":"map.","tag":"entries()","suffix":"","desc":"返回所有成员的遍历器\nMap 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。","url":"","summary":"```javascript\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n// 或者\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n````","reference":"","dot":""},{"prefix":"map.","tag":"forEach","suffix":"(fn(val,key,[map]),[this])","desc":"","url":"","summary":"","reference":"","dot":""}]}]},{"title":"对象","barcolor":"","fold":false,"box":[{"title":"基本","fold":false,"list":[{"prefix":"obj","tag":".","suffix":"key","desc":"同 `obj['key']`，但当key为变量时只能使用[]\n如果读取一个不存在的键，会返回undefined，而不是报错。\n**不能对一个未声明的对象直接指定属性，这样会报错**","url":"","summary":"","reference":"","dot":""},{"prefix":"obj","tag":"?.","suffix":"key","desc":"链判断运算符，同 `obj?.[expr]`\n在链式调用的时候判断，左侧的对象是否为null或undefined。\n如果是的，就不再往下运算，而是返回undefined。\n`const firstName = message?.body?.user?.firstName || 'default';`","url":"","summary":"","reference":"","dot":"#ff0000"},{"prefix":"","tag":"_.get","suffix":"(obj,path)","desc":"根据 object对象的path路径获取值。 如果解析 value 是 undefined 会以 defaultValue 取代。\n`_.set(object, path, value` 设置 object对象中对应 path 属性路径上的值，如果path不存在，则创建。 \n`_.unset(object, path)` 移除object对象 path 路径上的属性。\n`_.at(object, [paths])` 创建一个数组，值来自 object 的paths路径相应的值。\n`_.invoke(object, path, [args])` 调用object对象path上的方法","url":"","summary":"","reference":"参考资料|https://www.lodashjs.com/docs/latest#_getobject-path-defaultvalue","dot":""}]},{"title":"属性","fold":false,"list":[{"prefix":"","tag":"for ","suffix":"(key in obj)","desc":"遍历对象属性\n范围：\n☑**可枚举** ☒不可枚举\n☑**自身** ☑**继承**\n☒Symbol","url":"","summary":"通过for in遍历进行拷贝时，如果遇到存取器定义的属性，会只拷贝值。\n可以通过Object.defineProperty方法来拷贝属性。（但不会再包含继承的）\n```javascript\nar extend = function (to, from) {\n  for (var property in from) {\n    if (!from.hasOwnProperty(property)) continue;\n    Object.defineProperty(\n      to,\n      property,\n      Object.getOwnPropertyDescriptor(from, property)\n    );\n  }\n\n  return to;\n}\n\nextend({}, { get a(){ return 1 } })\n```","reference":"","dot":""},{"prefix":"","tag":"Object.keys","suffix":"(obj)","desc":"返回值：属性数组\n范围：\n☑**可枚举** ☒不可枚举\n☑**自身** ☒继承 \n☒Symbol","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Object.getOwnPropertyNames","suffix":"(obj)","desc":"返回值：属性数组\n范围：\n☑**可枚举** ☑**不可枚举** \n☑**自身** ☒继承 \n☒Symbol","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Object.getOwnPropertySymbols","suffix":"(obj)","desc":"返回值：Symbol属性数组\n范围：\n☒可枚举 ☒不可枚举\n☒自身 ☒继承 \n☑**Symbol**","url":"","summary":"Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。\n\n由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。","reference":"","dot":""},{"prefix":"","tag":"Reflect.ownKeys","suffix":"(obj)","desc":"返回值：全部属性数组\n范围：\n☑**可枚举** ☑**不可枚举**\n☑**自身** ☑**继承**\n☑**Symbol**\n\n-----\n\n首先遍历所有数值键，按照数值升序排列。\n其次遍历所有字符串键，按照加入时间升序排列。\n最后遍历所有 Symbol 键，按照加入时间升序排列。","url":"","summary":"","reference":"","dot":""}]},{"title":"值","fold":false,"list":[{"prefix":"","tag":"Object.values","suffix":"(obj)","desc":"返回值：值数组 \n范围：\n☑**可枚举** ☒不可枚举\n☑**自身** ☒继承 \n☒Symbol","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"_.isEmpty","suffix":"(val)","desc":"检查 value 是否为一个空对象，集合，映射或者set。 判断的依据是除非是有枚举属性的对象，length 大于 0 的 arguments object, array, string 或类jquery选择器。","url":"","summary":"","reference":"","dot":""}]},{"title":"转换","fold":false,"list":[{"prefix":"","tag":"Object.entries","suffix":"(obj)","desc":"返回值：键值对二维数组 ```[[key,val],..]```\nobj转为map ```new Map(Object.entries(obj))```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Object.fromEntries","suffix":"(ite)","desc":"把键值对二维数组列表转换为一个对象\nmap转obj ```Object.fromEntries(map)```\n当map key为非字符串时会自动执行toString","url":"","summary":"","reference":"","dot":""}]},{"title":"拷贝","fold":false,"list":[{"prefix":"","tag":"{...obj}","suffix":"","desc":"对象的扩展运算符（...），可用于拷贝或解构赋值\n范围：\n☑**可枚举** ☒不可枚举\n☑**自身** ☒继承 \n☑**Symbol**\n","url":"","summary":"由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。\n```\nlet foo = { ...['a', 'b', 'c'] };\nfoo\n// {0: \"a\", 1: \"b\", 2: \"c\"}\n```","reference":"参考资料|https://es6.ruanyifeng.com/#docs/object","dot":""},{"prefix":"","tag":"Object.assign","suffix":"({},obj)","desc":"浅拷贝一个对象实例属性\n范围：\n☑**可枚举** ☒不可枚举\n☑**自身** ☒继承 \n☑**Symbol**","url":"","summary":"Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。\nObject.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。","reference":"","dot":""},{"prefix":"","tag":" Object.create","suffix":"(proto,props)","desc":"完全拷贝对象\n+ 确保拷贝后的对象，与原对象具有同样的原型。\n+ 确保拷贝后的对象，与原对象具有同样的实例属性。\n\n范围：\n☑**可枚举** ☑**不可枚举**\n☑**自身** ☑**继承**\n☑**Symbol**\n```\nfunction copyObject(orig) {\n  return Object.create(\n    Object.getPrototypeOf(orig), //原型\n    Object.getOwnPropertyDescriptors(orig) //自身\n  );\n}\n```","url":"","summary":"","reference":"MDN|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create","dot":""},{"prefix":"","tag":"_.cloneDeep","suffix":"(val)","desc":"递归拷贝（深拷贝）value。","url":"","summary":"简易序列化 \n`var o = JSON.parse( JSON.stringify(o) );`\n\n分类型讨论，可存储在weakset|weakmap中\n1.当typeof!=object，基本类型使用valueOf赋值拷贝\n2.当为其他引用类型(map,set,regexp,date)时，instanceof测试，使用构造方法重新构造\n3.当为array时，for in递归拷贝\n4.当为object时，使用原型+自身属性描述对象递归拷贝\n```\nObject.create(\n    Object.getPrototypeOf(orig), //原型\n    Object.getOwnPropertyDescriptors(orig) //自身\n  );\n```\n5.对象环引用自身处理\n6.symbol类型reflect","reference":"参考资料|https://www.jianshu.com/p/b08bc61714c7","dot":""}]},{"title":"合并","fold":false,"list":[{"prefix":"","tag":"{...o1, ...o2}","suffix":"","desc":"扩展运算符可以用于合并两个对象。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Object.assign","suffix":"(obj,o1,o2..)","desc":"将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。\n字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。\nundefined和null不在首参数，就不会报错，否则报错。\n注意: 这方法会改变 object","url":"","summary":"","reference":"参考资料|https://es6.ruanyifeng.com/#docs/object-methods","dot":""},{"prefix":"","tag":"_.merge","suffix":"(obj,o1,..)","desc":"递归合并 sources 来源对象自身和继承的可枚举属性到 object 目标对象。\n如果目标值存在，被解析为undefined的sources 来源对象属性将被跳过。\n这方法会改变对象 object.","url":"","summary":"","reference":"","dot":""}]},{"title":"比较","fold":false,"list":[{"prefix":"","tag":"Object.is","suffix":"(o1,o2)","desc":"判断2个对象引用地址是否一致\n与严格相等类似，但+0不等于-0，NaN等于自身","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"_.isEqual","suffix":"(v1,v2)","desc":"执行深比较来确定两者的值是否相等。\n\n**注意: **这个方法支持比较 arrays, array buffers, booleans, date objects, error objects, maps, numbers, Object objects, regexes, sets, strings, symbols, 以及 typed arrays. Object 对象值比较自身的属性，不包括继承的和可枚举的属性。 不支持函数和DOM节点比较。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"JSON","barcolor":"","fold":false,"box":[{"title":"基本","fold":false,"list":[{"prefix":"","tag":"JSON.stringify","suffix":"(val,[fn|arr])","desc":"将一个值转为 JSON 字符串\n**忽略对象的不可枚举的属性**","url":"","summary":"# 参数1：传入的对象。\n如果对象的键值undefined、函数或 XML 对象，该属性会被过滤。\n如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。\n正则对象会被转成空对象，可设置`RegExp.prototype.toJSON = RegExp.prototype.toString`\n日期对象会转为字符串。\n  \n# 参数2：用于转换结果的函数或数组\n*fn(key,val)*\n+ 如果该参数是一个函数，被序列化的值的每个属性都会经过该函数的转换和处理，返回一个处理结果；\n+ 如果处理函数返回undefined或没有返回值，则该属性会被忽略。\n+ 递归处理所有的键；\n\n*[key1,key2..]*\n如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；\n类似白名单的数组，只对对象的属性有效，对数组无效。\n  \n# 参数3：缩进空格\n指定缩进用的空白字符串，用于美化输出；\n如果参数是个数字，它代表有多少的空格，上限为10。\n如果该参数为字符串，该字符串会添加在每行前面。","reference":"","dot":""},{"prefix":"","tag":"JSON.parse","suffix":"(json,[fn])","desc":"将 JSON 字符串转换成对应的值\n1.对非标准格式都会报错，总是需要做异常处理\n2.对空字符串记得做特殊处理\n对内部传入的字符串，需要做转义处理，`'a'=>'\\\"a\\\"'`","url":"","summary":"使用函数fn(key,val)时，会递归从最内层开始执行","reference":"参考资料|https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse","dot":""},{"prefix":"obj.","tag":"toJSON","suffix":"","desc":"如果参数对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。","url":"","summary":"JSON是一种表示结构化数据的形式，JSON是一个格式化的字符串\n字符串：对于原始类型的字符串，转换结果会带双引号\n数字：限十进制数值，不包括NaN和Infinity\n布尔值：布尔值\nnull：空，但不支持undefined\n对象：一组无序的键值对（键名必须放在双引号里面）\n数组：一组有序的值的列表\n数组或对象最后一个成员的后面，不能加逗号","reference":"","dot":""}]}]}]},{"column":[{"title":"函数","barcolor":"","fold":false,"box":[{"title":"基本","fold":false,"list":[{"prefix":"","tag":"function ","suffix":"name(arg){}","desc":"函数声明\n1.使用函数声明时，会提升优先级（一等公民），不包括函数表达式。\n2.如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。\n3.ES6中块级作用域中声明的函数，在块级作用域之外不可引用","url":"","summary":"","reference":"","dot":""},{"prefix":"handler = ","tag":"function ","suffix":"[name](arg){}","desc":"函数表达式\n1.函数表达式是一个匿名函数\n2.当定义name时，此时可以用name在函数内部指代函数本身，但在函数体外部无效\n3.函数表达式，不会被提升。\n4.如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。\n5.函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。 ","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/types/function.html","dot":""},{"prefix":"(args)","tag":"=>","suffix":"{}","desc":"箭头函数\n没有自己的this，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象，且固定不可变，即使使用call也无法修改，更多的可在构造函数或闭包内使用，则可替代普通函数需要用that指代this。\n例：\n1.当只有一行直接返回变量的处理时，x=>x*x，返回x的平方\n2.当只有一行且无需返回值时，x=>void dosomething\n3.当有多个参数或多条语句时，需添加括号和花括号，(x,y)=>{dosomething / return xx}","url":"","summary":"1.不可以当做构造函数，即不能使用new操作符\n2.不可以使用arguments、super、new.target，均指向外层函数的对应变量\n3.不可以使用yield命令，因此箭头函数不能用作 Generator 函数\n4.没有prototype属性，也不能使用yield关键字\nthis指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。所以call的绑定也是无效，但上层的普通函数的call绑定有效。","reference":"","dot":""}]},{"title":"属性","fold":false,"list":[{"prefix":"fn.","tag":"name","suffix":"","desc":"# 函数声明\nfn.name为name，可用于获取参数函数的名字\n# 函数表达式\n匿名赋值时，fn.name=handler\n具名赋值时，fn.name=name","url":"","summary":"","reference":"","dot":""},{"prefix":"fn.","tag":"length","suffix":"","desc":"fn.length 返回函数定义时的参数个数，不包括rest参数，不包括有默认值的参数。\narguments.length 返回函数调用时的参数个数。","url":"","summary":"length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）。","reference":"","dot":""},{"prefix":"fn.","tag":"toString()","suffix":"","desc":"返回一个字符串，内容是函数的源码（包括注释）\n原生的函数返回`function (){[native code]}`","url":"","summary":"","reference":"","dot":""}]},{"title":"执行","fold":false,"list":[{"prefix":"","tag":"fn","suffix":"([arg])","desc":"调用函数时，要使用圆括号运算符。\n圆括号之中，可以加入函数的参数。\nIIFE`(function(){}())` `(()=>{})()`","url":"","summary":"# 立即调用的函数表达式（IIFE）\nJavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句。否则为表达式。\nIIFE最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。\n```\n(function(){ /* code */ }());\n// 或者\n(function(){ /* code */ })();\n```","reference":"IIFE|https://wangdoc.com/javascript/types/function.html","dot":""},{"prefix":"","tag":"return ","suffix":"[exp]","desc":"返回表达式，不会执行后续代码。\n非必须，未设置时返回undefined。\n# 实践\n1.可通过调用自身形成递归。（尾调用优化）\n2.可制作链式调用。","url":"","summary":"JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。\n\n函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码。\n```javascript\nfunction fib(num) {\n  if (num === 0) return 0;\n  if (num === 1) return 1;\n  return fib(num - 2) + fib(num - 1);\n}\n\nfib(6) // 8\n```","reference":"underscore链式调用|https://github.com/mqyqingfeng/Blog/issues/57","dot":""}]},{"title":"参数","fold":false,"list":[{"prefix":"","tag":"arguments","suffix":"","desc":"函数的参数名称，相当于在函数内的局部变量名\narguments[0] 第一个参数值\n支持默认值 arg=defaultValue\n传参opt时优先使用解构","url":"","summary":"1.如果有同名的参数，则取最后出现的那个值。\n2.arguments.callee返回它所对应的原函数，严格模式禁用。\n3.参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的","reference":"","dot":""},{"prefix":"","tag":"...rest","suffix":"","desc":"rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\nrest 参数之后不能再有其他参数（即只能是最后一个参数）","url":"","summary":"","reference":"","dot":""}]},{"title":"特性","fold":true,"list":[{"prefix":"参数传递","tag":" ","suffix":"","desc":"# 传递方式\n基本类型：**传值传递**（passes by value）\n在函数内部，参数值是原始值的拷贝，无论怎么修改，都不会影响到原始值。\n\n引用类型：**传址传递**（pass by reference）\n拷贝的是指针，如修改原数据属性会改变原数据，如替换整个目标则不修改原数据，此外始终不改变原指针的指向。","url":"","summary":"","reference":"","dot":""},{"prefix":"作用域","tag":" ","suffix":"","desc":"# 作用域\n函数执行时所在的作用域，是**定义时的作用域**，而不是调用时所在的作用域。","url":"","summary":"","reference":"","dot":""},{"prefix":"闭包","tag":" ","suffix":"","desc":"# 闭包\n函数体内部声明的函数，**作用域绑定函数体内部**。\n可通过此实现静态函数效果，封装对象的私有属性和私有方法。","url":"","summary":"```javascript\nfunction createIncrementor(start) {\n  return function () {\n    return start++;\n  };\n}\n\nvar inc = createIncrementor(5);\n\ninc() // 5\ninc() // 6\ninc() // 7\n```","reference":"","dot":""}]},{"title":"this","fold":false,"list":[{"prefix":"","tag":"this","suffix":"","desc":"指代**当前运行环境的对象**，**多层this时可通过that中转**\n普通函数：严格模式(undefined)、严格模式(全局对象)\n构造函数：对象的实例\n对象方法：对象本身\ncall/apply/bind：绑定的对象\n箭头函数：函数所在的块的this","url":"","summary":"","reference":"","dot":""},{"prefix":"fn.","tag":"call","suffix":"(this,args..)","desc":"指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，*调用该函数*。\n\ncall方法的参数，应该是一个对象。\n如果参数为空、null和undefined，则默认传入全局对象。\n如果参数是一个原始值，那么这个原始值会自动转成对应的包装对象。","url":"","summary":"","reference":"","dot":""},{"prefix":"fn.","tag":"apply","suffix":"(this,argarr)","desc":"同call，但将函数参数作为数组传入\n绑定回调函数的对象","url":"","summary":"","reference":"","dot":""},{"prefix":"fn.","tag":"bind","suffix":"(this,args)","desc":"将函数体内的this绑定到某个对象，绑定参数位置，然后*返回一个新函数，并不执行*。\n回调函数可通过bind绑定指向原对象。","url":"","summary":"","reference":"","dot":""}]},{"title":"扩展","fold":false,"list":[{"prefix":"","tag":"_.after","suffix":"(n,fn)","desc":"定义函数执行若干次后才调用，可配合遍历。\n# 闭包\n存储函数内变量达到类似static效果","url":"","summary":"核心源码：\n```\nfunction after(n, func) {\n    return function() {\n        if (--n < 1) {\n            return func.apply(this, arguments);\n        }\n    }\n}\nvar test = after(2,fn)\ntest()\n```","reference":"","dot":""},{"prefix":"","tag":"_.once","suffix":"(fn)","desc":"创建一个只能调用 func 一次的函数。 重复调用返回第一次调用的结果。 func 调用时， this 绑定到创建的函数，并传入对应参数。\n# 惰性函数\n当我们每次都需要进行条件判断，其实只需要判断一次，接下来的使用方式都不会发生改变的时候，可以考虑使用惰性函数。\n```\nvar foo = function() {\n    var t = new Date();\n    foo = function() {\n        return t;\n    };\n    return foo();\n};\n```","url":"","summary":"","reference":"参考资料|https://github.com/mqyqingfeng/Blog/issues/44","dot":""},{"prefix":"","tag":"_.memoize","suffix":"(fn)","desc":"创建一个会缓存结果的函数。\n# 函数记忆\n如果需要大量重复的计算，或者大量计算又依赖于之前的结果，便可以考虑使用函数记忆。","url":"","summary":"","reference":"参考资料|https://github.com/mqyqingfeng/Blog/issues/46","dot":""},{"prefix":"","tag":"_.debounce","suffix":"(fn,delay)","desc":"在事件被触发n毫秒后再执行回调，如果在这n秒内又被触发，则重新计时。\n# 防抖 \nsearch搜索联想，用户在不断输入值时，用防抖来节约请求资源。\nwindow触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次\n","url":"","summary":"```javascript\n$('textarea').on('keydown', debounce(ajaxAction, 2500));\n\nfunction debounce(fn, delay){\n  var timer = null; // 声明计时器\n  return function() {\n    var context = this;\n    var args = arguments;\n    clearTimeout(timer);\n    timer = setTimeout(function () {\n      fn.apply(context, args);\n    }, delay);\n  };\n}\n```\n上面代码中，只要在2500毫秒之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是2500毫秒。","reference":"参考资料|https://github.com/mqyqingfeng/Blog/issues/22","dot":""},{"prefix":"","tag":"_.throttle","suffix":"(fn,delay)","desc":"规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。\n# 节流 \n鼠标不断点击触发，mousedown(单位时间内只触发一次)\n监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断","url":"","summary":"","reference":"参考资料|https://github.com/mqyqingfeng/Blog/issues/26\n节流与防抖区别|https://juejin.im/post/5b8de829f265da43623c4261","dot":""},{"prefix":"","tag":"_.curry","suffix":"(fn)","desc":"# 柯里化 \n将一个多参数的函数转换成多个单参数的函数\n","url":"","summary":"","reference":"参考资料|https://github.com/mqyqingfeng/Blog/issues/42","dot":""},{"prefix":"","tag":"_.partial","suffix":"(fn,_,arg)","desc":"# 偏函数 \n创建一个函数，传入预设的 partials 参数。 \n\n","url":"","summary":"```\nconst g = f(?, 1, ...);\n// 等同于\nconst g = (x, ...y) => f(x, 1, ...y);\n```","reference":"参考资料|https://github.com/mqyqingfeng/Blog/issues/43","dot":""},{"prefix":"","tag":"_.chain","suffix":"(val)","desc":"# 链式调用\n创建一个lodash包装实例，包装value以启用显式链模式。","url":"","summary":"```\n// 传统的写法\nexclaim(capitalize(doubleSay('hello')))\n// \"Hello, hello!\"\n\n// 管道的写法\n'hello'\n  |> doubleSay\n  |> capitalize\n  |> exclaim\n// \"Hello, hello!\"\n```","reference":"参考资料|https://github.com/mqyqingfeng/Blog/issues/57","dot":""}]}]},{"title":"Iterator","barcolor":"","fold":false,"box":[{"title":"Iterable","fold":false,"list":[{"prefix":"ite","tag":"[Symbol.iterator]","suffix":"","desc":"Symbol.iterator属性是一个函数，执行该函数返回一个iterator对象。\n\n# Iterable类型\n有Symbol.iterator属性，就可以认为是“可遍历的”（iterable），例如：\n+ String 字符串\n+ Array 数组\n+ Map 映射\n+ Set 集合\n+ TypedArray\n+ 函数的 arguments 对象\n+ NodeList 对象\n\n# 自定义部署\n+ “标准”自定义类数组对象，可直接引用数组的接口\n`NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator]`\n+ 普通对象，可通过keys/values/entries方法获取相关数组再引用数组接口\n+ 将一个生成器函数赋值给一个对象的[Symbol.iterator]属性，快速扩展iterator接口","url":"","summary":"```javascript\nconst obj = {\n  [Symbol.iterator] : function () {\n    return {\n      next: function () {\n        return {\n          value: 1,\n          done: true\n        };\n      }\n    };\n  }\n};\n```","reference":"","dot":""},{"prefix":"[","tag":"...","suffix":"ite]","desc":"具有Iterator接口的对象都可以使用扩展运算符快速转为数组\n默认的Symbol.iterator属性指向自身的某个遍历器函数\n+ 字符串 : -\n+ 数组 : values()\n+ set : values()\n+ map : entries()","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"for ","suffix":"(o of ite)","desc":"原生类型Iterator返回值：\n+ 字符串 : 字符（会正确识别 32 位 UTF-16 字符）\n+ 数组 : 元素\n+ set : 元素\n+ map : [k,v]数组\n\n可结合break,continue,return等，自由度较forEach更高","url":"","summary":"","reference":"","dot":""}]},{"title":"Iterator","fold":true,"list":[{"prefix":"itor.","tag":"next()","suffix":"","desc":"Iterator必须包含next方法，并返回一个对象\n`{value: x, done: false};`\n`{value: undefined, done: true};`","url":"","summary":"","reference":"","dot":""},{"prefix":"itor.","tag":"return()","suffix":"","desc":"当for...of循环提前退出（通常是因为出错，或者有break语句），就会调用return方法。","url":"","summary":"","reference":"","dot":""},{"prefix":"[","tag":"...","suffix":"itor]","desc":"扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"for ","suffix":"(o of itor) ","desc":"自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。","url":"","summary":"","reference":"","dot":""}]},{"title":"Generator","fold":false,"list":[{"prefix":"","tag":"yield ","suffix":"exp","desc":"表达式的返回值将作为next函数返回对象的value的值，无返回值时value为undefined\nyield本身没有返回值（总为undefined），next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n\n----------------\n\n1.yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\n2.也可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。","url":"","summary":"yield表达式如果用在另一个表达式之中，必须放在圆括号里面。\nyield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。","reference":"","dot":""},{"prefix":"","tag":"function* ","suffix":"name(arg){}","desc":"调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。\n每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。\nvalue属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；\ndone属性是一个布尔值，表示是否遍历结束。\n可以将一个生成器函数赋值给一个对象的[Symbol.iterator]属性，让其具有ite接口，而可以使用扩展运算符或被for of遍历。","url":"","summary":"Generator 函数，调用它会生成一个遍历器对象，其对象的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。\n\n如果一个对象的属性是 Generator 函数，可以简写成下面的形式。\n```javascript\nlet obj = {\n  * myGeneratorMethod() {\n    ···\n  }\n};\n```","reference":"","dot":""},{"prefix":"","tag":"yield* ","suffix":"itor","desc":"如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。使用yield* 在一个 Generator 函数里面执行另一个 Generator 函数。亦可用于有iterator接口的对象。\n`yield* gfn()`\n回直接进入gfn中对其中的yield进行求值","url":"","summary":"","reference":"","dot":""},{"prefix":"itor.","tag":"next","suffix":"(val)","desc":"将val作为上一个yield表达式的返回值（yield默认返回值总是undefined）\nyield返回值 ≠ next返回value值\n**yield返回值 => next传入参数|undefined**\n**yield后表达式的返回值 => next()返回的{value:值}**","url":"","summary":"","reference":"","dot":""},{"prefix":"itor.","tag":"throw","suffix":"(o)","desc":"1.Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。不同于throw语句。\n2.throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。\n3.throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。","url":"","summary":"","reference":"","dot":""},{"prefix":"itor.","tag":"return","suffix":"(val)","desc":"Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。\n**生成器函数中的return语句的中断结果不会被迭代所返回。**\n**而遍历器对象的return方法，为外部提前中断手动调用使用。**","url":"","summary":"如果 Generator 函数内部有try...finally代码块，且正在执行try代码块，那么return方法会导致立刻进入finally代码块，执行完以后，整个函数才会结束。","reference":"","dot":""}]}]},{"title":"异步","barcolor":"","fold":false,"box":[{"title":"基本","fold":false,"list":[{"prefix":"callback","tag":" ","suffix":"","desc":"回调函数","url":"","summary":"","reference":"参考资料|https://wangdoc.com/javascript/async/general.html\n发布订阅模式|https://yq.aliyun.com/articles/610160","dot":"","title":"定时器"}]},{"title":"Promise","fold":false,"list":[{"prefix":"","tag":"new Promise","suffix":"(fn(resolve,reject))","desc":"Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。\n+ resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n+ reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n\n调用resolve或reject并不会终结 Promise 的参数函数的执行。\n成功数据通过**resolve**传递给then。\n\n示例：\n```\nconst preloadImage = function (path) {\n  return new Promise(function (resolve, reject) {\n    const image = new Image();\n    image.onload  = resolve;\n    image.onerror = reject;\n    image.src = path;\n  });\n};\n```","url":"","summary":"# 微任务\nPromise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。\n```\nsetTimeout(function() {\n  console.log(1);\n}, 0);\n\nnew Promise(function (resolve, reject) {\n  resolve(2);\n}).then(console.log);\n\nconsole.log(3);\n// 3\n// 2\n// 1\n```\n上面代码的输出结果是321。这说明then的回调函数的执行时间，早于setTimeout(fn, 0)。因为then是本轮事件循环执行，setTimeout(fn, 0)在下一轮事件循环开始时执行。","reference":"","dot":""},{"prefix":"","tag":"resolve","suffix":"(val)","desc":"可将一个Promise作为作为另一个Promise的resolve参数。\n此时p1的状态决定了p2的状态。\n且此时后面的then语句都变成针对p1。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"reject","suffix":"(err)","desc":"Promise 对象的报错具有传递性。","url":"","summary":"","reference":"","dot":""},{"prefix":"pro.","tag":"then","suffix":"(fn(val))","desc":"then方法返回的是一个新的Promise实例\n第二个异步操作成功时（变为fulfilled状态）的回调函数\n第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。\n一旦状态改变，就调用相应的回调函数。\n# 链式调用\nthen方法可以链式使用。\n只要前一步的状态变为fulfilled，就会依次执行紧跟在后面的回调函数。\n*只要前一步的状态变为rejected，后面都不会执行。*\n成功数据通过**return**传递给then。","url":"","summary":"","reference":"","dot":""},{"prefix":"pro.","tag":"catch","suffix":"(fn(err))","desc":"跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。","url":"","summary":"","reference":"","dot":""},{"prefix":"pro.","tag":"finally","suffix":"(fn)","desc":"不管 Promise 对象最后状态如何，都会执行的操作","url":"","summary":"","reference":"","dot":""}]},{"title":"Promises","fold":false,"list":[{"prefix":"","tag":"Promise.all","suffix":"(pros)","desc":"将多个 Promise 实例，包装成一个新的 Promise 实例\n用途：所有promise状态都成功执行\n传递：[各个promise的resolve值数组]\n`let [foo, bar] = await Promise.all([getFoo(), getBar()]);`","url":"","summary":"Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。","reference":"","dot":""},{"prefix":"","tag":"Promise.allSettled","suffix":"(pros)","desc":"等到所有这些参数实例都返回结果\n用途：全部执行完毕，不管是成功或失败\n传递：[promise实例状态结果数组]","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Promise.race","suffix":"(pros)","desc":"有一个状态改变则新的Promise状态立即改变\n用途：可用于超时处理场景\n传递：第一个成功的返回值","url":"","summary":"```\nconst p = Promise.race([\n  fetch('/resource-that-may-take-a-while'),\n  new Promise(function (resolve, reject) {\n    setTimeout(() => reject(new Error('request timeout')), 5000)\n  })\n]);\n\np\n.then(console.log)\n.catch(console.error);\n```","reference":"","dot":""},{"prefix":"","tag":"Promise.any","suffix":"(pros)","desc":"不会因为某个 Promise 变成rejected状态而结束。\n场景：只要有一个成功则返回成功\n如果所有三个操作都变成rejected，抛出一个错误数组，每个成员对应一个被rejected的操作所抛出的错误。","url":"","summary":"","reference":"","dot":"#999"}]},{"title":"其它","fold":true,"list":[{"prefix":"","tag":"Promise.resolve","suffix":"(val)","desc":"将现有对象转为 Promise 对象\n立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。","url":"","summary":"","reference":"参考资料|https://es6.ruanyifeng.com/#docs/promise#Promise-resolve","dot":""},{"prefix":"","tag":"Promise.reject","suffix":"(val)","desc":"返回一个新的 Promise 实例，该实例的状态为rejected。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Promise.try","suffix":"(fn)","desc":"如果是同步则当做同步函数处理\n如果是异步则当做异步处理","url":"","summary":"","reference":"","dot":"#999"}]},{"title":"Async","fold":false,"list":[{"prefix":"","tag":"async function ","suffix":"name(arg){}","desc":"返回：一个 Promise 对象，可以使用then方法添加回调函数。\nasync函数内部**return**语句返回的值，会成为then方法回调函数的参数。\nasync函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"await ","suffix":"exp","desc":"返回：对异步操作求值\n当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。\n# 错误处理\n有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个await放在try...catch结构里面，这样不管这个异步操作是否成功，第二个await都会执行。\n# 并行触发\n多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\n提前设置触发，触发完成后再进行await求值","url":"","summary":"","reference":"","dot":""},{"prefix":"sleep","tag":" ","suffix":"","desc":"async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。\nJavaScript 一直没有休眠的语法，但是借助await命令就可以让程序停顿指定的时间。","url":"","summary":"```javascript\nfunction sleep(interval) {\n  return new Promise(resolve => {\n    setTimeout(resolve, interval);\n  })\n}\n\n// 用法\nasync function one2FiveInAsync() {\n  for(let i = 1; i <= 5; i++) {\n    console.log(i);\n    await sleep(1000);\n  }\n}\n\none2FiveInAsync();\n```","reference":"","dot":""}]}]},{"title":"定时器","barcolor":"","fold":false,"box":[{"title":"延迟与间隔","fold":false,"list":[{"prefix":"","tag":"setTimeout","suffix":"(fn,delay)","desc":"延迟delay毫秒后执行fn。返回定时器ID。\n更多的参数将依次传入推迟执行的函数（回调函数）。\n一般浏览器是每秒60帧，即显示频率是16.7ms，这也是为何setTimeout的定时器值推荐最小使用16.7ms的原因（16.7 = 1000 / 60, 即每秒60帧）。","url":"","summary":"如果回调函数是对象的方法，那么setTimeout使得方法内部的this关键字指向全局环境，而不是定义时所在的那个对象。","reference":"参考资料|https://wangdoc.com/javascript/async/timer.html","dot":""},{"prefix":"","tag":"setInterval","suffix":"(fn,intv)","desc":"间隔intv毫秒不断执行fn。返回定时器ID\n间隔时间不考虑执行时间。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"clearTimeout","suffix":"(timer)","desc":"清除定时器，返回定时器编号","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"clearInterval","suffix":"(timer)","desc":"清除定时器，返回定时器编号","url":"","summary":"清除所有定时器，先调用setTimeout，得到一个计算器编号，然后把编号比它小的计数器全部取消。\n```javascript\n(function() {\n  // 每轮事件循环检查一次\n  var gid = setInterval(clearAllTimeouts, 0);\n\n  function clearAllTimeouts() {\n    var id = setTimeout(function() {}, 0);\n    while (id > 0) {\n      if (id !== gid) {\n        clearTimeout(id);\n      }\n      id--;\n    }\n  }\n})();\n```","reference":"","dot":""}]},{"title":"下个事件循环","fold":false,"list":[{"prefix":"","tag":"setImmediate","suffix":"(fn,[args])","desc":"在当前回合的 Node.js 事件循环结束时调用的函数。","url":"","summary":"当多次调用 setImmediate() 时，callback 函数会按照它们被创建的顺序依次执行。 每次事件循环迭代都会处理整个回调队列。 如果一个立即定时器是被一个正在执行的回调排入队列的，则该定时器直到下一次事件循环迭代才会被触发。","reference":"","dot":""},{"prefix":"","tag":"clearImmediate","suffix":"(timer)","desc":"取消一个由 setImmediate() 创建的 Immediate 对象。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"setTimeout","suffix":"(fn,0)","desc":"setTimeout(f, 0)会在下一轮事件循环一开始就执行，即浏览器最早可得的空闲时段执行。\n可将计算量大、耗时长的任务切分到若干个setTimeout(f, 0)里面执行","url":"","summary":"```\ndocument.getElementById('input-box').onkeypress = function() {\n  var self = this;\n  setTimeout(function() {\n    self.value = self.value.toUpperCase();\n  }, 0);\n}\n```\n上面代码想在用户每次输入文本后，立即将字符转为大写。但是实际上，它只能将本次输入前的字符转为大写，因为浏览器此时还没接收到新的文本，所以this.value取不到最新输入的那个字符。只有用setTimeout改写，上面的代码才能发挥作用。\n上面代码将代码放入setTimeout之中，就能使得它在浏览器接收到文本之后触发。","reference":"","dot":""}]},{"title":"Node.js","fold":false,"list":[{"prefix":"timeout","tag":".refresh()","suffix":"","desc":"将定时器的开始时间设置为当前时间，并重新安排定时器以在之前指定的持续时间内调用其回调，并将其调整为当前时间。 这对于在不分配新 JavaScript 对象的情况下刷新定时器非常有用。\n在已调用其回调的定时器上使用此选项将重新激活定时器。","url":"","summary":"","reference":"","dot":""},{"prefix":"timeout","tag":".hasRef()","suffix":"","desc":"如果为 true，则 Timeout 对象将会使 Node.js 事件循环保持活动状态。","url":"","summary":"","reference":"","dot":""},{"prefix":"timeout","tag":".ref()","suffix":"","desc":"调用时，只要 Timeout 处于活动状态，就会请求 Node.js 事件循环不会退出。 多次调用 timeout.ref() 将无效。\n\n默认情况下，所有 Timeout 对象都是 ref 的，通常不需要调用 timeout.ref()，除非之前调用了 timeout.unref()。","url":"","summary":"","reference":"","dot":""},{"prefix":"timeout","tag":".unref()","suffix":"","desc":"调用时，活动的 Timeout 对象不需要 Node.js 事件循环保持活动状态。 如果没有其他活动保持事件循环运行，则进程可以在调用 Timeout 对象的回调之前退出。 多次调用 timeout.unref() 将无效。\n\n调用 timeout.unref() 会创建一个内部定时器，它将唤醒 Node.js 事件循环。 创建太多这些定时器可能会对 Node.js 应用程序的性能产生负面影响。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"原型","barcolor":"","fold":true,"box":[{"title":"构造函数与原型对象","fold":false,"list":[{"prefix":"proto = cfn.","tag":"prototype","suffix":"","desc":"返回值：构造函数创建的实例的原型（prototype是函数才会有的属性）\n为减少内存消耗，将公共方法写在构造函数的原型上","url":"","summary":"原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。\n\nJavaScript 规定，每个函数都有一个prototype属性，指向一个对象。\n对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。\n当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。\n如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。","reference":"","dot":""},{"prefix":"proto.","tag":"constructor","suffix":"","desc":"prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数\n*在改变原型对象时，一般要同时设置constructor属性*\n或直接单次在原型上追加方法","url":"","summary":"```\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.constructor === Person // true\n\nPerson.prototype = {\n  method: function () {}\n};\n\nPerson.prototype.constructor === Person // false\nPerson.prototype.constructor === Object // true\n```\n上面代码中，构造函数Person的原型对象改掉了，但是没有修改constructor属性，导致这个属性不再指向Person。由于Person的新原型是一个普通对象，而普通对象的constructor属性指向Object构造函数，导致Person.prototype.constructor变成了Object。\n\n------------------\n\nconstructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。\n另一方面，有了constructor属性，就可以从一个实例对象新建另一个实例。\n```\nfunction Constr() {}\nvar x = new Constr();\n\nvar y = new x.constructor();\ny instanceof Constr // true\n```\n这使得在实例方法中，调用自身的构造函数成为可能。\n```\nConstr.prototype.createCopy = function () {\n  return new this.constructor();\n};\n```","reference":"","dot":""},{"prefix":"proto.","tag":"isPrototypeOf","suffix":"(obj)","desc":"判断是否在对象的原型链上\n或 `obj instanceof proto`","url":"","summary":"由于任意对象（除了null）都是Object的实例，所以instanceof运算符可以判断一个值是否为非null的对象。\n```\nvar obj = { foo: 123 };\nobj instanceof Object // true\n\nnull instanceof Object // false\n```","reference":"","dot":""}]},{"title":"继承","fold":false,"list":[{"prefix":"sub_proto = ","tag":"Object.creat","suffix":"(sup_proto)","desc":"第一步：调用父类构造函数\n第二步：*拷贝生成原型*，并设置构造函数","url":"","summary":"# 第一步：调用父类构造函数\n让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。\n```\nfunction Sub(value) {\n  Super.call(this);\n  this.prop = value;\n}\n```\n# 第二步：拷贝生成原型，并设置构造函数\n```\nSub.prototype = Object.create(Super.prototype);\nSub.prototype.constructor = Sub;\nSub.prototype.method = '...';\n```\n注意不能直接设置子原型等于Super.prototype。否则后面两行对Sub.prototype的操作，会连父类的原型Super.prototype一起修改掉。","reference":"","dot":""}]},{"title":"生成实例","fold":false,"list":[{"prefix":"obj = ","tag":"new ","suffix":"Fn(args)","desc":"new命令的作用，就是执行构造函数，返回一个实例对象。\n如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。\nthis指向生成的实例。","url":"","summary":"1.创建一个空对象，作为将要返回的对象实例。\n2.将这个空对象的原型，指向构造函数的prototype属性。\n3.将这个空对象赋值给函数内部的this关键字。\n4.开始执行构造函数内部的代码。\n\n函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。","reference":"参考资料|https://wangdoc.com/javascript/oop/new.html","dot":""},{"prefix":"obj2 = ","tag":"Object.create","suffix":"(obj1)","desc":"以另一个实例为原型，返回一个实例对象。\n生成实例对象的常用方法是，使用new命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，则可以使用此方法。","url":"","summary":"```\nif (typeof Object.create !== 'function') {\n  Object.create = function (obj) {\n    function F() {}\n    F.prototype = obj;\n    return new F();\n  };\n}\n```\nObject.create方法的实质是新建一个空的构造函数F，然后让F.prototype属性指向参数对象obj，最后返回一个F的实例，从而实现让该实例继承obj的属性。\n\nObject.create方法生成的对象，继承了它的原型对象的构造函数。","reference":"","dot":""},{"prefix":"objx = ","tag":"Object.create","suffix":"(null)","desc":"如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。","url":"","summary":"","reference":"","dot":""}]},{"title":"实例","fold":false,"list":[{"prefix":"obj","tag":".prototype","suffix":"","desc":"构造函数创建的实例的prototype都将指向构造函数的prototype，它是一个对象。\n","url":"","summary":"JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……\n\n如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性。也就是说，所有对象都继承了Object.prototype的属性。这就是所有对象都有valueOf和toString方法的原因，因为这是从Object.prototype继承的。\n\n那么，Object.prototype对象有没有它的原型呢？回答是Object.prototype的原型是null。null没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是null。","reference":"","dot":""},{"prefix":"","tag":"Object.getPrototypeOf","suffix":"(obj)","desc":"返回参数对象的原型","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Object.setPrototypeOf","suffix":"(obj,proto)","desc":"为参数对象设置原型，返回该参数对象\nnew命令可以使用Object.setPrototypeOf方法模拟。","url":"","summary":"```\nvar f = new F();\n// 等同于\nvar f = Object.setPrototypeOf({}, F.prototype);\n```","reference":"","dot":""}]}]},{"title":"面向对象","barcolor":"","fold":false,"box":[{"title":"类","fold":false,"list":[{"prefix":"","tag":"class ","suffix":"Name","desc":"类的内部所有定义的方法，都是不可枚举的","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"constructor","suffix":"(args)","desc":"constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。\nconstructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"this","suffix":"","desc":"代表生成的实例","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":" ","suffix":"prop|fn(args)","desc":"实例属性或方法","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"static ","suffix":"prop|fn(args)","desc":"类属性|方法\n如果静态方法包含this关键字，这个this指的是类，而不是实例。","url":"","summary":"","reference":"","dot":""}]},{"title":"继承","fold":false,"list":[{"prefix":"sub ","tag":"extends ","suffix":"cls","desc":"继承类","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"super","suffix":"","desc":"+ super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。在子类的构造函数中，只有调用super之后，才可以使用this关键字。\n+ super作为对象时，在普通方法中，指向父类的原型对象；在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。\n+ super作为对象时，在静态方法中，指向父类。","url":"","summary":"","reference":"","dot":""}]},{"title":"实例","fold":false,"list":[{"prefix":"","tag":"new ","suffix":"Name(args)","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"obj.","tag":"prop|fn","suffix":"","desc":"访问和设置实例的属性或方法","url":"","summary":"","reference":"","dot":""}]},{"title":"装饰器","fold":false,"list":[{"prefix":"","tag":"get ","suffix":"prop(){..}","desc":"一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。\n存取器往往用于，属性的值依赖对象内部数据的场合。\n参数：无\n返回值：return 内部数据处理结果\n通过getter|setter存取器定义的属性将是可枚举的，对define定义的默认的则是不可枚举的。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"set ","suffix":"prop(val){..}","desc":"参数：设置的值\n返回值：无\n对内部依赖值进行操作\n当只定义了setter而没有定义getter时，获取的key为undefined","url":"","summary":"","reference":"","dot":""}]}]},{"title":"元编程","barcolor":"","fold":false,"box":[{"title":"Proxy","fold":false,"list":[{"prefix":"proxy ","tag":"= new Proxy","suffix":"(obj,opt)","desc":"*get*(target, propKey, receiver)：\n拦截对象属性的读取，数据加工。\n*set*(target, propKey, value, receiver)：\n拦截对象属性的设置，数据验证与监控。\n*apply*(target, object, args)：\n拦截函数调用的操作。\n\n","url":"","summary":"get方法与set方法的receiver，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。但当一个对象通过继承proxy实例作为原型时，则receiver指向此对象，而非proxy实例。\n\n-------------\n\n+ has(target, propKey)\n拦截对象属性存在查询，propKey in proxy的操作，返回一个布尔值。\n\n+ deleteProperty(target, propKey)\n拦截对象属性删除操作，delete proxy[propKey]的操作，返回一个布尔值。\n\n+ ownKeys(target)\n拦截对象属性遍历，返回一个数组，Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。\n\n+ construct(target, args)\n拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)，返回一个对象。\n\n---------\n\n+ getOwnPropertyDescriptor(target, propKey)\n拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象或undefined。\n\n+ defineProperty(target, propKey, propDesc)\n拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。\n\n+ preventExtensions(target)\n拦截Object.preventExtensions(proxy)，返回一个布尔值。\n\n+ isExtensible(target)\n拦截Object.isExtensible(proxy)，返回一个布尔值。\n\n+ getPrototypeOf(target)\n拦截Object.getPrototypeOf(proxy)，返回一个对象或null。\n\n+ setPrototypeOf(target, proto)\n拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。","reference":"","dot":""},{"prefix":"","tag":"Proxy.revocable","suffix":"(obj,opt)","desc":"返回一个可取消的 Proxy 实例\n`let {proxy, revoke} = Proxy.revocable(target, handler);`","url":"","summary":"Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。\n\nProxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。","reference":"","dot":""}]},{"title":"Reflect","fold":false,"list":[{"prefix":"","tag":"Reflect.","suffix":"fn(args)","desc":"在proxy中通过Reflect上获取和完成默认行为。\n`Reflect.apply(...arguments)`\n`Reflect.apply(target,thisArg,args)`","url":"","summary":"","reference":"观察者模式|https://es6.ruanyifeng.com/#docs/reflect","dot":""}]}]},{"title":"元信息","barcolor":"","fold":false,"box":[{"title":"属性描述对象","fold":false,"list":[{"prefix":"desc.","tag":"value","suffix":"","desc":"value是该属性的属性值\n默认为undefined","url":"","summary":"只要writable和configurable有一个为true，就允许改动","reference":"","dot":""},{"prefix":"desc.","tag":"writable","suffix":"","desc":"属性值是否可写\n默认为true","url":"","summary":"writable为false时，直接目标属性赋值，非严格模式不报错但不会成功，严格模式会报错","reference":"","dot":""},{"prefix":"desc.","tag":"enumerable","suffix":"","desc":"属性是否可枚举\n默认为true","url":"","summary":"具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。\n+ for..in循环\n+ Object.keys方法\n+ JSON.stringify方法","reference":"","dot":""},{"prefix":"desc.","tag":"configurable","suffix":"","desc":"属性描述对象的可写性\n默认为true","url":"","summary":"设为false后将不可删除，亦不可修改除value以外的整个属性描述对象","reference":"","dot":""},{"prefix":"desc.","tag":"get","suffix":"","desc":"属性的取值函数\n默认为undefined\n注意，一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错。","url":"","summary":"","reference":"","dot":""},{"prefix":"desc.","tag":"set","suffix":"","desc":"属性的赋值函数\n默认为undefined","url":"","summary":"","reference":"","dot":""}]},{"title":"获取属性","fold":false,"list":[{"prefix":"","tag":"Object.getOwnPropertyDescriptor","suffix":"(obj,key)","desc":"获取对象指定属性的描述对象\n只能用于对象自身的属性，不能用于继承的属性。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Object.getOwnPropertyDescriptors","suffix":"(obj)","desc":"获取一个对象的所有自身属性的描述符\n返回：{key:descobj,..}\n范围：\n☑**可枚举** ☑**不可枚举** \n☑**自身** ☒继承 \n☑**Symbol**","url":"","summary":"","reference":"","dot":""}]},{"title":"设置属性","fold":false,"list":[{"prefix":"","tag":"Object.defineProperty","suffix":"(obj,key,desc)","desc":"设置对象属性的描述对象\n```javascript\nvar obj = Object.defineProperty({}, 'p', {\n  value: 123,\n  writable: false,\n  enumerable: true,\n  configurable: false\n});\n```\n使用此方法时，writable、configurable、enumerable这三个属性的默认值都为false。\n可通过此方法定义隐藏属性","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Object.defineProperties","suffix":"(obj,{key:desc,..})","desc":"一次性定义或修改多个属性\n```javascript\nvar obj = Object.defineProperties({}, {\n  p1: { value: 123, enumerable: true },\n  p2: { value: 'abc', enumerable: true },\n  p3: { get: function () { return this.p1 + this.p2 },\n    enumerable:true,\n    configurable:true\n  }\n});\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"检测属性","fold":false,"list":[{"prefix":"obj.","tag":"propertyIsEnumerable","suffix":"(key)","desc":"判断某个属性是否可枚举\n只能用于判断对象自身的属性，对于继承的属性一律返回false","url":"","summary":"","reference":"","dot":""},{"prefix":"obj.","tag":"hasOwnProperty","suffix":"(key)","desc":"返回值：布尔值\n是否自身具有该属性","url":"","summary":"","reference":"","dot":""}]},{"title":"状态控制","fold":false,"list":[{"prefix":"","tag":"Object.preventExtensions","suffix":"(obj)","desc":"禁止对象扩展属性\n对象无法再添加新的属性","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Object.seal","suffix":"(obj)","desc":"密封一个对象\n使得一个对象既无法添加新属性，也无法删除旧属性\n但并不影响修改某个属性的值","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Object.freeze","suffix":"(obj)","desc":"冻结一个对象\n对象无法添加新属性、无法删除旧属性、也无法改变属性的值","url":"","summary":"局限性：\n可以通过改变原型对象，来为对象增加属性。\n一种解决方案是，把obj的原型也冻结住。\n另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。","reference":"","dot":""}]},{"title":"状态检查","fold":false,"list":[{"prefix":"","tag":"Object.isExtensible","suffix":"(obj)","desc":"检查是否可以为一个对象添加属性","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Object.isSealed","suffix":"(obj)","desc":"检查一个对象是否密封","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Object.isFrozen","suffix":"(obj)","desc":"检查一个对象是否冻结","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"错误异常","barcolor":"","fold":false,"box":[{"title":"Error类","fold":false,"list":[{"prefix":"","tag":"new Error","suffix":"(msg)","desc":"# 冒泡与捕获\n如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。所以，我们不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获，一网打尽。","url":"","summary":"```\nclass Myerr extends Error{\n   constructor(arg,...params){\n       super(...params);\n       if (Error.captureStackTrace) {\n           Error.captureStackTrace(this, CustomError);\n       }\n       this.code = arg\n   }\n}\n```","reference":"","dot":""},{"prefix":"err.","tag":"message","suffix":"","desc":"err.message: 错误提示信息\nerr.name：错误名称（浏览器非标准属性）","url":"","summary":"","reference":"","dot":""},{"prefix":"err.","tag":"stack","suffix":"","desc":"浏览器 错误的堆栈（非标准属性）\nNode.js 描述代码中 Error 被实例化的位置","url":"","summary":"","reference":"","dot":""},{"prefix":"err.","tag":"code","suffix":"","desc":"浏览器: 可自定义err.code对错误分类\nNode.js: 识别错误的最稳定方法,它只会在 Node.js 的主要版本之间更改。","url":"","summary":"","reference":"","dot":""}]},{"title":"原生错误类型","fold":true,"list":[{"prefix":"","tag":"共有","suffix":"","desc":"+ SyntaxError 解析代码时发生的语法错误\n+ ReferenceError 引用一个不存在的变量时发生的错误\n+ RangeError 表明提供的参数不在函数的可接受值的集合或范围内；无论是一个数字范围，还是在给定的函数参数的选项的集合之外。\n+ TypeError 变量或参数不是预期类型时发生的错误,调用对象不存在的方法,也会抛出TypeError错误","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"浏览器","suffix":"","desc":"+ URIError URI 相关函数的参数不正确时抛出的错误\n+ EvalError eval函数没有被正确执行时","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Node.js","suffix":"","desc":"+ AssertionError 表明断言的失败\n+ SystemError 系统错误\n+ OpenSSL 错误","url":"","summary":"","reference":"系统错误|http://nodejs.cn/api/errors.html#errors_common_system_errors","dot":""}]},{"title":"自定义错误类型","fold":false,"list":[{"prefix":"","tag":"throw ","suffix":"err","desc":"手动中断程序执行，抛出一个错误。\n对于 JavaScript 引擎来说，遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。","url":"","summary":"throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。","reference":"","dot":""}]},{"title":"同步捕获","fold":false,"list":[{"prefix":"","tag":"try..catch(e)..finally","suffix":"","desc":"catch接受一个参数，表示try代码块抛出的值。\ncatch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去\nfinally代码块，表示不管是否出现错误，都必需在最后运行的语句。\n*try和catch中的return和throw会触发转入finally，返回值在finally之前取得，但在finally执行完后才返回，finally中可以覆盖返回值。*\n\n# 范围:\n1.同步\n2.指定业务需要作针对处理的","url":"","summary":"涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。类似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。","reference":"参考资料|https://wangdoc.com/javascript/features/error.html","dot":""},{"prefix":"","tag":" ","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"异步捕获","fold":false,"list":[{"prefix":"","tag":"window.onerror","suffix":"= fn(message, source, lineno, colno, error)","desc":"windows内运行时的异常捕获,包括同步和异步(包括事件).\n\n# 范围\n1. 同步 | 异步\n2. 运行中的意外错误,需设置`return true`并放在所有脚本之前.\n3. 无法处理网络请求错误\n","url":"","summary":"```javascript\nwindow.onerror = function(message, source, lineno, colno, error) {\n// message：错误信息（字符串）。\n// source：发生错误的脚本URL（字符串）\n// lineno：发生错误的行号（数字）\n// colno：发生错误的列号（数字）\n// error：Error对象（对象）\nconsole.log('捕获到异常：',{message, source, lineno, colno, error});\n}\n```\n\nwindow.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx。\nonerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误。\n","reference":"参考资料|https://mp.weixin.qq.com/s/A6eSNyW1VS9EXFZpnAAYPQ","dot":""},{"prefix":"","tag":"window.addEventListener","suffix":"('error',fn(err)))","desc":"当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，*并执行该元素上的onerror() 处理函数*。这些 error 事件不会向上冒泡到 window ，不过能被单一的window.addEventListener 捕获。\n\n# 范围\n1. 同步 | 异步 | 资源加载\n2. 需对资源绑定onerror处理函数\n3. GFW导致的为超时错误,需自行使用定时器,而非等待报错","url":"","summary":"需要注意：\n不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。\n需要注意避免 addEventListener 重复监听。","reference":"","dot":""},{"prefix":"","tag":"window.addEventListener","suffix":"(\"unhandledrejection\",fn(e))","desc":"对没有做处理的 Promise 异常，可以在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error。(如果去掉控制台的异常显示需要阻止默认行为)\n\n# 范围\n1.Uncaught Promise Error","url":"","summary":"```\nwindow.addEventListener(\"unhandledrejection\", function(e) {\n    e.preventDefault();\n    console.log(\"捕获到异常：\", e);\n    return true;\n});\n```","reference":"","dot":""},{"prefix":"emitter","tag":".on","suffix":"('error',fn(err))","desc":"发生错误的时候，也可以用EventEmitter接口抛出error事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"process.","tag":"on","suffix":"('uncaughtException', fn(err))","desc":"当一个异常未被捕获，就会触发uncaughtException事件，可以对这个事件注册回调函数，从而捕获异常。","url":"","summary":"","reference":"","dot":""}]},{"title":"iframe","fold":false,"list":[{"prefix":"","tag":"window.frames[i].onerror","suffix":"","desc":"捕获同源iframe内部的错误","url":"","summary":"iframe自身的加载总会触发load,不管成功或失败.只能通过内容判断\n```\nwindow.frames[0].onerror = function (message, source, lineno, colno, error) {\n    console.log('捕获到 iframe 异常：',{message, source, lineno, colno, error});\n    return true;\n};\nwindow.frames[0].onload = function () {\n    console.log(window.frames[0].document)\n    console.log(document.getElementById('abc').contentWindow.document)\n};\n```","reference":"","dot":""}]},{"title":"框架","fold":true,"list":[{"prefix":"","tag":"Vue.config.errorHandler","suffix":"","desc":"VUE errorHandler\n```\nVue.config.errorHandler = (err, vm, info) => {\n  console.error('通过vue errorHandler捕获的错误');\n  console.error(err);\n  console.error(vm);\n  console.error(info);\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"componentDidCatch","suffix":"","desc":"```\ncomponentDidCatch(error, info) {\n    console.log(error, info);\n}\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"崩溃卡顿","fold":true,"list":[{"prefix":"","tag":"load & beforeunload","suffix":"","desc":"利用 window 对象的 load 和 beforeunload 事件实现了网页崩溃的监控","url":"","summary":"```javascript\nwindow.addEventListener('load', function () {\n    sessionStorage.setItem('good_exit', 'pending');\n    setInterval(function () {\n        sessionStorage.setItem('time_before_crash', newDate().toString());\n    }, 1000);\n  });\n\n  window.addEventListener('beforeunload', function () {\n    sessionStorage.setItem('good_exit', 'true');\n  });\n\n  if(sessionStorage.getItem('good_exit') &&\n    sessionStorage.getItem('good_exit') !== 'true') {\n    /*\n        insert crash logging code here\n    */\n    alert('Hey, welcome back from your crash, looks like you crashed on: ' + sessionStorage.getItem('time_before_crash'));\n  }\n```","reference":"","dot":""},{"prefix":"","tag":"Service Worker","suffix":"","desc":"Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。","url":"","summary":"","reference":"","dot":""}]},{"title":"错误上报","fold":true,"list":[{"prefix":"","tag":"new Image().src","suffix":"","desc":"通过 Ajax 发送数据 因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。\n动态创建 img 标签的形式\n```\nfunction report(error) {\n  let reportUrl = 'http://jartto.wang/report';\n  new Image().src = `${reportUrl}?logs=${error}`;\n}\n```","url":"","summary":"收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力：\n```\nReporter.send = function(data) {\n  // 只采集 30%\n  if(Math.random() < 0.3) {\n    send(data)      // 上报错误信息\n  }\n}\n```","reference":"","dot":""}]}]},{"title":"调试测试","barcolor":"","fold":false,"box":[{"title":"断言","fold":false,"list":[{"prefix":"","tag":"assert","suffix":"(exp,msg)","desc":"当第一个参数对应的布尔值为true时，不会有任何提示，返回undefined。当第一个参数对应的布尔值为false时，会抛出一个错误，该错误的提示信息就是第二个参数设定的字符串。","url":"","summary":"","reference":"参考资料|https://javascript.ruanyifeng.com/nodejs/assert.html","dot":""},{"prefix":"assert","tag":".equal","suffix":"(val1,val2,msg)","desc":"第一个参数是实际值，第二个是预期值，第三个是错误的提示信息。\nequal方法内部使用的是相等运算符（==），而不是严格运算符（===），进行比较运算。","url":"","summary":"assert.notEqual() 在实际值等于预期值时，才会抛出错误。\nassert.deepEqual() 用来比较两个对象。只要它们的属性一一对应，且值都相等，就认为两个对象相等，否则抛出一个错误。\nassert.notDeepEqual() 与deepEqual方法正好相反，用来断言两个对象是否不相等。\nassert.strictEqual() 使用严格相等运算符（===），比较两个表达式。\nassert.notStrictEqual() 使用严格不相等运算符（!==），比较两个表达式。","reference":"","dot":""},{"prefix":"assert","tag":".ifError(val)","suffix":"","desc":"断言某个表达式是否false，如果该表达式对应的布尔值等于true，就抛出一个错误。它对于验证回调函数的第一个参数十分有用，如果该参数为true，就表示有错误。","url":"","summary":"","reference":"","dot":""},{"prefix":"assert","tag":".fail","suffix":"(actual,expected,message,operator)","desc":"抛出一个错误\n该方法共有四个参数，但是不管参数是什么值，它总是抛出一个错误。如果message参数对应的布尔值不为false，抛出的错误信息就是message，否则错误信息就是“实际值 + 分隔符 + 预期值”。","url":"","summary":"","reference":"","dot":""}]},{"title":"控制台","fold":false,"list":[{"prefix":"console.","tag":"log","suffix":"(msg)","desc":"+ logo,info,debug 信息\n+ warn,error 错误\n```javascript\nconsole.log(\n  '%cThis text is styled!',\n  'color: red; background: yellow; font-size: 24px;'\n)\n```\n","url":"","summary":"%s 字符串\n%d 整数\n%i 整数\n%f 浮点数\n%o 对象的链接\n%c CSS 格式字符串","reference":"","dot":""},{"prefix":"console.","tag":"table|dir","suffix":"(obj|ele)","desc":"+ table 格式化表格显示\n+ dir(ele),dirxml(ele) 对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。","url":"","summary":"","reference":"","dot":""},{"prefix":"console.","tag":"group","suffix":"(label)|groupEnd()","desc":"+ group(label) 分组开始\n+ groupCollapsed(label) 默认折叠\n+ groupEnd() 分组结束","url":"","summary":"","reference":"","dot":""},{"prefix":"console.","tag":"count","suffix":"(label)","desc":"+ count(label) 计数，可以接受一个字符串作为参数，作为标签，对执行次数进行分类\n+ countReset(label) 重置计数","url":"","summary":"","reference":"","dot":""},{"prefix":"console.","tag":"time","suffix":"(label)","desc":"+ time(label) 开始计时\n+ timeEnd(label) 结束计时","url":"","summary":"","reference":"","dot":""},{"prefix":"console.","tag":"assert","suffix":"(exp,msg)","desc":"一个简单的断言测试，验证 value 是否为真。 如果不为真，则抛出 AssertionError。","url":"","summary":"","reference":"","dot":""},{"prefix":"console.","tag":"trace()","suffix":"","desc":"显示当前执行的代码在堆栈中的调用路径","url":"","summary":"","reference":"","dot":""},{"prefix":"console.","tag":"clear()","suffix":"","desc":"清除当前控制台的所有输出","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"模块","barcolor":"","fold":false,"box":[{"title":"Node.js","fold":false,"list":[{"prefix":"","tag":"module","suffix":"","desc":"对当前模块的引用","url":"","summary":"+ module.filename 模块的完全解析后的文件名\n+ module.id 模块的标识符。 通常是完全解析后的文件名。\n+ module.loaded 模块是否已经加载完成，或正在加载中。\n+ module.parent 最先引用该模块的模块。\n+ module.children 被该模块引用的模块对象。","reference":"参考资料|http://nodejs.cn/api/modules.html","dot":""},{"prefix":"","tag":"module.exports","suffix":"","desc":"导出模块","url":"","summary":"exports是一个对于 module.exports 的更简短的引用形式\n如果一个新的值被赋值给 exports，它就不再绑定到 module.exports\n但如果是对exports.prop进行赋值，则依然当做module.exports.prop输出\n当 module.exports 属性被一个新的对象完全替代时，也会重新赋值 exports","reference":"参考资料|https://mp.weixin.qq.com/s/MV2juZqDCxxYzx7iMKQjZQ","dot":""},{"prefix":"","tag":"require","suffix":"(mod)","desc":"引入模块\n","url":"","summary":"# 路径分析和文件定位\n缓存 > 原生模块 > 相对路径文件模块 > 绝对路径文件模块 > node_modules\nnode_modules(当前文件目录下>父目录下>..>根目录下)\n目录时:优先加载package.json中main指定,否则尝试index.js和index.node\n\n# 模块编译\n.js文件 > .node文件 > .json文件\n+ js文件:通过fs模块同步读取文件后编译执行\n+ node文件:通过dlopen方法加载最后编译生效的文件(c/c++)\n+ json文件:通过fs模块同步读取文件后用JSON.parse解析返回结果\n\n----\n\n# 缓存\n模块在第一次加载后会被缓存。 这也意味着（类似其他缓存机制）如果每次调用 require('foo') 都解析到同一文件，则返回相同的对象。如果想要多次执行一个模块，可以导出一个函数，然后调用该函数。\n模块是基于其解析的文件名进行缓存的。 由于调用模块的位置的不同，模块可能被解析成不同的文件名（比如从 node_modules 目录加载），这样就不能保证 require('foo') 总能返回完全相同的对象。\n\n----\n\n# 其它\n+ require.extensions['.ext'] 扩展自定义的文件类型\n+ require.main\n当 Node.js 直接运行一个文件时， require.main 会被设为它的 module。 这意味着可以通过 require.main === module 来判断一个文件是否被直接运行\n通过检查 require.main.filename 来获取当前应用程序的入口点","reference":"","dot":""}]},{"title":"ES5","fold":false,"list":[{"prefix":"(fn)(global|mod)","tag":" ","suffix":"","desc":"通过将外部环境以变量传入匿名立即执行函数\n封装内部变量\n并设置挂载到全局对象","url":"","summary":"JavaScript 模块的基本写法，立即执行函数，封装私有变量\n```\nvar module1 = (function () {\n　var _count = 0;\n　var m1 = function () {\n　  //...\n　};\n　var m2 = function () {\n　　//...\n　};\n　return {\n　　m1 : m1,\n　　m2 : m2\n　};\n})();\n```\n模块放大模式\n```\nvar module1 = (function (mod){\n　mod.m3 = function () {\n　　//...\n　};\n　return mod;\n})(module1 || {});\n```\n为了在模块内部调用全局变量，必须显式地将其他变量输入模块。\n```\nvar module1 = (function ($, YAHOO) {\n　//...\n})(jQuery, YAHOO);\n```\njQuery的实现原理参考，挂载到全局\n```\n(function($, window, document) {\n\n  function go(num) {\n  }\n\n  function handleEvents() {\n  }\n\n  function initialize() {\n  }\n\n  function dieCarouselDie() {\n  }\n\n  //attach to the global scope\n  window.finalCarousel = {\n    init : initialize,\n    destroy : dieCarouselDie\n  }\n\n})( jQuery, window, document );\n```","reference":"参考资料|https://wangdoc.com/javascript/oop/prototype.html","dot":""}]},{"title":"ES6","fold":false,"list":[{"prefix":"","tag":"export","suffix":"","desc":"导出\n","url":"","summary":"1. export .. 可出现多次\n2. export {..}\n3. export {.. as ..}\n4. export default .. 指定默认导出","reference":"","dot":""},{"prefix":"","tag":"import","suffix":"","desc":"导入","url":"","summary":"1. import * from ..\n2. import {..} from ..\n3. import {.. as ..} from ..\n4. import myname from .. 指定任意自定义名字引入default的内容\n5. import .. 仅仅执行模块，但是不输入任何值。","reference":"","dot":""},{"prefix":"","tag":"import","suffix":"(..)","desc":"按需加载或条件加载，支持路径动态生成。\n返回一个promise `import(..).then(mod=>..)`","url":"","summary":"","reference":"","dot":""}]}]},{"title":"包","barcolor":"","fold":false,"box":[{"title":"package.json","fold":false,"list":[{"prefix":"","tag":"package.json","suffix":"","desc":"name 不能以\"_\"或\".\"开头,不能含有大写字母,name会成为url的一部分，不能含有url非法字符","url":"","summary":"version 版本\ndescription 描述\nkeywords 关键词数组\nauthor 作者 \ncontributors 贡献者数组\nrepository 代码仓库\ndependencies 依赖\ndevDependencies 开发依赖","reference":"","dot":""},{"prefix":"main","tag":" ","suffix":"","desc":"指定了程序的主入口文","url":"","summary":"","reference":"","dot":""},{"prefix":"bin","tag":" ","suffix":"","desc":"模块安装的时候，若是全局安装，则npm会为bin中配置的文件在bin目录下创建一个软连接（对于windows系统，默认会在C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的./node_modules/.bin/目录下创建一个软链接。","url":"","summary":"```\n\"bin\": {\n  \"someTool\": \"./bin/someTool.js\"\n}\nscripts: {  \n  start: 'someTool build'\n}\n```\n","reference":"参考资料|https://javascript.ruanyifeng.com/nodejs/packagejson.html","dot":""},{"prefix":"config","tag":" ","suffix":"","desc":"会被注册到 process.env.npm_package_config_$var","url":"","summary":"","reference":"","dot":""}]},{"title":"初始化与设置","fold":false,"list":[{"prefix":"npm ","tag":"-v","suffix":"","desc":"查看版本","url":"","summary":"","reference":"","dot":""},{"prefix":"npm ","tag":"init ","suffix":"-y","desc":"`npm init -y` 生成一个新的package.json文件\n设置环境变量,这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入.\n```\nnpm set init-author-name 'Your name'`\nnpm set init-author-email 'Your email'\nnpm set init-author-url 'http://yourdomain.com'\nnpm set init-license 'MIT'\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"npm ","tag":"config set registry","suffix":"","desc":"`npm config set registry https://registry.npm.taobao.org` 更换淘宝源\n`npm config set registry https://registry.npmjs.org` 恢复默认源\n`npm --registry https://registry.npmjs.org install pkg` 临时使用\n`npm config get registry` 查看当前源","url":"","summary":"","reference":"","dot":""}]},{"title":"脚本命令","fold":false,"list":[{"prefix":"npm ","tag":"run ","suffix":"script","desc":"预定义脚本test、start、install、publish可以直接使用npm script","url":"","summary":"","reference":"全部预定义脚本|https://docs.npmjs.com/misc/scripts#description","dot":""},{"prefix":"run-script ","tag":"&& ","suffix":"run-script","desc":"先后运行","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":" ","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""},{"prefix":"run-script ","tag":"& ","suffix":"run-script","desc":"平行执行","url":"","summary":"","reference":"","dot":""},{"prefix":"npm run script ","tag":"-- args","suffix":"","desc":"传递参数给原始脚本命令","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"pre-/post-","suffix":"run-script","desc":"npm run为每条命令提供了pre-和post-两个钩子（hook）。以npm run lint为例，执行这条命令之前，npm会先查看有没有定义prelint和postlint两个钩子，如果有的话，就会先执行npm run prelint，然后执行npm run lint，最后执行npm run postlint。","url":"","summary":"prepublish：发布一个模块前执行。\npostpublish：发布一个模块后执行。\npretest：运行npm test命令前执行。\nposttest：运行npm test命令后执行。\nprestart：运行npm start命令前执行。\npoststart：运行npm start命令后执行。\nprerestart：运行npm restart命令前执行。\npostrestart：运行npm restart命令后执行。","reference":"","dot":""},{"prefix":"","tag":"$npm_package_","suffix":"conf","desc":"scripts字段可以使用一些内部变量，主要是package.json的各种字段。\n```\n{\n  \"scripts\":{\n    \"bundle\": \"mkdir -p build/$npm_package_version/\"\n  }\n}\n```\nconfig字段也可以用于设置内部字段。\n```\n\"config\": {\n    \"reporter\": \"xunit\"\n},\n\"scripts\": {\n    \"test\": \"mocha test/ --reporter $npm_package_config_reporter\"\n}\n```","url":"","summary":"# 通配符规则\n* 匹配0个或多个字符\n? 匹配1个字符\n[...] 匹配某个范围的字符。如果该范围的第一个字符是!或^，则匹配不在该范围的字符。\n!(pattern|pattern|pattern) 匹配任何不符合给定的模式\n?(pattern|pattern|pattern) 匹配0个或1个给定的模式\n+(pattern|pattern|pattern) 匹配1个或多个给定的模式\n*(a|b|c) 匹配0个或多个给定的模式\n@(pattern|pat*|pat?erN) 只匹配给定模式之一\n** 如果出现在路径部分，表示0个或多个子目录。","reference":"参考资料|https://javascript.ruanyifeng.com/nodejs/npm.html","dot":""}]},{"title":"安装包","fold":false,"list":[{"prefix":"","tag":"npm install","suffix":"","desc":"默认会安装dependencies字段和devDependencies字段中的所有模块\n使用--production参数，可以只安装dependencies字段的模块","url":"","summary":"","reference":"","dot":""},{"prefix":"npm install -g ","tag":"pkg","suffix":"","desc":"`npm install pkg` 安装包\n`npm install -g pkg` 全局安装","url":"","summary":"# 避免系统权限\n默认情况下，Npm全局模块都安装在系统目录（比如/usr/local/lib/），普通用户没有写入权限，需要用到sudo命令。这不是很方便，我们可以在没有root权限的情况下，安装全局模块。\n首先，在主目录下新建配置文件.npmrc，然后在该文件中将prefix变量定义到主目录下面。\n`prefix = /home/yourUsername/npm`\n然后在主目录下新建npm子目录。\n`$ mkdir ~/npm`\n此后，全局安装的模块都会安装在这个子目录中，npm也会到~/npm/bin目录去寻找命令。\n最后，将这个路径在.bash_profile文件（或.bashrc文件）中加入PATH变量。\n`export PATH=~/npm/bin:$PATH`","reference":"参考资料|https://javascript.ruanyifeng.com/nodejs/npm.html","dot":""},{"prefix":"npm install pkg","tag":"@latest","suffix":"","desc":"`npm install pkg@latest` 安装最新版\n`npm install pkg@0.1.1` 安装指定版本\n`npm install pkg@\">=0.1.0 <0.2.0\"` 安装指定范围内版本\n`npm install pkg --save --save-exact` 记录为具体的版本\n`npm set save-exact true` 将记录模块的确切版本，而不是一个可选的版本范围","url":"","summary":"","reference":"","dot":""},{"prefix":"npm install pkg ","tag":"-S/-D","suffix":"","desc":"`–-save`或`-S`：模块名将被添加到dependencies。\n`–-save-dev`或`-D`: 模块名将被添加到devDependencies。","url":"","summary":"","reference":"","dot":""}]},{"title":"更新包","fold":false,"list":[{"prefix":"npm ","tag":"update ","suffix":"-g pkg -S","desc":"更新包,但不更新其依赖.","url":"","summary":"","reference":"","dot":""},{"prefix":"npm ","tag":"uninstall ","suffix":"-g pkg","desc":"卸载包","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"npm-check -u","suffix":"","desc":"一行命令更新所有 npm 依赖包\n`npm i -g npm-check` 先安装npm-check","url":"","summary":"","reference":"参考资料|https://nusr.github.io/post/2019/2019-04-21-update-all-npm-package/","dot":""},{"prefix":"","tag":" ","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"发布包","fold":false,"list":[{"prefix":"npm ","tag":"link","suffix":"","desc":"+ 开发包内`npm link`\n+ 项目包内`npm link devModule`","url":"","summary":"","reference":"参考资料|https://javascript.ruanyifeng.com/nodejs/npm.html#toc18","dot":""},{"prefix":"npm ","tag":"adduser","suffix":"","desc":"注册","url":"","summary":"","reference":"","dot":""},{"prefix":"npm ","tag":"login","suffix":"","desc":"登录","url":"","summary":"","reference":"","dot":""},{"prefix":"npm ","tag":"publish","suffix":"--tag beta","desc":"发布latest `npm publish`\n发布测试版 `npm publish --tag beta`","url":"","summary":"","reference":"","dot":""},{"prefix":"npm publish ","tag":"--access public","suffix":"","desc":"发布@scope公开包","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":".npmignore","suffix":"","desc":"可直接只发布最后构建内容\n```\n\"scripts\": {\n  \"build\": \"babel source --presets babel-preset-es2015 --out-dir distribution\",\n  \"prepublish\": \"npm run build\"\n}\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"npm ","tag":"owner","suffix":"","desc":"列出指定模块的维护者 npm owner ls <package name>\n新增维护者 npm owner add <user> <package name>\n删除维护者 npm owner rm <user> <package name>","url":"","summary":"","reference":"","dot":""}]}]}]}]}