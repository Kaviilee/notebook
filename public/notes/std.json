{"version":1584764487902,"name":"git","data":[{"column":[{"title":"Buffer","barcolor":"","fold":false,"box":[{"title":"创建","fold":false,"list":[{"prefix":"","tag":"Buffer.from","suffix":"(str,encoding)","desc":"Buffer 实例也是 Uint8Array 实例，长度1为1个字节（8位）\n+ Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）\n+ Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。\n+ Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例\n+ Buffer.from(object[, offsetOrEncoding[, length]]) 对于对象的valueOf()返回值\n+ Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例\n+ Buffer.from(path)：从文件内容返回","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Buffer.alloc","suffix":"(size)","desc":"+ Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0\n+ Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据\n+ Buffer.allocUnsafeSlow(size)","url":"","summary":"","reference":"","dot":""}]},{"title":"读取","fold":false,"list":[{"prefix":"buf","tag":"[i]","suffix":"","desc":"获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".length","suffix":"","desc":"返回 Buffer 对象所占据的内存长度。(字节数）\n`Buffer.byteLength(buf)`","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"<encoding>","suffix":"","desc":"# nodejs默认内置字符编码\n+ ascii \n仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。\n+ utf-8\n多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。\n+ hex \n将每个字节编码为两个十六进制字符（1字节=8位=2个4位,2^4=16）\n+ base64\nMIME编码的一种\n+ latin1/binary \n一种把 Buffer 编码成一字节编码的字符串的方式,ISO-8859-1的别名\n+ utf16le/ucs2 \n2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。","url":"","summary":"# ascii\n作用：表语英语及西欧语言。\n位数：ASCII是用7位表示的，能表示128个字符；其扩展使用8位表示，表示256个字符。\n范围：ASCII从00到7F，扩展从00到FF\n# iso8859-1\n作用：扩展ASCII，表示西欧、希腊语等。\n位数：8位\n范围：从00到FF，兼容ASCII字符集\n# GB2312字符集\n作用：国家简体中文字符集，兼容ASCII。\n位数：使用2个字节表示，能表示7445个符号，包括6763个汉字，几乎覆盖所有高频率汉字。\n范围：高字节从A1到F7, 低字节从A1到FE。将高字节和低字节分别加上0XA0即可得到编码。\n# GBK字符集\n作用：它是GB2312的扩展，加入对繁体字的支持，兼容GB2312。\n位数：使用2个字节表示，可表示21886个字符。\n范围：高字节从81到FE，低字节从40到FE。\n# BIG5字符集\n作用：它解决了中文、日文、朝鲜语等的编码，兼容GBK。\n位数：它采用变字节表示(1 ASCII，2，4字节)。可表示27484个文字。\n范围：1字节从00到7F; 2字节高字节从81到FE，低字节从40到7E和80到FE；4字节第一三字节从81到FE，第二四字节从30到39。\n# UTF-8/UTF-32/UTF-16/UTF-7\n作用：为世界650种语言进行统一编码，兼容ISO-8859-1。\n位数：UNICODE字符集有多个编码方式，分别是UTF-8，UTF-16和UTF-32。","reference":"参考资料1|https://www.cnblogs.com/happyday56/p/4135845.html\n参考资料2|https://dailc.github.io/2017/06/03/utf8ToUtf16ToGbk.html","dot":""},{"prefix":"buf","tag":".toString","suffix":"([encoding])","desc":"解码缓冲区数据并使用指定的编码返回字符串。\n`buf.toString([encoding[, start[, end]]])`\nencoding - 使用的编码。默认为 'utf8' 。\nstart - 指定开始读取的索引位置，默认为 0。\nend - 结束位置，默认为缓冲区的末尾。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"iconv-lite","suffix":"","desc":"包括gbk在内的更多编码支持\n```javascript\nvar iconv = require('iconv-lite');\n \n// Convert from an encoded buffer to js string.\nstr = iconv.decode(Buffer.from([0x68, 0x65, 0x6c, 0x6c, 0x6f]), 'win1251');\n \n// Convert from js string to an encoded buffer.\nbuf = iconv.encode(\"Sample input string\", 'win1251');\n \n// Check if encoding is supported\niconv.encodingExists(\"us-ascii\")\n```","url":"https://www.npmjs.com/package/iconv-lite","summary":"","reference":"","dot":""}]},{"title":"操作","fold":false,"list":[{"prefix":"buf","tag":".write","suffix":"(str)","desc":"返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。\n`buf.write(string[, offset[, length]][, encoding])`\nstring - 写入缓冲区的字符串。\noffset - 缓冲区开始写入的索引值，默认为 0 。\nlength - 写入的字节数，默认为 buffer.length\nencoding - 使用的编码。默认为 'utf8' 。","url":"","summary":"buf.writeBigInt64BE(value[, offset])\nbuf.writeBigInt64LE(value[, offset])\nbuf.writeBigUInt64BE(value[, offset])\nbuf.writeBigUInt64LE(value[, offset])\nbuf.writeDoubleBE(value[, offset])\nbuf.writeDoubleLE(value[, offset])\nbuf.writeFloatBE(value[, offset])\nbuf.writeFloatLE(value[, offset])\nbuf.writeInt8(value[, offset])\nbuf.writeInt16BE(value[, offset])\nbuf.writeInt16LE(value[, offset])\nbuf.writeInt32BE(value[, offset])\nbuf.writeInt32LE(value[, offset])\nbuf.writeIntBE(value, offset, byteLength)\nbuf.writeIntLE(value, offset, byteLength)\nbuf.writeUInt8(value[, offset])\nbuf.writeUInt16BE(value[, offset])\nbuf.writeUInt16LE(value[, offset])\nbuf.writeUInt32BE(value[, offset])\nbuf.writeUInt32LE(value[, offset])\nbuf.writeUIntBE(value, offset, byteLength)\nbuf.writeUIntLE(value, offset, byteLength)","reference":"","dot":""},{"prefix":"","tag":"Buffer.concat","suffix":"([buf1,buf2,..])","desc":"缓冲区合并,返回一个多个成员合并的新 Buffer 对象。\n`Buffer.concat(list[, totalLength])`\nlist - 用于合并的 Buffer 对象数组列表。\ntotalLength - 指定合并后Buffer对象的总长度。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".slice","suffix":"(start,[end])","desc":"`buf.slice([start[, end]])`\n返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf1","tag":".copy","suffix":"(buf2)","desc":"`buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])`\n缓冲区拷贝,没有返回值","url":"","summary":"","reference":"","dot":""},{"prefix":"buf1","tag":".compare","suffix":"(buf2)","desc":"比较两个buffer，返回一个数字，表示 buf 在 otherBuffer 之前(<0)，之后或相同\n`buf.equals(otherBuffer)` 比较两个缓冲区是否相等，如果是返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".fill","suffix":"(val)","desc":"`buf.fill(value[, offset][, end])`\n使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。","url":"","summary":"","reference":"","dot":""}]},{"title":"python","fold":false,"list":[{"prefix":"","tag":"struct.pack","suffix":"(flag,data)","desc":"把任意数据类型变成bytes","url":"","summary":"","reference":"参考资料|https://www.liaoxuefeng.com/wiki/1016959663602400/1017685387246080","dot":""},{"prefix":"","tag":"struct.unpack","suffix":"(flag,bytes)","desc":"把bytes变成相应的数据类型","url":"","summary":"","reference":"","dot":""}]}]},{"title":"events","barcolor":"","fold":false,"box":[{"title":"创建实例","fold":false,"list":[{"prefix":"","tag":"new events.EventEmitter()","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"添加监听","fold":false,"list":[{"prefix":"emitter","tag":".addListener","suffix":"(evt,fn)","desc":"为指定事件添加一个监听器到监听器数组的尾部。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".on","suffix":"(evt,fn)","desc":"为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数\n不会检查 listener 是否已被添加。 多次调用并传入相同的 eventName 与 listener 会导致 listener 会被添加多次。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".prependListener","suffix":"(evt,fn)","desc":"添加 listener 函数到名为 eventName 的事件的监听器数组的开头。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".once","suffix":"(evt,fn)","desc":"为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".prependOnceListener","suffix":"(evt,fn)","desc":"添加单次监听器 listener 到名为 eventName 的事件的监听器数组的开头。 \n当 eventName 事件下次触发时，监听器会先被移除，然后再调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"newListener","suffix":",fn)","desc":"实例在新的监听器被添加到其内部监听器数组之前，会触发自身的 'newListener' 事件。","url":"","summary":"","reference":"","dot":""}]},{"title":"移除监听","fold":false,"list":[{"prefix":"emitter","tag":".removeListener","suffix":"(evt,fn)","desc":"移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。\n最多只会从监听器数组中移除一个监听器。 如果监听器被多次添加到指定 eventName 的监听器数组中，则必须多次调用 removeListener() 才能移除所有实例。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".off","suffix":"(evt,fn)","desc":"emitter.removeListener() 的别名。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".removeAllListeners","suffix":"([evt])","desc":"移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"removeListener","suffix":",fn)","desc":"'removeListener' 事件在 listener 被移除后触发。","url":"","summary":"","reference":"","dot":""}]},{"title":"触发事件","fold":false,"list":[{"prefix":"emitter","tag":".emit","suffix":"(evt,args..)","desc":"按监听器的顺序执行执行每个监听器\n如果事件有注册监听返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"error","suffix":",fn)","desc":"我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。","url":"","summary":"","reference":"","dot":""}]},{"title":"其它","fold":true,"list":[{"prefix":"emitter","tag":".eventNames()","suffix":"","desc":"返回已注册监听器的事件名数组。 数组中的值为字符串或 Symbol。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".listeners","suffix":"(evt)","desc":"返回指定事件的监听器数组。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".listenerCount","suffix":"(evt)","desc":"返回正在监听的名为 eventName 的事件的监听器的数量。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".setMaxListeners","suffix":"(n)","desc":"默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 \nsetMaxListeners 函数用于提高监听器的默认限制的数量。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"stream","barcolor":"","fold":false,"box":[{"title":"管道全自动","fold":false,"list":[{"prefix":"rs","tag":".pipe","suffix":"(ws,[{end:false}])","desc":"绑定可写流到可读流，将可读流自动切换到流动模式，并将可读流的所有数据推送到绑定的可写流。 数据流会被自动管理，所以即使可读流更快，目标可写流也不会超负荷。\n**返回:目标流的引用**\n默认情况下，当来源可读流触发 'end' 事件时，目标可写流也会调用 stream.end() 结束写入。 若要禁用这种默认行为， end 选项应设为 false，这样目标流就会保持打开\n```\nreader.pipe(writer, { end: false });\nreader.on('end', () => {\n  writer.end('结束');\n});\n```\n如果可读流在处理期间发送错误，则可写流目标不会自动关闭。 如果发生错误，则需要手动关闭每个流以防止内存泄漏。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"pipe","suffix":",fn(rs))","desc":"当在可读流上调用 stream.pipe() 方法时会发出 'pipe' 事件，并将此可写流添加到其目标集","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".unpipe","suffix":"([ws])","desc":"解绑之前使用 stream.pipe() 方法绑定的可写流\n如果没有指定 destination, 则解绑所有管道\n如果指定了 destination, 但它没有建立管道，则不起作用","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"unpipe","suffix":",fn)","desc":"在可读流上调用 stream.unpipe() 方法时会发出 'unpipe'事件，从其目标集中移除此可写流。\n当可读流通过管道流向可写流发生错误时，也会触发此事件。","url":"","summary":"","reference":"","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"s","tag":".destroy","suffix":"([error])","desc":"销毁流","url":"","summary":"","reference":"","dot":""},{"prefix":"s.on(","tag":"close","suffix":",fn)","desc":"当流或其底层资源（比如文件描述符）被关闭时触发 'close' 事件。 \n该事件表明不会再触发其他事件，也不会再发生操作。","url":"","summary":"","reference":"","dot":""},{"prefix":"s.on(","tag":"error","suffix":",fn)","desc":"发生错误时","url":"","summary":"","reference":"","dot":""}]}]},{"title":"stream.Transform","barcolor":"","fold":false,"box":[{"title":"自定义","fold":false,"list":[{"prefix":"ts = ","tag":"new stream.Transform","suffix":"","desc":"转换流是一种双工流，它会对输入做些计算然后输出。\n```\nconst { Transform } = require('stream');\n\nconst myTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    // ...\n  }\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"ts","tag":"._transform","suffix":"(chunk,encoding,done)","desc":"将读入的chunk进行操作后，最后传递给push。`this.push(newChunk)`\n_transform的回调函数，第一参数可为err，第2个参数将传递给push。\n","url":"","summary":"该方法是用于接受输入并产生输出的一个中转站，该方法内部实现对写入的字节进行操作，然后计算出一个输出，最后将输出使用readable.push()方法传递给可读流。\ncallback函数必须在当前块完全消耗完毕之后调用，如果在处理输入的时候发生错误的时候回调的第一个参数必须是一个Error对象，否则是一个null。如果回调有第二个参数的话，它将会转发给readable.push()。\n```\nconst { Transform } = require(\"stream\");\nclass myTransform extends Transform {\n    constructor(options) {\n        super(options);\n    }\n    _transform(chunk, encoding, done) {\n        const upperChunk = chunk.toString().toUpperCase();\n        this.push(upperChunk);\n        done();\n    }\n    _flush(done) {\n        // this.push(\"end\\n\");\n        done();\n    }\n}\n```","reference":"参考资料|https://juejin.im/entry/59b5539af265da066c22e28a","dot":""},{"prefix":"ts","tag":"._flush","suffix":"(done)","desc":"收尾处理，在finish之前执行。\n_flush的回调函数，第一个参数可为null，第2个参数将传递给push。","url":"","summary":"\n","reference":"","dot":""}]}]},{"title":"stream.Readable","barcolor":"","fold":false,"box":[{"title":"stream.Readable","fold":false,"list":[{"prefix":"rs","tag":".readableFlowing","suffix":"","desc":"+ null 没有提供消费流数据的机制，所以流不会产生数据\n+ false 数据可能会堆积在流的内部缓冲中\n+ true ","url":"","summary":"# 两种模式\n可读流运作于两种模式之一：流动模式（flowing）或暂停模式（paused）。 这些模式与对象模式分开。 无论是否处于流动模式或暂停模式，可读流都可以处于对象模式。\n在流动模式中，数据自动从底层系统读取，并通过 EventEmitter 接口的事件尽可能快地被提供给应用程序。\n在暂停模式中，必须显式调用 stream.read() 读取数据块。\n# 模式切换\n所有可读流都开始于暂停模式\n*切换到流动模式*：\n+ 添加 'data' 事件句柄。\n+ 调用 stream.resume() 方法。\n+ 调用 stream.pipe() 方法将数据发送到可写流。\n\n*切换回暂停模式*：\n+ 如果没有管道目标，则调用 stream.pause()。\n+ 如果有管道目标，则移除所有管道目标。调用 stream.unpipe() 可以移除多个管道目标。\n# 补充说明\n只有提供了消费或忽略数据的机制后，可读流才会产生数据。 如果消费的机制被禁用或移除，则可读流会停止产生数据。\n\n为了向后兼容，移除 'data' 事件句柄不会自动地暂停流。 如果有管道目标，一旦目标变为 drain 状态并请求接收数据时，则调用 stream.pause() 也不能保证流会保持暂停模式。\n\n如果可读流切换到流动模式，且没有可用的消费者来处理数据，则数据将会丢失。 例如，当调用 readable.resume() 时，没有监听 'data' 事件或 'data' 事件句柄已移除。\n\n添加 'readable' 事件句柄会使流自动停止流动，并通过 readable.read() 消费数据。 如果 'readable' 事件句柄被移除，且存在 'data' 事件句柄，则流会再次开始流动。","reference":"","dot":""},{"prefix":"rs","tag":".setEncoding","suffix":"(encoding)","desc":"为从可读流读取的数据设置字符编码\n默认情况下没有设置字符编码，流数据返回的是 Buffer 对象。 如果设置了字符编码，则流数据返回指定编码的字符串。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".readableHighWaterMark","suffix":"","desc":"默认16KB","url":"","summary":"","reference":"","dot":""}]},{"title":"纯手动","fold":false,"list":[{"prefix":"rs.on(","tag":"readable","suffix":",fn)","desc":"当有数据可从流中读取时，就会触发 'readable' 事件。 \n在某些情况下，为 'readable' 事件附加监听器将会导致将一些数据读入内部缓冲区\n```\nreadable.on('readable', function() {\n  // 有数据可读取。\n  let data;\n\n  while (data = this.read()) {\n    console.log(data);\n  }\n});\n```","url":"","summary":"当到达流数据的尽头时， 'readable' 事件也会触发，但是在 'end' 事件之前触发。\n'readable' 事件表明流有新的动态：要么有新的数据，要么到达流的尽头。 对于前者，stream.read() 会返回可用的数据。 对于后者，stream.read() 会返回 null。","reference":"","dot":""},{"prefix":"rs","tag":".read","suffix":"([size])","desc":"从内部缓冲拉取并返回数据。size指定要读取的数据的字节数。\n如果没有可读的数据，则返回 null。 \n默认情况下， readable.read() 返回的数据是 Buffer 对象，除非使用 readable.setEncoding() 指定字符编码或流处于对象模式。\n```\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    console.log(`接收到 ${chunk.length} 字节的数据`);\n  }\n});\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"可调节","fold":false,"list":[{"prefix":"rs.on(","tag":"data","suffix":",fn(chunk))","desc":"当流将数据块传送给消费者后触发\n将 'data' 事件监听器附加到尚未显式暂停的流将会使流切换为流动模式。 数据将会在可用时立即传递。\n```\nreadable.on('data', (chunk) => {\n  console.log(`接收到 ${chunk.length} 个字节的数据`);\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".pause()","suffix":"","desc":"使流动模式的流停止触发 'data' 事件，并切换出流动模式。\n任何可用的数据都会保留在内部缓存中。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs.on(","tag":"pause","suffix":",fn)","desc":"当调用 stream.pause() 并且 readsFlowing 不为 false 时，就会触发 'pause' 事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".resume()","suffix":"","desc":"将被暂停的可读流恢复触发 'data' 事件，并将流切换到流动模式。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs.on(","tag":"resume","suffix":",fn)","desc":"当调用 stream.resume() 并且 readsFlowing 不为 true 时，将会触发 'resume' 事件","url":"","summary":"","reference":"","dot":""}]},{"title":"读取完毕","fold":false,"list":[{"prefix":"rs.on(","tag":"end","suffix":",fn)","desc":"当流中没有数据可供消费时触发。\n'end' 事件只有在数据被完全消费掉后才会触发。 ","url":"","summary":"","reference":"","dot":""}]},{"title":"自定义","fold":false,"list":[{"prefix":"rs = ","tag":"new stream.Readable","suffix":"","desc":"创建一个readable流\n```\nconst { Readable } = require('stream');\n\nconst myReadable = new Readable({\n  read(size) {\n    // ...\n  }\n});\n```","url":"","summary":"","reference":"参考资料|http://nodejs.cn/api/stream.html#stream_new_stream_readable_options","dot":""},{"prefix":"rs","tag":"._read","suffix":"([size])","desc":"自定义按需读取","url":"","summary":"","reference":"参考资料|https://github.com/jabez128/stream-handbook","dot":""},{"prefix":"rs","tag":".push","suffix":"(chunk,[encoding])","desc":"当 chunk 是 Buffer、 Uint8Array 或 string 时， chunk 的数据会被添加到内部队列中供流消费。 \n在没有数据可写入后，给 chunk 传入 **null** 表示流的结束（EOF）。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"stream.Readable.from","suffix":"(ite)","desc":"一个从迭代器中创建可读流的实用方法","url":"","summary":"```\nconst { Readable } = require('stream');\n\nasync function * generate() {\n  yield 'hello';\n  yield 'streams';\n}\n\nconst readable = Readable.from(generate());\n\nreadable.on('data', (chunk) => {\n  console.log(chunk);\n});\n```","reference":"","dot":""}]}]},{"title":"stream.Writable","barcolor":"","fold":false,"box":[{"title":"stream.Writable","fold":false,"list":[{"prefix":"ws","tag":".setDefaultEncoding","suffix":"(encoding)","desc":"为可写流设置默认的 encoding","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":".writableHighWaterMark","suffix":"","desc":"默认16KB","url":"","summary":"","reference":"","dot":""}]},{"title":"写入中","fold":false,"list":[{"prefix":"ws","tag":".write","suffix":"(chunk,[encoding,callback])","desc":"`writable.write(chunk[, encoding][, callback])`\n写入数据到流，并在数据被完全处理之后调用 callback。 \n在接收了 chunk 后，如果内部的缓冲小于创建流时配置的 highWaterMark，则返回 true 。 如果返回 false ，则应该停止向流写入数据，直到 'drain' 事件被触发。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"drain","suffix":",fn)","desc":"writable.write(chunk)返回false以后，当缓存数据全部写入完成，可以继续写入时，会触发drain事件，表示缓存空了。","url":"","summary":"","reference":"","dot":""}]},{"title":"写入完","fold":false,"list":[{"prefix":"ws","tag":".end","suffix":"([chunk,encoding,callback])","desc":"`writable.end([chunk[, encoding]][, callback])`\n表明已没有数据要被写入可写流。 \n可选的 chunk 和 encoding 参数可以在关闭流之前再写入一块数据。 \n如果传入了 callback 函数，则会做为监听器添加到 'finish' 事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"finish","suffix":",fn)","desc":"缓冲数据都已传给底层系统之后触发","url":"","summary":"","reference":"","dot":""}]},{"title":"自定义","fold":false,"list":[{"prefix":"ws = ","tag":"new stream.Writable","suffix":"","desc":"创建一个可写流\n```\nconst { Writable } = require('stream');\n\nconst myWritable = new Writable({\n  write(chunk, encoding, callback) {\n    // ...\n  },\n  writev(chunks, callback) {\n    // ...\n  }\n});\n```","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/stream.html#stream_constructor_new_stream_writable_options","dot":""},{"prefix":"ws","tag":"._write","suffix":"(chunk,encoding,callback)","desc":"所有可写流的实现必须提供 writable.\\_write() 和/或 writable.\\_writev() 方法将数据发送到底层资源。\n`writable._writev(chunks, callback)` 一次处理多个数据块","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":"._final","suffix":"(callback)","desc":"当结束写入所有剩余数据时的回调函数\n该方法会在流关闭之前被调用，且在 callback 被调用后触发 'finish' 事件。 主要用于在流结束之前关闭资源或写入缓冲的数据。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"path","barcolor":"","fold":false,"box":[{"title":"全局变量","fold":false,"list":[{"prefix":"","tag":"__filename","suffix":"","desc":"指向当前运行的脚本文件名","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"__dirname","suffix":"","desc":"指向当前运行的脚本所在的目录","url":"","summary":"","reference":"","dot":""}]},{"title":"生成","fold":false,"list":[{"prefix":"path","tag":".resolve","suffix":"([...paths])","desc":"将路径或路径片段的序列解析为绝对路径","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".join","suffix":"([...paths])","desc":"使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。","url":"","summary":"零长度的 path 片段会被忽略。 如果连接的路径字符串是零长度的字符串，则返回 '.'，表示当前工作目录","reference":"","dot":""},{"prefix":"path","tag":".normalize","suffix":"(path)","desc":"规范化给定的 path","url":"","summary":"","reference":"","dot":""}]},{"title":"分析","fold":false,"list":[{"prefix":"path","tag":".parse","suffix":"(path)","desc":"返回一个对象，其属性表示 path 的重要元素。 尾部的目录分隔符将被忽略，\n```\npath.parse('/home/user/dir/file.txt');\n// 返回:\n// { root: '/',\n//   dir: '/home/user/dir',\n//   base: 'file.txt',\n//   ext: '.txt',\n//   name: 'file' \n```","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".format","suffix":"(obj)","desc":"从对象返回路径字符串,path逆方法\ndir和root只需一个\nbase和name+ext只需一个","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/path.html#path_path_format_pathobject","dot":""},{"prefix":"path","tag":".isAbsolute","suffix":"(path)","desc":"检测 path 是否为绝对路径。","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".relative","suffix":"(from, to)","desc":"根据当前工作目录返回 from 到 to 的相对路径。 ","url":"","summary":"","reference":"","dot":""}]},{"title":"信息","fold":false,"list":[{"prefix":"path","tag":".dirname","suffix":"(path)","desc":"返回 path 的目录名，类似于 Unix 的 dirname 命令。 尾部的目录分隔符将被忽略\n```\npath.dirname('/foo/bar/baz/asdf/quux');\n// 返回: '/foo/bar/baz/asdf'\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".basename","suffix":"(path,[ext])","desc":"返回 path 的最后一部分，类似于 Unix 的 basename 命令。\n尾部的目录分隔符将被忽略\n```javascript\npath.basename('/foo/bar/baz/asdf/quux.html');\n// 返回: 'quux.html'\npath.basename('/foo/bar/baz/asdf/quux.html', '.html');\n// 返回: 'quux'\n```","url":"","summary":"","reference":"","dot":"","title":"其它"},{"prefix":"path","tag":".extname","suffix":"(path)","desc":"返回 path 的扩展名\n从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束。 如果在 path 的最后一部分中没有 . ，或者如果 path 的基本名称（参阅 path.basename()）除了第一个字符以外没有 .，则返回空字符串。","url":"","summary":"","reference":"","dot":""}]},{"title":"其它","fold":true,"list":[{"prefix":"path","tag":".delimiter","suffix":"","desc":"提供平台特定的路径定界符：\n; 用于 Windows\n: 用于 POSIX","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".sep","suffix":"","desc":"提供平台特定的路径片段分隔符：\nWindows 上是 \\。\nPOSIX 上是 /。","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".win32","suffix":"","desc":"提供对特定于 Windows 的 path 方法的实现的访问。","url":"","summary":"","reference":"","dot":""},{"prefix":"path","tag":".posix","suffix":"","desc":"提供对 path 方法的 POSIX 特定实现的访问","url":"","summary":"","reference":"","dot":""}]}]},{"title":"目录","barcolor":"","fold":false,"box":[{"title":"检查","fold":false,"list":[{"prefix":"fs","tag":".existsSync","suffix":"(path)","desc":"如果路径存在，则返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""}]},{"title":"移动","fold":false,"list":[{"prefix":"fse","tag":".move","suffix":"(src,dest,fn)","desc":"移动内容，默认不覆盖\n```\nfs.move(srcpath, dstpath)\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/move.md","summary":"","reference":"","dot":""}]},{"title":"创建","fold":false,"list":[{"prefix":"fs","tag":".mkdir","suffix":"(path,fn)","desc":"创建目录,如已存在会失败\n同步方法：`fs.mkdirSync(path[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_mkdir_path_options_callback","dot":""},{"prefix":"fs","tag":".mkdtemp","suffix":"(prefix,fn)","desc":"创建一个唯一的临时目录。\n同步方法：`fs.mkdtempSync(prefix[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_mkdtemp_prefix_options_callback","dot":""}]},{"title":"删除","fold":false,"list":[{"prefix":"fs","tag":".rmdir","suffix":"(path,[opt],fn)","desc":"删除目录\n同步方法：`fs.rmdirSync(path[, options])`\nopt.recursive 如果为 true，则执行递归的目录删除。在递归模式中，如果 path 不存在则不报告错误，并且在失败时重试操作。默认值: false。","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_rmdir_path_options_callback","dot":""},{"prefix":"fse","tag":".remove","suffix":"(path)","desc":"递归删除文件和目录\n```\nfs.remove('/tmp/myfile')\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/remove.md","summary":"","reference":"","dot":""},{"prefix":"fse","tag":".emptyDir","suffix":"(dir)","desc":"递归清空目录\n```\nfs.emptyDir('/tmp/some/dir')\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"读取","fold":false,"list":[{"prefix":"fs","tag":".readdir","suffix":"(path,fn)","desc":"读取目录的内容\n同步方法：`fs.readdirSync(path[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_readdir_path_options_callback","dot":""},{"prefix":"fs","tag":".opendir","suffix":"(path,fn)","desc":"打开目录\n同步方法：`fs.opendirSync(path[, options])`","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_opendir_path_options_callback","dot":""},{"prefix":"","tag":"glob","suffix":"(**/*.js,fn(err,files))","desc":"选择glob规则指定文件\n```\nvar glob = require(\"glob\")\nglob(\"**/*.js\", options, function (er, files) {\n  // files is an array of filenames.\n})\n```","url":"","summary":"","reference":"参考资料|https://www.npmjs.com/package/glob","dot":""}]}]}]},{"column":[{"title":"fs","barcolor":"","fold":false,"box":[{"title":"读取","fold":false,"list":[{"prefix":"fs","tag":".createReadStream","suffix":"(path,opt)","desc":"按流读取，highWaterMark为64KB。","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_createreadstream_path_options","dot":""},{"prefix":"fs","tag":".readFile","suffix":"(path,encoding,fn)","desc":"异步地读取文件的全部内容。（会缓冲整个文件）\n同步方法： `fs.readFileSync(path,opt);`\n","url":"","summary":"+ path：可以为文件名或文件描述符\n+ encoding：如果没有指定 encoding，则返回原始的 buffer。\n```\nfs.readFile('/etc/passwd', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n```","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_readfile_path_options_callback","dot":""},{"prefix":"fs","tag":".copyFile","suffix":"(src,dest,fn)","desc":"复制文件。如果已存在，则覆盖它。\n同步方法：`fs.copyFileSync(src, dest[, flags])`","url":"","summary":"","reference":"","dot":""},{"prefix":"fse","tag":".copy","suffix":"(src,dest)","desc":"递归拷贝\n```\nconst fs = require('fs-extra')\nfs.copy('/tmp/myfile', '/tmp/mynewfile')\n.then(() => {\n  console.log('success!')\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/copy.md","summary":"","reference":"","dot":""}]},{"title":"写入","fold":false,"list":[{"prefix":"fs","tag":".createWriteStream","suffix":"(path,opt)","desc":"创建可写流","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_createwritestream_path_options","dot":""},{"prefix":"fs","tag":".writeFile","suffix":"(file,data,fn)","desc":"异步地将数据写入到一个文件，如果文件已存在则覆盖该文件。\n同步方法：`fs.writeFileSync(file, data[, options])`","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_writefile_file_data_options_callback","dot":""},{"prefix":"fs","tag":".appendFile","suffix":"(path,data,fn)","desc":"异步地将数据追加到文件，如果文件尚不存在则创建该文件。data 可以是字符串或 Buffer。\n同步方法：`fs.appendFileSync(path, data[, options])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_appendfile_path_data_options_callback","dot":""},{"prefix":"fse","tag":".outputFile","suffix":"(file,data)","desc":"写入文件，如果不存在，自动创建\n导出json，`fs.outputJson(file, object[, options][, callback])` \n```\nfs.outputFile(file, 'hello!')\n.then(() => fs.readFile(file, 'utf8'))\n.then(data => {\n  console.log(data) // => hello!\n})\n.catch(err => {\n  console.error(err)\n})\n```","url":"https://github.com/jprichardson/node-fs-extra/blob/master/docs/outputFile.md","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".truncate","suffix":"(path,len,fn)","desc":"截断文件内容,len指定保留的长度（字节数）\n同步方法：`fs.truncateSync(path[, len])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_truncate_path_len_callback","dot":""}]},{"title":"监听","fold":false,"list":[{"prefix":"fs","tag":".watch","suffix":"(path,fn)","desc":"监视 filename 的更改，其中 filename 是文件或目录","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_watch_filename_options_listener","dot":""},{"prefix":"fs","tag":".watchFile","suffix":"(file,fn)","desc":"监视 filename 的更改。","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_watchfile_filename_options_listener","dot":""},{"prefix":"fs","tag":".unwatchFile","suffix":"(file,fn)","desc":"停止监视 filename 的变化","url":"","summary":"","reference":"","dot":""},{"prefix":"watcher.on(","tag":"change","suffix":",fn)","desc":"+ change 当监视的目录或文件中发生更改时触发\n+ error 当监视文件时发生错误时触发\n+ close 当监视器停止监视更改时触发","url":"","summary":"","reference":"","dot":""},{"prefix":"watcher","tag":".close()","suffix":"","desc":"给定的 fs.FSWatcher 停止监视更改。 一旦停止，则 fs.FSWatcher 对象将不再可用。","url":"","summary":"","reference":"","dot":""}]},{"title":"开关","fold":false,"list":[{"prefix":"fd","tag":" ","suffix":"","desc":"在 POSIX 系统上，对于每个进程，内核都维护着一张当前打开着的文件和资源的表格。 每个打开的文件都分配了一个称为文件描述符的简单的数字标识符。 在系统层，所有文件系统操作都使用这些文件描述符来标识和跟踪每个特定的文件。 Windows 系统使用了一个虽然不同但概念上类似的机制来跟踪资源。 为了简化用户的工作，Node.js 抽象出操作系统之间的特定差异，并为所有打开的文件分配一个数字型的文件描述符。\n大多数操作系统限制在任何给定时间内可能打开的文件描述符的数量，因此当操作完成时关闭描述符至关重要。 如果不这样做将导致内存泄漏，最终导致应用程序崩溃。","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".open","suffix":"(path,fn(err,fd))","desc":"打开文件\n同步方法：`fs.openSync(path[, flags, mode])`","url":"","summary":"<table class=\"reference\">\n<tbody><tr><th>Flag</th><th>描述</th></tr>\n<tr><td>r</td><td>以读取模式打开文件。如果文件不存在抛出异常。</td></tr>\n<tr><td>r+</td><td> 以读写模式打开文件。如果文件不存在抛出异常。</td></tr>\n<tr><td>rs</td><td>以同步的方式读取文件。</td></tr>\n<tr><td>rs+</td><td>以同步的方式读取和写入文件。</td></tr>\n<tr><td>w</td><td>以写入模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>wx</td><td>类似 'w'，但是如果文件路径存在，则文件写入失败。</td></tr>\n<tr><td>w+</td><td>以读写模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>wx+</td><td>类似 'w+'， 但是如果文件路径存在，则文件读写失败。</td></tr>\n<tr><td>a</td><td>以追加模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>ax</td><td>类似 'a'， 但是如果文件路径存在，则文件追加失败。</td></tr>\n<tr><td>a+</td><td>以读取追加模式打开文件，如果文件不存在则创建。</td></tr>\n<tr><td>ax+</td><td>类似 'a+'， 但是如果文件路径存在，则文件读取追加失败。</td></tr>\n</tbody></table>","reference":"","dot":""},{"prefix":"fs","tag":".read","suffix":"(fd,buffer,offset,length,position)","desc":"从 fd 指定的文件中读取数据\n同步方法：`fs.readSync(fd, buffer, offset, length, position)`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback","dot":""},{"prefix":"fs","tag":".write","suffix":"(fd,data,fn)","desc":"将 buffer 写入到 fd 指定的文件。\n`fs.write(fd, buffer[, offset[, length[, position]]], callback)`\n`fs.write(fd, string[, position[, encoding]], callback)`\n同步方法：\n`fs.writeSync(fd, buffer[, offset[, length[, position]]])`\n`fs.writeSync(fd, string[, position[, encoding]])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_write_fd_buffer_offset_length_position_callback","dot":""},{"prefix":"fs","tag":".writev","suffix":"(fd,buffers,fn)","desc":"使用 writev() 将一个 ArrayBufferView 数组写入 fd 指定的文件。\n同步方法：`fs.writevSync(fd, buffers[, position])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_writev_fd_buffers_position_callback","dot":""},{"prefix":"fs","tag":".close","suffix":"(fd,fn)","desc":"关闭文件\n同步方法：`fs.closeSync(fd)`","url":"","summary":"","reference":"","dot":""}]},{"title":"链接","fold":false,"list":[{"prefix":"link","tag":" ","suffix":"","desc":"# inode\n我们首先来看看 linux 系统里面的一个重要概念：inode。\n\n我们知道，文件存储在硬盘上，硬盘存储的最小单位是扇区（sector，每个扇区 512 B）。而操作系统读取文件时，按块读取（连续的多个扇区），也就是说文件存取的最小单位是块（block，块通常是 4 KB）。\n\n除了文件数据，我们还必须存储文件的元信息（如：文件大小、文件创建者、文件数据的块位置、文件读/写/执行权限、文件时间戳等等），这种存储文件元信息的结构就称为 inode。\n\n每个 inode 都有一个唯一的号码标志，linux 系统内部使用 inode 的号码来识别文件，并不使用文件名。我们打开一个文件时，系统首先找到文件名对应的 inode 号码，然后通过 inode 号码获取 inode 信息，最后根据 inode 信息中的文件数据所在的 block 读出数据。\n\n实际上，在 linux 系统中，目录也是一种文件。目录文件包含一系列目录项，每个目录项由两部分组成：所包含文件的文件名，以及该文件名对应的 inode 号码。我们可以使用 ls -i 来列出目录中的文件以及它们的 inode 号码。这其实也解释了仅更改目录的读权限，并不能实现读取目录下所有文件内容的原因，通常需要 chmod -R 来进行递归更改。\n\n总结下：\n\n硬盘存取的最小单位是扇区，文件存取的最小单位是块（连续的扇区）\n存储文件元信息（文件大小、创建者、块位置、时间戳、权限等非数据信息）的结构称为 inode\n每个 inode 拥有一个唯一号码，系统内部通过它来识别文件\n目录也是一种文件，其内容包含一系列目录项（每个目录项由文件的文件名和文件对应的 inode 号码组成）","url":"","summary":"# 硬链接\n一般情况，一个文件名“唯一”对应一个 inode。但是，linux 允许多个文件名都指向同一个 inode。这表示我们可以使用不同的文件名访问同样的内容；对文件内容进行修改将“反映”到所有文件；删除一个文件不影响另一个文件的访问 。这种机制就被称为“硬链接”。\n\n# 软链接\n软链接\n软链接类似于 windows 中的”快捷方式“。两个文件虽然 inode 号码不一样，但是文件 A 内部会指向文件 B 的 inode。当我们读取文件 A 时，系统就自动导向文件 B，文件 A 就是文件 B 的软链接（或者叫符号链接）。这表示我们同样可以使用不同的文件名访问同样的内容；对文件内容修改将”反映“到所有文件。但是当我们删除掉源文件 B 时，再访问文件 A 时会报错 “No such file or directory”。","reference":"参考资料|https://kohpoll.github.io/blog/2016/05/30/hardlink-symlink-require-in-nodejs/","dot":""},{"prefix":"fs","tag":".link","suffix":"(old,new,fn)","desc":"创建硬链接\n同步方法：`fs.linkSync(existingPath, newPath)`","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".unlink","suffix":"(path,fn)","desc":"异步地删除文件或符号链接。\n同步方法：`fs.unlinkSync(path)`","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".readlink","suffix":"(path,encoding,fn)","desc":"异步读取链接\n同步方法：`fs.readlinkSync(path[, options])` ","url":"","summary":"","reference":"官方文档|http://nodejs.cn/api/fs.html#fs_fs_readlink_path_options_callback","dot":""},{"prefix":"fs","tag":".symlink","suffix":"(target,path,fn)","desc":"软链接。创建名为 path 的链接，该链接指向 target。\n同步方法：`fs.symlinkSync(target, path[, type])`","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_fs_symlink_target_path_type_callback","dot":""}]},{"title":"权限","fold":false,"list":[{"prefix":"fs","tag":".chmod","suffix":"(path,mode,fn)","desc":"异步地更改文件的权限，0o<所有者7><群组6><其他人5>\n同步方法：`fs.chmodSync(path, mode)`\n强制执行：`fs.fchmod(fd, mode, callback)`\nMacOS：`fs.lchmod(path, mode, callback)`","url":"","summary":"权限数字\n<table><thead><tr><th>数字</th><th>说明</th></tr></thead><tbody><tr><td><code>7</code></td><td>可读、可写、可执行</td></tr><tr><td><code>6</code></td><td>可读、可写</td></tr><tr><td><code>5</code></td><td>可读、可执行</td></tr><tr><td><code>4</code></td><td>只读</td></tr><tr><td><code>3</code></td><td>可写、可执行</td></tr><tr><td><code>2</code></td><td>只写</td></tr><tr><td><code>1</code></td><td>只可执行</td></tr><tr><td><code>0</code></td><td>没有权限</td></tr></tbody></table>\n构造 mode 更简单的方法是使用三个八进制数字的序列（ 例如 765）。 最左边的数字（示例中的 7）指定文件所有者的权限。 中间的数字（示例中的 6）指定群组的权限。 最右边的数字（示例中的 5）指定其他人的权限。\n例如，八进制值 0o765 表示：\n所有者可以读取、写入和执行该文件。\n群组可以读和写入该文件。\n其他人可以读取和执行该文件。\n注意事项：在 Windows 上，只能更改写入权限，并且不会实现群组、所有者或其他人的权限之间的区别。","reference":"","dot":""},{"prefix":"fs","tag":".chown","suffix":"(path,uid,gid,fn)","desc":"异步地更改文件的所有者和群组\n同步方法：`fs.chownSync(path, uid, gid)`\n强制执行：`fs.fchown(fd, uid, gid, callback)`\nMacOS：`fs.lchown(path, uid, gid, callback)`","url":"","summary":"","reference":"","dot":""}]},{"title":"杂项","fold":false,"list":[{"prefix":"fs","tag":".stat","suffix":"(path,fn(err,stats))","desc":"同步方法：`fs.statSync(path[, options])`\nstats.isDirectory() 是否为目录\nstats.isFile() 是否为常规文件\nstats.isSocket() 是否为套接字\nstats.isSymbolicLink() 是否为软链接","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/fs.html#fs_class_fs_stats","dot":""},{"prefix":"fs","tag":".rename","suffix":"(old,new,fn)","desc":"文件重命名。如果 newPath 已存在，则覆盖它。\n同步方法：`fs.renameSync(oldPath, newPath)`","url":"","summary":"","reference":"","dot":""},{"prefix":"fs","tag":".utimes","suffix":"(path,atime,mtime,fn)","desc":"更改 path 指向的对象的文件系统时间戳。\n同步方法：`fs.utimesSync(path, atime, mtime)`","url":"","summary":"atime 和 mtime 参数遵循以下规则：\n值可以是表示 Unix 纪元时间的数字、 Date 对象、或类似 '123456789.0' 的数值字符串。\n如果该值无法转换为数值、或值为 NaN、 Infinity 或 -Infinity，则抛出错误。","reference":"","dot":""}]}]},{"title":"python","barcolor":"","fold":false,"box":[{"title":"python","fold":false,"list":[{"prefix":"","tag":"open","suffix":"(file,flag)","desc":"`f = open('/Users/michael/test.txt', 'w')`","url":"https://www.runoob.com/python3/python3-file-methods.html","summary":"","reference":"","dot":""},{"prefix":"f","tag":".write","suffix":"(data)","desc":"`f.write('Hello, world!')`","url":"","summary":"","reference":"","dot":""},{"prefix":"f","tag":".close()","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"crypto","barcolor":"","fold":false,"box":[]},{"title":"zlib","barcolor":"","fold":false,"box":[]}]},{"column":[{"title":"OS","barcolor":"","fold":false,"box":[{"title":"python","fold":false,"list":[{"prefix":"","tag":"id","suffix":"(obj)","desc":"函数用于获取对象内存地址","url":"","summary":"","reference":"","dot":""}]}]},{"title":"I/O","barcolor":"","fold":false,"box":[{"title":"node","fold":false,"list":[{"prefix":"","tag":"readline","suffix":"","desc":"","url":"https://segmentfault.com/a/1190000015271621","summary":"","reference":"","dot":""}]},{"title":"python","fold":false,"list":[{"prefix":"","tag":"input","suffix":"(msg)","desc":"等待用户输入","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"print","suffix":"(val,..)","desc":"print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=\"\"","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"process","barcolor":"","fold":false,"box":[]}]}]}