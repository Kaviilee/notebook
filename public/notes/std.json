{"version":1584764487902,"name":"git","data":[{"column":[{"title":"Buffer","barcolor":"","fold":false,"box":[{"title":"创建","fold":false,"list":[{"prefix":"","tag":"Buffer.from","suffix":"(str,encoding)","desc":"Buffer 实例也是 Uint8Array 实例，长度1为1个字节（8位）\n+ Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）\n+ Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。\n+ Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例\n+ Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"Buffer.alloc","suffix":"(size)","desc":"+ Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0\n+ Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据\n+ Buffer.allocUnsafeSlow(size)","url":"","summary":"","reference":"","dot":""}]},{"title":"读取","fold":false,"list":[{"prefix":"buf","tag":"[i]","suffix":"","desc":"获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".length","suffix":"","desc":"返回 Buffer 对象所占据的内存长度。(字节数）\n`Buffer.byteLength(buf)`","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"<encoding>","suffix":"","desc":"# nodejs默认内置字符编码\n+ ascii \n仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。\n+ utf-8\n多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。\n+ hex \n将每个字节编码为两个十六进制字符（1字节=8位=2个4位,2^4=16）\n+ base64\nMIME编码的一种\n+ latin1/binary \n一种把 Buffer 编码成一字节编码的字符串的方式,ISO-8859-1的别名\n+ utf16le/ucs2 \n2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。","url":"","summary":"# ascii\n作用：表语英语及西欧语言。\n位数：ASCII是用7位表示的，能表示128个字符；其扩展使用8位表示，表示256个字符。\n范围：ASCII从00到7F，扩展从00到FF\n# iso8859-1\n作用：扩展ASCII，表示西欧、希腊语等。\n位数：8位\n范围：从00到FF，兼容ASCII字符集\n# GB2312字符集\n作用：国家简体中文字符集，兼容ASCII。\n位数：使用2个字节表示，能表示7445个符号，包括6763个汉字，几乎覆盖所有高频率汉字。\n范围：高字节从A1到F7, 低字节从A1到FE。将高字节和低字节分别加上0XA0即可得到编码。\n# GBK字符集\n作用：它是GB2312的扩展，加入对繁体字的支持，兼容GB2312。\n位数：使用2个字节表示，可表示21886个字符。\n范围：高字节从81到FE，低字节从40到FE。\n# BIG5字符集\n作用：它解决了中文、日文、朝鲜语等的编码，兼容GBK。\n位数：它采用变字节表示(1 ASCII，2，4字节)。可表示27484个文字。\n范围：1字节从00到7F; 2字节高字节从81到FE，低字节从40到7E和80到FE；4字节第一三字节从81到FE，第二四字节从30到39。\n# UTF-8/UTF-32/UTF-16/UTF-7\n作用：为世界650种语言进行统一编码，兼容ISO-8859-1。\n位数：UNICODE字符集有多个编码方式，分别是UTF-8，UTF-16和UTF-32。","reference":"参考资料1|https://www.cnblogs.com/happyday56/p/4135845.html\n参考资料2|https://dailc.github.io/2017/06/03/utf8ToUtf16ToGbk.html","dot":""},{"prefix":"buf","tag":".toString","suffix":"([encoding])","desc":"解码缓冲区数据并使用指定的编码返回字符串。\n`buf.toString([encoding[, start[, end]]])`\nencoding - 使用的编码。默认为 'utf8' 。\nstart - 指定开始读取的索引位置，默认为 0。\nend - 结束位置，默认为缓冲区的末尾。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"iconv-lite","suffix":"","desc":"包括gbk在内的更多编码支持\n```javascript\nvar iconv = require('iconv-lite');\n \n// Convert from an encoded buffer to js string.\nstr = iconv.decode(Buffer.from([0x68, 0x65, 0x6c, 0x6c, 0x6f]), 'win1251');\n \n// Convert from js string to an encoded buffer.\nbuf = iconv.encode(\"Sample input string\", 'win1251');\n \n// Check if encoding is supported\niconv.encodingExists(\"us-ascii\")\n```","url":"https://www.npmjs.com/package/iconv-lite","summary":"","reference":"","dot":""}]},{"title":"操作","fold":false,"list":[{"prefix":"buf","tag":".write","suffix":"(str)","desc":"返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。\n`buf.write(string[, offset[, length]][, encoding])`\nstring - 写入缓冲区的字符串。\noffset - 缓冲区开始写入的索引值，默认为 0 。\nlength - 写入的字节数，默认为 buffer.length\nencoding - 使用的编码。默认为 'utf8' 。","url":"","summary":"buf.writeBigInt64BE(value[, offset])\nbuf.writeBigInt64LE(value[, offset])\nbuf.writeBigUInt64BE(value[, offset])\nbuf.writeBigUInt64LE(value[, offset])\nbuf.writeDoubleBE(value[, offset])\nbuf.writeDoubleLE(value[, offset])\nbuf.writeFloatBE(value[, offset])\nbuf.writeFloatLE(value[, offset])\nbuf.writeInt8(value[, offset])\nbuf.writeInt16BE(value[, offset])\nbuf.writeInt16LE(value[, offset])\nbuf.writeInt32BE(value[, offset])\nbuf.writeInt32LE(value[, offset])\nbuf.writeIntBE(value, offset, byteLength)\nbuf.writeIntLE(value, offset, byteLength)\nbuf.writeUInt8(value[, offset])\nbuf.writeUInt16BE(value[, offset])\nbuf.writeUInt16LE(value[, offset])\nbuf.writeUInt32BE(value[, offset])\nbuf.writeUInt32LE(value[, offset])\nbuf.writeUIntBE(value, offset, byteLength)\nbuf.writeUIntLE(value, offset, byteLength)","reference":"","dot":""},{"prefix":"","tag":"Buffer.concat","suffix":"([buf1,buf2,..])","desc":"缓冲区合并,返回一个多个成员合并的新 Buffer 对象。\n`Buffer.concat(list[, totalLength])`\nlist - 用于合并的 Buffer 对象数组列表。\ntotalLength - 指定合并后Buffer对象的总长度。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".slice","suffix":"(start,[end])","desc":"`buf.slice([start[, end]])`\n返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf1","tag":".copy","suffix":"(buf2)","desc":"`buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])`\n缓冲区拷贝,没有返回值","url":"","summary":"","reference":"","dot":""},{"prefix":"buf1","tag":".compare","suffix":"(buf2)","desc":"比较两个buffer，返回一个数字，表示 buf 在 otherBuffer 之前(<0)，之后或相同\n`buf.equals(otherBuffer)` 比较两个缓冲区是否相等，如果是返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""},{"prefix":"buf","tag":".fill","suffix":"(val)","desc":"`buf.fill(value[, offset][, end])`\n使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"events","barcolor":"","fold":false,"box":[{"title":"创建实例","fold":false,"list":[{"prefix":"","tag":"new events.EventEmitter()","suffix":"","desc":"","url":"","summary":"","reference":"","dot":""}]},{"title":"添加监听","fold":false,"list":[{"prefix":"emitter","tag":".addListener","suffix":"(evt,fn)","desc":"为指定事件添加一个监听器到监听器数组的尾部。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".on","suffix":"(evt,fn)","desc":"为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数\n不会检查 listener 是否已被添加。 多次调用并传入相同的 eventName 与 listener 会导致 listener 会被添加多次。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".prependListener","suffix":"(evt,fn)","desc":"添加 listener 函数到名为 eventName 的事件的监听器数组的开头。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".once","suffix":"(evt,fn)","desc":"为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".prependOnceListener","suffix":"(evt,fn)","desc":"添加单次监听器 listener 到名为 eventName 的事件的监听器数组的开头。 \n当 eventName 事件下次触发时，监听器会先被移除，然后再调用。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"newListener","suffix":",fn)","desc":"实例在新的监听器被添加到其内部监听器数组之前，会触发自身的 'newListener' 事件。","url":"","summary":"","reference":"","dot":""}]},{"title":"移除监听","fold":false,"list":[{"prefix":"emitter","tag":".removeListener","suffix":"(evt,fn)","desc":"移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。\n最多只会从监听器数组中移除一个监听器。 如果监听器被多次添加到指定 eventName 的监听器数组中，则必须多次调用 removeListener() 才能移除所有实例。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".off","suffix":"(evt,fn)","desc":"emitter.removeListener() 的别名。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".removeAllListeners","suffix":"([evt])","desc":"移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"removeListener","suffix":",fn)","desc":"'removeListener' 事件在 listener 被移除后触发。","url":"","summary":"","reference":"","dot":""}]},{"title":"触发事件","fold":false,"list":[{"prefix":"emitter","tag":".emit","suffix":"(evt,args..)","desc":"按监听器的顺序执行执行每个监听器\n如果事件有注册监听返回 true，否则返回 false。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter.on(","tag":"error","suffix":",fn)","desc":"我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。","url":"","summary":"","reference":"","dot":""}]},{"title":"其它","fold":true,"list":[{"prefix":"emitter","tag":".eventNames()","suffix":"","desc":"返回已注册监听器的事件名数组。 数组中的值为字符串或 Symbol。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".listeners","suffix":"(evt)","desc":"返回指定事件的监听器数组。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".listenerCount","suffix":"(evt)","desc":"返回正在监听的名为 eventName 的事件的监听器的数量。","url":"","summary":"","reference":"","dot":""},{"prefix":"emitter","tag":".setMaxListeners","suffix":"(n)","desc":"默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 \nsetMaxListeners 函数用于提高监听器的默认限制的数量。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"stream","barcolor":"","fold":false,"box":[{"title":"管道全自动","fold":false,"list":[{"prefix":"rs","tag":".pipe","suffix":"(ws,[{end:false}])","desc":"绑定可写流到可读流，将可读流自动切换到流动模式，并将可读流的所有数据推送到绑定的可写流。 数据流会被自动管理，所以即使可读流更快，目标可写流也不会超负荷。\n**返回:目标流的引用**\n默认情况下，当来源可读流触发 'end' 事件时，目标可写流也会调用 stream.end() 结束写入。 若要禁用这种默认行为， end 选项应设为 false，这样目标流就会保持打开\n```\nreader.pipe(writer, { end: false });\nreader.on('end', () => {\n  writer.end('结束');\n});\n```\n如果可读流在处理期间发送错误，则可写流目标不会自动关闭。 如果发生错误，则需要手动关闭每个流以防止内存泄漏。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"pipe","suffix":",fn(rs))","desc":"当在可读流上调用 stream.pipe() 方法时会发出 'pipe' 事件，并将此可写流添加到其目标集","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".unpipe","suffix":"([ws])","desc":"解绑之前使用 stream.pipe() 方法绑定的可写流\n如果没有指定 destination, 则解绑所有管道\n如果指定了 destination, 但它没有建立管道，则不起作用","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"unpipe","suffix":",fn)","desc":"在可读流上调用 stream.unpipe() 方法时会发出 'unpipe'事件，从其目标集中移除此可写流。\n当可读流通过管道流向可写流发生错误时，也会触发此事件。","url":"","summary":"","reference":"","dot":""}]},{"title":"事件","fold":false,"list":[{"prefix":"s","tag":".destroy","suffix":"([error])","desc":"销毁流","url":"","summary":"","reference":"","dot":""},{"prefix":"s.on(","tag":"error","suffix":",fn)","desc":"发生错误时","url":"","summary":"","reference":"","dot":""},{"prefix":"s.on(","tag":"close","suffix":",fn)","desc":"当流或其底层资源（比如文件描述符）被关闭时触发 'close' 事件。 \n该事件表明不会再触发其他事件，也不会再发生操作。","url":"","summary":"","reference":"","dot":""}]}]},{"title":"stream.Transform","barcolor":"","fold":false,"box":[{"title":"自定义","fold":false,"list":[{"prefix":"ts = ","tag":"new stream.Transform","suffix":"","desc":"转换流是一种双工流，它会对输入做些计算然后输出。\n```\nconst { Transform } = require('stream');\n\nconst myTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    // ...\n  }\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"ts","tag":"._transform","suffix":"(chunk,encoding,done)","desc":"将读入的chunk进行操作后，最后传递给push。`this.push(newChunk)`\n_transform的回调函数，第一参数可为err，第2个参数将传递给push。\n","url":"","summary":"该方法是用于接受输入并产生输出的一个中转站，该方法内部实现对写入的字节进行操作，然后计算出一个输出，最后将输出使用readable.push()方法传递给可读流。\ncallback函数必须在当前块完全消耗完毕之后调用，如果在处理输入的时候发生错误的时候回调的第一个参数必须是一个Error对象，否则是一个null。如果回调有第二个参数的话，它将会转发给readable.push()。\n```\nconst { Transform } = require(\"stream\");\nclass myTransform extends Transform {\n    constructor(options) {\n        super(options);\n    }\n    _transform(chunk, encoding, done) {\n        const upperChunk = chunk.toString().toUpperCase();\n        this.push(upperChunk);\n        done();\n    }\n    _flush(done) {\n        // this.push(\"end\\n\");\n        done();\n    }\n}\n```","reference":"参考资料|https://juejin.im/entry/59b5539af265da066c22e28a","dot":""},{"prefix":"ts","tag":"._flush","suffix":"(done)","desc":"收尾处理，在finish之前执行。\n_flush的回调函数，第一个参数可为null，第2个参数将传递给push。","url":"","summary":"\n","reference":"","dot":""}]}]},{"title":"stream.Readable","barcolor":"","fold":false,"box":[{"title":"stream.Readable","fold":false,"list":[{"prefix":"rs","tag":".readableFlowing","suffix":"","desc":"+ null 没有提供消费流数据的机制，所以流不会产生数据\n+ false 数据可能会堆积在流的内部缓冲中\n+ true ","url":"","summary":"# 两种模式\n可读流运作于两种模式之一：流动模式（flowing）或暂停模式（paused）。 这些模式与对象模式分开。 无论是否处于流动模式或暂停模式，可读流都可以处于对象模式。\n在流动模式中，数据自动从底层系统读取，并通过 EventEmitter 接口的事件尽可能快地被提供给应用程序。\n在暂停模式中，必须显式调用 stream.read() 读取数据块。\n# 模式切换\n所有可读流都开始于暂停模式\n*切换到流动模式*：\n+ 添加 'data' 事件句柄。\n+ 调用 stream.resume() 方法。\n+ 调用 stream.pipe() 方法将数据发送到可写流。\n\n*切换回暂停模式*：\n+ 如果没有管道目标，则调用 stream.pause()。\n+ 如果有管道目标，则移除所有管道目标。调用 stream.unpipe() 可以移除多个管道目标。\n# 补充说明\n只有提供了消费或忽略数据的机制后，可读流才会产生数据。 如果消费的机制被禁用或移除，则可读流会停止产生数据。\n\n为了向后兼容，移除 'data' 事件句柄不会自动地暂停流。 如果有管道目标，一旦目标变为 drain 状态并请求接收数据时，则调用 stream.pause() 也不能保证流会保持暂停模式。\n\n如果可读流切换到流动模式，且没有可用的消费者来处理数据，则数据将会丢失。 例如，当调用 readable.resume() 时，没有监听 'data' 事件或 'data' 事件句柄已移除。\n\n添加 'readable' 事件句柄会使流自动停止流动，并通过 readable.read() 消费数据。 如果 'readable' 事件句柄被移除，且存在 'data' 事件句柄，则流会再次开始流动。","reference":"","dot":""},{"prefix":"rs","tag":".setEncoding","suffix":"(encoding)","desc":"为从可读流读取的数据设置字符编码\n默认情况下没有设置字符编码，流数据返回的是 Buffer 对象。 如果设置了字符编码，则流数据返回指定编码的字符串。","url":"","summary":"","reference":"","dot":""}]},{"title":"纯手动","fold":false,"list":[{"prefix":"rs.on(","tag":"readable","suffix":",fn)","desc":"当有数据可从流中读取时，就会触发 'readable' 事件。 \n在某些情况下，为 'readable' 事件附加监听器将会导致将一些数据读入内部缓冲区\n```\nreadable.on('readable', function() {\n  // 有数据可读取。\n  let data;\n\n  while (data = this.read()) {\n    console.log(data);\n  }\n});\n```","url":"","summary":"当到达流数据的尽头时， 'readable' 事件也会触发，但是在 'end' 事件之前触发。\n'readable' 事件表明流有新的动态：要么有新的数据，要么到达流的尽头。 对于前者，stream.read() 会返回可用的数据。 对于后者，stream.read() 会返回 null。","reference":"","dot":""},{"prefix":"rs","tag":".read","suffix":"([size])","desc":"从内部缓冲拉取并返回数据。size指定要读取的数据的字节数。\n如果没有可读的数据，则返回 null。 \n默认情况下， readable.read() 返回的数据是 Buffer 对象，除非使用 readable.setEncoding() 指定字符编码或流处于对象模式。\n```\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    console.log(`接收到 ${chunk.length} 字节的数据`);\n  }\n});\n```","url":"","summary":"","reference":"","dot":""}]},{"title":"可调节","fold":false,"list":[{"prefix":"rs.on(","tag":"data","suffix":",fn(chunk))","desc":"当流将数据块传送给消费者后触发\n将 'data' 事件监听器附加到尚未显式暂停的流将会使流切换为流动模式。 数据将会在可用时立即传递。\n```\nreadable.on('data', (chunk) => {\n  console.log(`接收到 ${chunk.length} 个字节的数据`);\n});\n```","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".pause()","suffix":"","desc":"使流动模式的流停止触发 'data' 事件，并切换出流动模式。\n任何可用的数据都会保留在内部缓存中。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs.on(","tag":"pause","suffix":",fn)","desc":"当调用 stream.pause() 并且 readsFlowing 不为 false 时，就会触发 'pause' 事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs","tag":".resume()","suffix":"","desc":"将被暂停的可读流恢复触发 'data' 事件，并将流切换到流动模式。","url":"","summary":"","reference":"","dot":""},{"prefix":"rs.on(","tag":"resume","suffix":",fn)","desc":"当调用 stream.resume() 并且 readsFlowing 不为 true 时，将会触发 'resume' 事件","url":"","summary":"","reference":"","dot":""}]},{"title":"读取完毕","fold":false,"list":[{"prefix":"rs.on(","tag":"end","suffix":",fn)","desc":"当流中没有数据可供消费时触发。\n'end' 事件只有在数据被完全消费掉后才会触发。 ","url":"","summary":"","reference":"","dot":""}]},{"title":"自定义","fold":false,"list":[{"prefix":"rs = ","tag":"new stream.Readable","suffix":"","desc":"创建一个readable流\n```\nconst { Readable } = require('stream');\n\nconst myReadable = new Readable({\n  read(size) {\n    // ...\n  }\n});\n```","url":"","summary":"","reference":"参考资料|http://nodejs.cn/api/stream.html#stream_new_stream_readable_options","dot":""},{"prefix":"rs","tag":"._read","suffix":"([size])","desc":"自定义按需读取","url":"","summary":"","reference":"参考资料|https://github.com/jabez128/stream-handbook","dot":""},{"prefix":"rs","tag":".push","suffix":"(chunk,[encoding])","desc":"当 chunk 是 Buffer、 Uint8Array 或 string 时， chunk 的数据会被添加到内部队列中供流消费。 \n在没有数据可写入后，给 chunk 传入 **null** 表示流的结束（EOF）。","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"stream.Readable.from","suffix":"(ite)","desc":"一个从迭代器中创建可读流的实用方法","url":"","summary":"```\nconst { Readable } = require('stream');\n\nasync function * generate() {\n  yield 'hello';\n  yield 'streams';\n}\n\nconst readable = Readable.from(generate());\n\nreadable.on('data', (chunk) => {\n  console.log(chunk);\n});\n```","reference":"","dot":""}]}]},{"title":"stream.Writable","barcolor":"","fold":false,"box":[{"title":"stream.Writable","fold":false,"list":[{"prefix":"ws","tag":".setDefaultEncoding","suffix":"(encoding)","desc":"为可写流设置默认的 encoding","url":"","summary":"","reference":"","dot":""}]},{"title":"写入中","fold":false,"list":[{"prefix":"ws","tag":".write","suffix":"(chunk,[encoding,callback])","desc":"`writable.write(chunk[, encoding][, callback])`\n写入数据到流，并在数据被完全处理之后调用 callback。 \n在接收了 chunk 后，如果内部的缓冲小于创建流时配置的 highWaterMark，则返回 true 。 如果返回 false ，则应该停止向流写入数据，直到 'drain' 事件被触发。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"drain","suffix":",fn)","desc":"writable.write(chunk)返回false以后，当缓存数据全部写入完成，可以继续写入时，会触发drain事件，表示缓存空了。","url":"","summary":"","reference":"","dot":""}]},{"title":"写入完","fold":false,"list":[{"prefix":"ws","tag":".end","suffix":"([chunk,encoding,callback])","desc":"`writable.end([chunk[, encoding]][, callback])`\n表明已没有数据要被写入可写流。 \n可选的 chunk 和 encoding 参数可以在关闭流之前再写入一块数据。 \n如果传入了 callback 函数，则会做为监听器添加到 'finish' 事件。","url":"","summary":"","reference":"","dot":""},{"prefix":"ws.on(","tag":"finish","suffix":",fn)","desc":"缓冲数据都已传给底层系统之后触发","url":"","summary":"","reference":"","dot":""}]},{"title":"自定义","fold":false,"list":[{"prefix":"ws = ","tag":"new stream.Writable","suffix":"","desc":"创建一个可写流\n```\nconst { Writable } = require('stream');\n\nconst myWritable = new Writable({\n  write(chunk, encoding, callback) {\n    // ...\n  },\n  writev(chunks, callback) {\n    // ...\n  }\n});\n```","url":"","summary":"","reference":"官方手册|http://nodejs.cn/api/stream.html#stream_constructor_new_stream_writable_options","dot":""},{"prefix":"ws","tag":"._write","suffix":"(chunk,encoding,callback)","desc":"所有可写流的实现必须提供 writable.\\_write() 和/或 writable.\\_writev() 方法将数据发送到底层资源。\n`writable._writev(chunks, callback)` 一次处理多个数据块","url":"","summary":"","reference":"","dot":""},{"prefix":"ws","tag":"._final","suffix":"(callback)","desc":"当结束写入所有剩余数据时的回调函数\n该方法会在流关闭之前被调用，且在 callback 被调用后触发 'finish' 事件。 主要用于在流结束之前关闭资源或写入缓冲的数据。","url":"","summary":"","reference":"","dot":""}]}]}]},{"column":[{"title":"fs","barcolor":"","fold":false,"box":[{"title":"全局变量","fold":false,"list":[{"prefix":"","tag":"__filename","suffix":"","desc":"指向当前运行的脚本文件名","url":"","summary":"","reference":"","dot":""},{"prefix":"","tag":"__dirname","suffix":"","desc":"指向当前运行的脚本所在的目录","url":"","summary":"","reference":"","dot":""}]}]},{"title":"zlib","barcolor":"","fold":false,"box":[]},{"title":"readline","barcolor":"","fold":false,"box":[]},{"title":"path","barcolor":"","fold":false,"box":[]}]},{"column":[{"title":"Crypto","barcolor":"","fold":false,"box":[]}]},{"column":[{"title":"OS","barcolor":"","fold":false,"box":[{"title":"内存","fold":false,"list":[{"prefix":"","tag":"id","suffix":"(obj)","desc":"函数用于获取对象内存地址","url":"","summary":"","reference":"","dot":""}]}]},{"title":"I/O","barcolor":"","fold":false,"box":[{"title":"输入","fold":false,"list":[{"prefix":"","tag":"input","suffix":"(msg)","desc":"等待用户输入","url":"","summary":"","reference":"","dot":""}]},{"title":"输出","fold":false,"list":[{"prefix":"","tag":"print","suffix":"(val,..)","desc":"print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=\"\"","url":"","summary":"","reference":"","dot":""}]}]},{"title":"process","barcolor":"","fold":false,"box":[]}]},{"column":[]}]}