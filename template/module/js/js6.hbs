<!-- 标准对象 -->
<div class="u-col">
	<div class="u-block">
        <h3>元编程<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>+</span>]Symbol</h4>
            <ul style="display:none;">
                <li>
                    <a href="">Symbol</a>([des])
                    <span>
                        它是一种类似于字符串的数据类型，但独一无二。 <hr>
                        1.Symbol函数前不能使用new命令，否则会报错 <br>
                        2.Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。 <br>
                        3.Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 <br>
                        4.Symbol 值不能与其他类型的值进行运算 <br>
                        5.Symbol 值可以通过toString或String方法显式转为字符串 <br>
                        6.Symbol 值也可以转为布尔值，但是不能转为数值 <br>
                        7.不能使用.运算符，必须使用[] <br>
                        8.Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。
                    </span>
                </li>
                <li>
                    <a href="">Symbol.for</a>(desc)
                    <span>
                        接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。
                    </span>
                </li>
                <li>
                    <a href="">Symbol.keyfor</a>(symbol)
                    <span>
                        返回一个已登记的 Symbol 类型值的key
                    </span>
                </li>
            </ul>
			<h4>[<span>-</span>]Proxy</h4>
			<ul>
				<li>
					<a href="">new Proxy</a>(target,handler)
					<span>
                        var proxy = new Proxy(target,{handler}) <br>
						在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 <br>
						<a href="http://es6.ruanyifeng.com/#docs/proxy">参考资料</a> <br>
						通过改写return值，可实现链式操作 <hr>
                        当被代理的对象为不同的类型时：<br>
                        对象：target=源对象,key=源对象的属性;<br>
                        数组：target=源数组,key=源数组的索引;<br>
                        函数：target=执行源函数,target[key]=函数源; <br>
					</span>
				</li>
                <li>
					<a href="">Proxy.revocable</a>(target,handler)
					<span>
						返回一个可取消的Proxy实例 <br>
                        let {proxy, revoke} = Proxy.revocable(target, handler); <br>
                        目标对象内部的this关键字会指向 Proxy 代理 <br>
                        Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例 <a href="http://es6.ruanyifeng.com/#docs/proxy#Proxy-revocable">参考资料</a>
					</span>
				</li>
				<li>
					handler.<a href="">get</a><em>(target,key,receiver)</em>
					<span>
						拦截对象属性的读取
					</span>
				</li>
				<li>
					handler.<a href="">set</a><em>(target,key,val,receiver)</em>
					<span>
						拦截对象属性的设置
					</span>
				</li>
				<li>
					handler.<a href="">has</a><em>(target,key)</em>
					<span>
						拦截propKey in proxy的操作，返回一个布尔值。
					</span>
				</li>
				<li>
					handler.<a href="">deleteProperty</a><em>(target,key)</em>
					<span>
						拦截delete proxy[propKey]的操作，返回一个布尔值。
					</span>
				</li>
                <li>	
					handler.<a href="">construct</a><em>(target, args)</em>
					<span>
						拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。
					</span>
				</li>
                <li>
					handler.<a href="">apply</a><em>(target,object,args)</em>
					<span>
						拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
					</span>
				</li>
				<li>
					handler.<a href="">ownKeys</a><em>(target)</em>
					<span>
						拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名。
					</span>
				</li>
                <li>
					handler.<a href="">getOwnPropertyDescriptor</a><em>(target,key)</em>
					<span>
						拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
					</span>
				</li>
				<li>
					handler.<a href="">defineProperty</a><em>(target,key,desc)</em>
					<span>
						拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
					</span>
				</li>
				<li>
					handler.<a href="">preventExtensions</a><em>(target)</em>
					<span>
						拦截Object.preventExtensions(proxy)，返回一个布尔值。
					</span>
				</li>
                <li>
					handler.<a href="">isExtensible</a><em>(target)</em>
					<span>
						拦截Object.isExtensible(proxy)，返回一个布尔值。
					</span>
				</li>
				<li>
					handler.<a href="">getPrototypeOf</a><em>(target)</em>
					<span>
						拦截Object.getPrototypeOf(proxy)，返回一个对象。
					</span>
				</li>
				<li>
					handler.<a href="">setPrototypeOf</a><em>(target,proto)</em>
					<span>
						拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]Reflect</h4>
			<ul style="display:none;">
				<li>
					<a href="">Reflect</a>
					<span>
						1.将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。 <br>
						2.修改某些Object方法的返回结果，让其变得更合理。 <br>
						3.让Object操作都变成函数行为。 <br>
						<a href="http://es6.ruanyifeng.com/#docs/reflect">参考资料</a>
					</span>
				</li>
				<li>
					Reflect.<a href="">get</a><em>(target,key,[receiver])</em>
					<span>
						查找并返回target对象的name属性，如果没有该属性，则返回undefined。
					</span>
				</li>
				<li>
					Reflect.<a href="">set</a><em>(target,key,value,[receiver])</em>
					<span>
						设置target对象的name属性等于value
					</span>
				</li>
				<li>
					Reflect.<a href="">has</a><em>(target,key)</em>
					<span>
						对应key in obj里面的in运算符
					</span>
				</li>
				<li>
					Reflect.<a href="">deleteProperty</a><em>(target,key)</em>
					<span>
						等同于delete obj[name]，用于删除对象的属性
					</span>
				</li>
				<li>
					Reflect.<a href="">construct</a><em>(target,args)</em>
					<span>
						等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。
					</span>
				</li>
                <li>
					Reflect.<a href="">apply</a><em>(fn,thisArg,args)</em>
					<span>
						等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。
					</span>
				</li>
                <li>
					Reflect.<a href="">ownKeys</a><em>(target)</em>
					<span>
						返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。
					</span>
				</li>
                <li>
					Reflect.<a href="">getOwnPropertyDescriptor</a><em>(target,key)</em>
					<span>
						基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象
					</span>
				</li>
				<li>
					Reflect.<a href="">defineProperty</a><em>(target,key,desc)</em>
					<span>
						基本等同于Object.defineProperty，用来为对象定义属性。
					</span>
				</li>
                <li>
					Reflect.<a href="">preventExtensions</a><em>(target)</em>
					<span>
						对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。
					</span>
				</li>
				<li>
					Reflect.<a href="">isExtensible</a><em>(target)</em>
					<span>
						对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。
					</span>
				</li>
                <li>
					Reflect.<a href="">getPrototypeOf</a><em>(obj)</em>
					<span>
						用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。
					</span>
				</li>
				<li>
					Reflect.<a href="">setPrototypeOf</a><em>(obj,proto)</em>
					<span>
						用于设置对象的__proto__属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。
					</span>
				</li>
			</ul>
        </div>
    </div>
    <div class="u-block">
        <h3>其它<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>-</span>]全局函数</h4>
			<ul>
				<li>
                    <a href="">eval</a>(str)
                    <span>
                        将传入的字符串当做 JavaScript 代码进行执行。<br>
						1.eval没有自己的作用域，都在当前作用域内执行。<br>
                        2.JavaScript规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。 <br>
						3.在严格模式下，eval依然可以读写当前作用域的变量。<br>
                        4.eval“间接调用”时作用域总是全局作用域
                        <a href="http://javascript.ruanyifeng.com/grammar/function.html#toc24">参考资料</a>
                    </span>
                </li>
			</ul>
            <h4>[<span>+</span>]其它内置对象</h4>
            <ul style="display: none;">
                <li><a href="">Error</a><span>
                    new Error('msg') <br>
                    错误对象属性：
                    <table>
                        <tr>
                            <th>属性</th>
                            <th>描述</th>
                        </tr>
                        <tr>
                            <td>err.message</td>
                            <td>错误提示信息</td>
                        </tr>
                        <tr>
                            <td>err.name</td>
                            <td>错误名称（非标准属性）</td>
                        </tr>
                        <tr>
                            <td>err.stack</td>
                            <td>错误的堆栈（非标准属性）</td>
                        </tr>
                    </table>
                    <br>
                    原生错误类型：
                    <table>
                        <tr>
                            <th>名称</th>
                            <th>描述</th>
                        </tr>
                        <tr>
                            <td>SyntaxError</td>
                            <td>解析代码时发生的语法错误</td>
                        </tr>
                        <tr>
                            <td>ReferenceError</td>
                            <td>引用一个不存在的变量时发生的错误；将一个值分配给无法分配的对象</td>
                        </tr>
                        <tr>
                            <td>RangeError</td>
                            <td>当一个值超出有效范围时发生的错误</td>
                        </tr>
                        <tr>
                            <td>TypeError</td>
                            <td>变量或参数不是预期类型时发生的错误</td>
                        </tr>
                        <tr>
                            <td>URIError</td>
                            <td>URI相关函数的参数不正确时抛出的错误</td>
                        </tr>
                        <tr>
                            <td>EvalError</td>
                            <td>eval函数没有被正确执行</td>
                        </tr>
                        <tr>
                            <td>自定义错误</td>
                            <td><a href="http://javascript.ruanyifeng.com/grammar/error.html">参考资料</a></td>
                        </tr>
                    </table>

                    <br><br>
                    如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。所以，我们不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获，一网打尽。<hr>
                    涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。<br>
                    类似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。
                </span></li>
            </ul>
        </div>
    </div>
	<div class="u-block">
        <h3>数据类型<span>+</span></h3>
        <div class="u-list">
            <h4>[<span>+</span>]Buffer&Stream</h4>
            <ul style="display:none;">

            </ul>
            <h4>[<span>+</span>]数据类型</h4>
            <ul style="display:none;">
                <li>
                    <a href="">Boolean</a>
                    <span>
                        布尔:原始类型
                    </span>
                </li>
                <li>
                    <a href="">Number</a>
                    <span>
                        数值：原始类型 <br>
                        根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(263 -1) 到 263 -1） <br>
                        数字类型只有一个整数: 0
                    </span>
                </li>
                <li>
                    <a href="">String</a>
                    <span>
                        字符串：原始类型 <br>
                        JavaScript 字符串是不可更改的
                    </span>
                </li>
                <li>
                    <a href="">Symbol</a>
                    <span>
                        符号：原始类型 <br>
                        符号类型是唯一的并且是不可修改的,可以用来作为Object的key的值
                    </span>
                </li>
                <li>
                    <a href="">Undefined</a>
                    <span>
                        未定义：原始类型 <br>
                        一个没有被赋值的变量会有个默认值 undefined
                    </span>
                </li>
                <li>
                    <a href="">Null</a>
                    <span>
                        空：原始类型 <br>
                        Null 类型只有一个值： null
                    </span>
                </li>
                <li>
                    <a href="">Object</a>
                    <span>
                        对象：引用类型（包括数组、函数、标准对象等）
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>]类型检测</h4>
            <ul style="display:none;">
                <li>
                    <a href="">typeof</a> val
                    <span>
                        返回的是字符串。 <br>
                        可通过Object.prototype.toString.call(o)测试
                        <table>
                            <tr>
                                <th>类型</th>
                                <th>结果</th>
                            </tr>
                            <tr>
                                <td>true/false</td>
                                <td>boolean</td>
                            </tr>
                            <tr>
                                <td>数值/NaN</td>
                                <td>boolean</td>
                            </tr>
                            <tr>
                                <td>Symbol</td>
                                <td>symbol</td>
                            </tr>
                            <tr>
                                <td>字符串/JSON</td>
                                <td>string</td>
                            </tr>
                            <tr>
                                <td>fn</td>
                                <td>function</td>
                            </tr>
                            <tr>
                                <td>obj/数组/null</td>
                                <td>object</td>
                            </tr>
                            <tr>
                                <td>undefined/不存在的属性或方法</td>
                                <td>undefined</td>
                            </tr>
                        </table>
                        <br><hr>
                        1.判断null请使用myVar === null <br>
                        2.不存在的变量与未声明的变量typeof检测均为undefined，但两者其实不同，故建议总是初始化。 <br>
                        3.Null 类型是一个只有一个值的数据类型，即特殊的值 null。它表示一个空对象引用(指针)，而 typeof 操作符检测 null 会返回 object。如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null。这样，当检查 null 值就知道是否已经变量是否已经分配了对象引用了。<br>
                        4.undefined 是派生自 null 的，因此 ECMA-262 规定对它们的相等性测试返回 true。alert(undefined == null);但typeof数据类型不等。
                    </span>
                </li>
                <li>
                    obj <a href="">instanceof</a> cst
                    <span>instanceof运算符返回一个布尔值，表示某个对象是否为指定的构造函数的实例。
                        <table>
                            <tr>
                                <th>测试目标</th>
                                <th>测试结果</th>
                            </tr>
                            <tr>
                                <td>数组</td>
                                <td>arr instanceof Array</td>
                            </tr>
                            <tr>
                                <td>函数/构造函数</td>
                                <td>fn instanceof Function</td>
                            </tr>
                            <tr>
                                <td>构造函数实例</td>
                                <td>child instanceof parent</td>
                            </tr>
                            <tr>
                                <td>泛对象</td>
                                <td>obj instanceof Object</td>
                            </tr>
                            <tr>
                                <td>日期</td>
                                <td>value instanceof Date</td>
                            </tr>
                            <tr>
                                <td>正则表达式</td>
                                <td>value instanceof RegExp</td>
                            </tr>
                            <tr>
                                <td>数学</td>
                                <td>value instanceof Math</td>
                            </tr>
                        </table>
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>]类型转换</h4>
            <ul style="display:none;">
                <li>
                    <a href="">Boolean</a>(val)
                    <span>
                        省略该参数 <br>
                        其值为 0、-0、null、false、NaN、undefined、或者空字符串（""）<br>
                        参数是DOM对象document.all <br>
                        以上均生成值为false的Boolean对象
                    </span></li>
                <li>
                    <a href="">Number</a>(val)
                    <span>
                        <table>
                            <tr>
                                <th>value</th>
                                <th>返回值</th>
                            </tr>
                            <tr>
                                <td>number/包含单个数值的数组</td>
                                <td>number</td>
                            </tr>
                            <tr>
                                <td>boolean</td>
                                <td>1 / 0</td>
                            </tr>
                            <tr>
                                <td>null/空字符串/空数组</td>
                                <td>0</td>
                            </tr>
                            <tr>
                                <td>undefined/string/object</td>
                                <td>NaN</td>
                            </tr>
                        </table>
                    </span></li>
                <li>
                    <a href="">String</a>(val)
                    <span>
                        <table>
                            <tr>
                                <th>value</th>
                                <th>返回值</th>
                            </tr>
                            <tr>
                                <td>数值</td>
                                <td>转为相应的字符串</td>
                            </tr>
                            <tr>
                                <td>字符串</td>
                                <td>转换后还是原来的值</td>
                            </tr>
                            <tr>
                                <td>布尔值</td>
                                <td>true转为"true"，false转为"false"</td>
                            </tr>
                            <tr>
                                <td>undefined</td>
                                <td>转为"undefined"</td>
                            </tr>
                            <tr>
                                <td>null</td>
                                <td>转为"null"</td>
                            </tr>
                            <tr>
                                <td>数组</td>
                                <td>返回该数组的字符串形式  "1,2,3"</td>
                            </tr>
                            <tr>
                                <td>对象</td>
                                <td>返回一个类型字符串 "[object Object]" <br>可通过toString方法来设置修改</td>
                            </tr>
                        </table>
                    </span>
                </li>
            </ul>
        </div>
        <h3>语法<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>+</span>]变量</h4>
            <ul style="display:none;">
                <li>
                    <a href="">var</a>
                    <span>
                        x1 = 1;<br />
                        var x2 = 2;<br />
                        window.x3 = 3;<br />
                        <a href="http://snandy.iteye.com/blog/720816">3种全局变量的异同</a> <hr>
                        1.变量会提升，在没有声明前调用，会输出undefined <br>
                        2.假设声明a、b、c,且c=a+b，且均为非引用类型，当ab发生变化时，c不会改变，应设为c=fn(return a+b)
                    </span>
                </li>
                <li>
                    <a href="">let</a>
                    <span>
                        let i = 1;<br>
                        1.申明一个块级作用域的变量 <br>
                        2.不能使用let重复定义一个变量 <br>
                        3.只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响，暂时性死区。<br>
                    </span>
                </li>
                <li>
                    <a href="">const</a>
                    <span>
                        const PI = 3.14 <br>
                        1.const来定义常量，在声明时就必须赋值。<br>
                        2.const与let都具有块级作用域。 <br>
                        2.一旦声明，常量的指针就不能改变。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>]表达式与运算符</h4>
            <ul style="display:none;">
                <li>
                    <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators">运算符</a>
                </li>
                <li>
                    <a href="">void</a>
                    <span>
                        void运算符对给定的表达式进行求值，然后返回 undefined <br>
                        在使用立即执行的函数表达式时，可以利用 void 运算符让 JavaScript 引擎把一个function关键字识别成函数表达式而不是函数声明（语句）
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>]流程控制与错误处理</h4>
            <ul style="display:none;">
                <li>
                    <a href="">if..else..</a>
                    <span>
                        if.. <br>
                        if..else.. <br>
                        if..else if..else..
                    </span>
                </li>
                <li>
                    <a href="">switch</a>
                    <span>
                        switch(expression){ <br>
                            case ex:<br>
                                ..<br>
                            break;<br>
                            default:<br>
                                ..<br>
                        }<br>
                        1.switch中的case为全等判断<br>
                        2.多个case使用同一个执行块应写为case 1: case2: ... <br>
                        3.每个case代码块内部的break不能少，否则会接着执行下一个case
                    </span>
                </li>
                <li>
                    <a href="">try..catch</a>
                    <span>
                        try{..} <br>
                        catch(e){..} <br>
                        finally{..}
                    </span>
                </li>
                <li>
                    <a href="">throw</a>
                    <span>
                        抛出一个异常
                    </span>
                </li>
                <li>
                    <a href="">debugger</a>
                    <span>
                        调用任何可用的调试功能，例如设置断点。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>]循环与迭代</h4>
            <ul style="display:none;">
                <li>
                    <a href="">for</a>
                    <span>
                        设置循环变量的部分和循环体内部有各自单独的作用域，变量彼此不影响（使用let时）。
                    </span>
                </li>
                <li>
                    <a href="">for..in</a>
                    <span>
                        循环一个对象所有可枚举的属性
                    </span>
                </li>
                <li>
                    <a href="">for..of</a>
                    <span>
                        在可迭代的对象上创建了一个循环 <br>
                        包括Array, Map, Set, 参数对象（ arguments） 等等
                    </span>
                </li>
                <li>
                    <a href="">do..while</a>(exp)
                    <span>
                        一直重复直到指定的条件求值得到假
                    </span>
                </li>
                <li>
                    <a href="">while</a>(exp)..
                    <span>
                        一个 while 语句只要指定的条件求值为真（true）就会一直执行它的语句块
                    </span>
                </li>
                <li>
                    <a href="">label</a>:
                    <span>
                        使用 break 或者 continue 来指出程序是否该停止循环还是继续循环
                    </span>
                </li>
                <li>
                    <a href="">break</a> [label]
                    <span>
                        跳出(内部/指定)循环 
                    </span>
                </li>
                <li>
                    <a href="">continue</a> [label]
                    <span>
                        跳至(内部/指定)循环 <hr>
                        不带参数的break和continue语句都只针对最内层的循环，如continue语句后面不使用标签，则进入下一轮的内层循环 <br>
                        带参数的break和continue语句，满足条件时，会跳过当前循环，直接进入下一轮外层循环
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>]模块引入与导出</h4>
			<ul style="display:none;">
                <li>
                    <a href="">import $path</a>
                    <span>
                        引入某个模块
                    </span>
                </li>
                <li>
                    <a href="">export default $mod</a>
                    <span>
                        输出某个模块
                    </span>
                </li>
                <li>
                    <a href="">import $mod from $path</a>
                    <span>
                        引入某个模块
                    </span>
                </li>
				<li>
            		<a href="">export {mods,..}</a>
            		<span>
            			导出多个模块 <br>
                        也可以将其导出时更换为别的名称：<br>
                        export {<br>
                            $inner as $outer,<br>
                            .. <br>
                        }
            		</span>
            	</li>
            	<li>
            		<a href="">import {mods,..} from $path</a>
            		<span>
            			导入多个模块 <br>
                        也可以在导入时将其重命名：<br>
                        import {
                            $old as $new,<br>
                            .. <br>
                        } <hr>
                        也可以将其全部导入在一个对象下： <br>
                        import * as $modc from $path <br>
            		</span>
            	</li>
			</ul>
        </div>
    </div>
	<div class="u-block">
		<h3>参考资料<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>+</span>]文档</h4>
			<ul style="display: none;">
				<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">JS参考文档</a></li>
				<li><a href="http://kangax.github.io/compat-table/es6/">ES6支持程度</a></li>
				<li><a href="http://yanhaijing.com/es5/">ECMAScript5规范</a></li>
			</ul>
			<h4>[<span>+</span>]教程</h4>
			<ul style="display: none;">
				<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide">JS指南</a></li>
				<li><a href="http://javascript.ruanyifeng.com">ES5教程</a></li>
				<li><a href="http://es6.ruanyifeng.com">ES6教程</a></li>
			</ul>
			<h4>[<span>+</span>]动态</h4>
			<ul style="display: none;">
				<li><a href="https://www.awesomes.cn/">前端库大全</a></li>
				<li><a href="https://juejin.im/welcome/frontend">掘金社区</a></li>
				<li><a href="https://www.zhihu.com/topic/19550901/hot">知乎话题</a></li>
			</ul>
		</div>
	</div>
</div>