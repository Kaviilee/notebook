<!-- 标准对象 -->
<div class="u-col">
	<div class="u-block">
		<h3>类<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]类</h4>
			<ul>
				<li><a href="">class </a>Name<span>
<pre><code data-language="javascript">
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
var test = new Point(1,2)
</code></pre>
					1.constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 <br>
					2.类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 <br>
					3.类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。 <br>
					4.var MyClass = class Me{...} 表达式的方式 <a href="http://es6.ruanyifeng.com/#docs/class#Class-表达式">参考资料</a> <br>
					5.类不存在变量提升 <br>
					6.
                </span></li>
                <li>
                	<a href="">static</a> fn
                	<span>
                		类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 <br>
                		注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。 <hr>
                		ES6 明确规定，Class 内部只有静态方法，没有静态属性。 <br>
                		目前需要通过在类外面使用Class.prop来定义
                	</span>
                </li>
			</ul>
			<h4>[<span>-</span>]类继承</h4>
			<ul>
				<li><a href="">class $child extends $parent</a><span>
<pre><code data-language="javascript">
class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert('I am at grade ' + this.grade);
    }
}
</code></pre>
					PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。
                </span></li>
                <li><a href="">super</a>(parent_key)<span>
                	super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。<br>
                	1.super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。 <br>
                	2.super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
                </span></li>
			</ul>
			<h4>[<span>-</span>]原型链</h4>
			<ul>
				<li>
					cst.<a href="">prototype|super</a>
					<span>
                		返回值：构造函数创建的实例的原型（prototype是函数才会有的属性） <br>
                    	为减少内存消耗，将公共方法写在构造函数的原型上，<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997235247b53be560ab041a7b10360a567422a78000">参考资料</a> <br>
						在改变原型对象时，一般要同时设置constructor属性 <br>
                	</span>
				</li>
				<li>
					pro.<a href="">constructor</a>
					<span>
                    	原型对象的这个属性指向构造函数 <br>
                    	<img src="image/js/prototype.png" alt="">
                	</span>
				</li>
				<li>
					obj.<a href="">constructor</a>
					<span>
						返回值：Object / 构造函数 <br>
						实例本身没有constructor，通过在原型上查找获取
					</span>
				</li>
				<li>
					obj.<a href="">__proto__</a>
					<span>
						返回值：Object / 构造函数原型对象（仅浏览器环境） <br>
						在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型，并且，低版本的IE也无法使用__proto__。 
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]原型方法</h4>
			<ul style="display:none;">
				<li>
					pro.<a href="">isPrototypeOf</a>(obj)
					<span>
						判断当前对象是否为另一个对象的原型 <br>
						Object.prototype处于原型链的最顶端，所以对各种实例都返回true，只有继承null的对象除外。
					</span>
				</li>
				<li>
					<a href="">Object.getPrototypeOf</a>(obj)
					<span>
						获取对象的原型对象
					</span>
				</li>
				<li>
					<a href="">Object.setPrototypeOf</a>(obj,proto)
					<span>
						为现有对象设置原型，返回新对象。
					</span>
				</li>
			</ul>
            <h4>[<span>-</span>]原型继承</h4>
            <ul>
				<li>
					<a href="">Object.create</a>(proto)
					<span>
						于一个原型创建新对象 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">参考资料</a><br>
						不能直接将b的原型赋值给a，否则当b的原型修改时，a的原型也会被更改 <hr>
						Child.prototype = Object.create(Parent.prototype) <br>	Child.prototype.constructor = Child
					</span>
				</li>
            </ul>
        </div>
    </div>
	<div class="u-block">
        <h3>数据类型<span>+</span></h3>
        <div class="u-list">
            <h4>[<span>+</span>]Buffer&Stream</h4>
            <ul style="display:none;">

            </ul>
            <h4>[<span>+</span>]数据类型</h4>
            <ul style="display:none;">
                <li>
                    <a href="">Boolean</a>
                    <span>
                        布尔:原始类型
                    </span>
                </li>
                <li>
                    <a href="">Number</a>
                    <span>
                        数值：原始类型 <br>
                        根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(263 -1) 到 263 -1） <br>
                        数字类型只有一个整数: 0
                    </span>
                </li>
                <li>
                    <a href="">String</a>
                    <span>
                        字符串：原始类型 <br>
                        JavaScript 字符串是不可更改的
                    </span>
                </li>
                <li>
                    <a href="">Symbol</a>
                    <span>
                        符号：原始类型 <br>
                        符号类型是唯一的并且是不可修改的,可以用来作为Object的key的值
                    </span>
                </li>
                <li>
                    <a href="">Undefined</a>
                    <span>
                        未定义：原始类型 <br>
                        一个没有被赋值的变量会有个默认值 undefined
                    </span>
                </li>
                <li>
                    <a href="">Null</a>
                    <span>
                        空：原始类型 <br>
                        Null 类型只有一个值： null
                    </span>
                </li>
                <li>
                    <a href="">Object</a>
                    <span>
                        对象：引用类型（包括数组、函数、标准对象等）
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>]类型检测</h4>
            <ul style="display:none;">
                <li>
                    <a href="">typeof</a> val
                    <span>
                        返回的是字符串。 <br>
                        可通过Object.prototype.toString.call(o)测试
                        <table>
                            <tr>
                                <th>类型</th>
                                <th>结果</th>
                            </tr>
                            <tr>
                                <td>true/false</td>
                                <td>boolean</td>
                            </tr>
                            <tr>
                                <td>数值/NaN</td>
                                <td>boolean</td>
                            </tr>
                            <tr>
                                <td>Symbol</td>
                                <td>symbol</td>
                            </tr>
                            <tr>
                                <td>字符串/JSON</td>
                                <td>string</td>
                            </tr>
                            <tr>
                                <td>fn</td>
                                <td>function</td>
                            </tr>
                            <tr>
                                <td>obj/数组/null</td>
                                <td>object</td>
                            </tr>
                            <tr>
                                <td>undefined/不存在的属性或方法</td>
                                <td>undefined</td>
                            </tr>
                        </table>
                        <br><hr>
                        1.判断null请使用myVar === null <br>
                        2.不存在的变量与未声明的变量typeof检测均为undefined，但两者其实不同，故建议总是初始化。 <br>
                        3.Null 类型是一个只有一个值的数据类型，即特殊的值 null。它表示一个空对象引用(指针)，而 typeof 操作符检测 null 会返回 object。如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null。这样，当检查 null 值就知道是否已经变量是否已经分配了对象引用了。<br>
                        4.undefined 是派生自 null 的，因此 ECMA-262 规定对它们的相等性测试返回 true。alert(undefined == null);但typeof数据类型不等。
                    </span>
                </li>
                <li>
                    obj <a href="">instanceof</a> cst
                    <span>instanceof运算符返回一个布尔值，表示某个对象是否为指定的构造函数的实例。
                        <table>
                            <tr>
                                <th>测试目标</th>
                                <th>测试结果</th>
                            </tr>
                            <tr>
                                <td>数组</td>
                                <td>arr instanceof Array</td>
                            </tr>
                            <tr>
                                <td>函数/构造函数</td>
                                <td>fn instanceof Function</td>
                            </tr>
                            <tr>
                                <td>构造函数实例</td>
                                <td>child instanceof parent</td>
                            </tr>
                            <tr>
                                <td>泛对象</td>
                                <td>obj instanceof Object</td>
                            </tr>
                            <tr>
                                <td>日期</td>
                                <td>value instanceof Date</td>
                            </tr>
                            <tr>
                                <td>正则表达式</td>
                                <td>value instanceof RegExp</td>
                            </tr>
                            <tr>
                                <td>数学</td>
                                <td>value instanceof Math</td>
                            </tr>
                        </table>
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>]类型转换</h4>
            <ul style="display:none;">
                <li>
                    <a href="">Boolean</a>(val)
                    <span>
                        省略该参数 <br>
                        其值为 0、-0、null、false、NaN、undefined、或者空字符串（""）<br>
                        参数是DOM对象document.all <br>
                        以上均生成值为false的Boolean对象
                    </span></li>
                <li>
                    <a href="">Number</a>(val)
                    <span>
                        <table>
                            <tr>
                                <th>value</th>
                                <th>返回值</th>
                            </tr>
                            <tr>
                                <td>number/包含单个数值的数组</td>
                                <td>number</td>
                            </tr>
                            <tr>
                                <td>boolean</td>
                                <td>1 / 0</td>
                            </tr>
                            <tr>
                                <td>null/空字符串/空数组</td>
                                <td>0</td>
                            </tr>
                            <tr>
                                <td>undefined/string/object</td>
                                <td>NaN</td>
                            </tr>
                        </table>
                    </span></li>
                <li>
                    <a href="">String</a>(val)
                    <span>
                        <table>
                            <tr>
                                <th>value</th>
                                <th>返回值</th>
                            </tr>
                            <tr>
                                <td>数值</td>
                                <td>转为相应的字符串</td>
                            </tr>
                            <tr>
                                <td>字符串</td>
                                <td>转换后还是原来的值</td>
                            </tr>
                            <tr>
                                <td>布尔值</td>
                                <td>true转为"true"，false转为"false"</td>
                            </tr>
                            <tr>
                                <td>undefined</td>
                                <td>转为"undefined"</td>
                            </tr>
                            <tr>
                                <td>null</td>
                                <td>转为"null"</td>
                            </tr>
                            <tr>
                                <td>数组</td>
                                <td>返回该数组的字符串形式  "1,2,3"</td>
                            </tr>
                            <tr>
                                <td>对象</td>
                                <td>返回一个类型字符串 "[object Object]" <br>可通过toString方法来设置修改</td>
                            </tr>
                        </table>
                    </span>
                </li>
            </ul>
        </div>
        <h3>语法<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>+</span>]变量</h4>
            <ul style="display:none;">
                <li>
                    <a href="">var</a>
                    <span>
                        x1 = 1;<br />
                        var x2 = 2;<br />
                        window.x3 = 3;<br />
                        <a href="http://snandy.iteye.com/blog/720816">3种全局变量的异同</a> <hr>
                        1.变量会提升，在没有声明前调用，会输出undefined <br>
                        2.假设声明a、b、c,且c=a+b，且均为非引用类型，当ab发生变化时，c不会改变，应设为c=fn(return a+b)
                    </span>
                </li>
                <li>
                    <a href="">let</a>
                    <span>
                        let i = 1;<br>
                        1.申明一个块级作用域的变量 <br>
                        2.不能使用let重复定义一个变量 <br>
                        3.只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响，暂时性死区。<br>
                    </span>
                </li>
                <li>
                    <a href="">const</a>
                    <span>
                        const PI = 3.14 <br>
                        1.const来定义常量，在声明时就必须赋值。<br>
                        2.const与let都具有块级作用域。 <br>
                        2.一旦声明，常量的指针就不能改变。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>]运算符与操作符</h4>
            <ul style="display:none;">
                <li>
                    <a href=""></a><em>运算符</em>
                    <span>
                        <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators">参考资料</a>
                    </span>
                </li>
                <li>
					<a href="">delete </a>obj.key
					<span>
						删除属性delete obj.key，删除成功后返回true <br>
						注意，删除一个不存在的属性，delete不报错，而且返回true。 <br>
						只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。<br>
						delete命令只能删除对象本身的属性，无法删除继承的属性 <br>
						delete命令不能删除var命令声明的变量，只能用来删除属性。
					</span>
				</li>
				<li>
                    key <a href="">in</a> obj
                    <span>
                        in遍历访问对象的属性/属性值
                        它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性 <br>
                        它不仅遍历对象自身的属性，还遍历继承的属性。
                    </span>
                </li>
                <li>
                    <a href="">void</a>
                    <span>
                        表明一个运算没有返回值
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>]表达式与其它</h4>
            <ul style="display:none;">
                <li>
                    <a href="">this</a>
                    <span>
                        this关键字被用于指代当前的对象，通常，this指代的是方法中正在被调用的对象
                    </span>
                </li>
                <li>
                    <a href="">new</a>
                    <span>
                        你可以使用new operator 创建一个自定义类型或者是预置类型的对象实例
                    </span>
                </li>
                <li>
                    <a href="">'use strict'</a>
                    <span>
                        严格模式下，函数中的this指向Undefined，非window对象。 <a href="http://es6.ruanyifeng.com/#docs/module#严格模式">参考资料</a> <br>
                        ES6下默认开启严格模式
                    </span>
                </li>
                <li>
                    <a href="">with</a>(obj)
                    <span>
                        操作同一个对象的多个属性时，提供一些书写的方便. <a href="http://javascript.ruanyifeng.com/grammar/object.html">参考资料</a> <br>
                        注意，with区块内部的变量，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。这是因为with区块没有改变作用域，它的内部依然是当前作用域。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>]流程控制与错误处理</h4>
            <ul style="display:none;">
                <li>
                    <a href="">if..else..</a>
                    <span>
                        if.. <br>
                        if..else.. <br>
                        if..else if..else..
                    </span>
                </li>
                <li>
                    <a href="">switch</a>
                    <span>
                        switch(expression){ <br>
                            case ex:<br>
                                ..<br>
                            break;<br>
                            default:<br>
                                ..<br>
                        }<br>
                        1.switch中的case为全等判断<br>
                        2.多个case使用同一个执行块应写为case 1: case2: ... <br>
                        3.每个case代码块内部的break不能少，否则会接着执行下一个case
                    </span>
                </li>
                <li>
                    <a href="">try..catch</a>
                    <span>
                        try{..} <br>
                        catch(e){..} <br>
                        finally{..}
                    </span>
                </li>
                <li>
                    <a href="">throw</a>
                    <span>
                        抛出一个异常
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>]循环与迭代</h4>
            <ul style="display:none;">
                <li>
                    <a href="">for</a>
                    <span>
                        设置循环变量的部分和循环体内部有各自单独的作用域，变量彼此不影响（使用let时）。
                    </span>
                </li>
                <li>
                    <a href="">for..in</a>
                    <span>
                        循环一个对象所有可枚举的属性
                    </span>
                </li>
                <li>
                    <a href="">for..of</a>
                    <span>
                        在可迭代的对象上创建了一个循环 <br>
                        包括Array, Map, Set, 参数对象（ arguments） 等等
                    </span>
                </li>
                <li>
                    <a href="">do..while</a>(exp)
                    <span>
                        一直重复直到指定的条件求值得到假
                    </span>
                </li>
                <li>
                    <a href="">while</a>(exp)..
                    <span>
                        一个 while 语句只要指定的条件求值为真（true）就会一直执行它的语句块
                    </span>
                </li>
                <li>
                    <a href="">label</a>:
                    <span>
                        使用 break 或者 continue 来指出程序是否该停止循环还是继续循环
                    </span>
                </li>
                <li>
                    <a href="">break</a> [label]
                    <span>
                        跳出(内部/指定)循环 
                    </span>
                </li>
                <li>
                    <a href="">continue</a> [label]
                    <span>
                        跳至(内部/指定)循环 <hr>
                        不带参数的break和continue语句都只针对最内层的循环，如continue语句后面不使用标签，则进入下一轮的内层循环 <br>
                        带参数的break和continue语句，满足条件时，会跳过当前循环，直接进入下一轮外层循环
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>]模块引入与导出</h4>
			<ul style="display:none;">
                <li>
                    <a href="">import $path</a>
                    <span>
                        引入某个模块
                    </span>
                </li>
                <li>
                    <a href="">export default $mod</a>
                    <span>
                        输出某个模块
                    </span>
                </li>
                <li>
                    <a href="">import $mod from $path</a>
                    <span>
                        引入某个模块
                    </span>
                </li>
				<li>
            		<a href="">export {mods,..}</a>
            		<span>
            			导出多个模块 <br>
                        也可以将其导出时更换为别的名称：<br>
                        export {<br>
                            $inner as $outer,<br>
                            .. <br>
                        }
            		</span>
            	</li>
            	<li>
            		<a href="">import {mods,..} from $path</a>
            		<span>
            			导入多个模块 <br>
                        也可以在导入时将其重命名：<br>
                        import {
                            $old as $new,<br>
                            .. <br>
                        } <hr>
                        也可以将其全部导入在一个对象下： <br>
                        import * as $modc from $path <br>
            		</span>
            	</li>
			</ul>
        </div>
    </div>
	<div class="u-block">
		<h3>参考资料<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>+</span>]文档</h4>
			<ul style="display: none;">
				<li><a href="https://developer.mozilla.org/zh-CN/docs/Web">MDN Web技术文档</a></li>
				<li><a href="http://kangax.github.io/compat-table/es6/">ES6支持程度</a></li>
				<li><a href="http://yanhaijing.com/es5/">ECMAScript5规范</a></li>
			</ul>
			<h4>[<span>+</span>]教程</h4>
			<ul style="display: none;">
				<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide">JS指南</a></li>
				<li><a href="http://javascript.ruanyifeng.com">ES5教程</a></li>
				<li><a href="http://es6.ruanyifeng.com">ES6教程</a></li>
			</ul>
			<h4>[<span>+</span>]动态</h4>
			<ul style="display: none;">
				<li><a href="https://www.awesomes.cn/">前端库大全</a></li>
				<li><a href="https://juejin.im/welcome/frontend">掘金社区</a></li>
				<li><a href="https://www.zhihu.com/topic/19550901/hot">知乎话题</a></li>
			</ul>
		</div>
	</div>
</div>