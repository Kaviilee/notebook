<!-- 标准对象 -->
<div class="u-col">
	<div class="u-block">
		<h3>标准对象<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]JSON</h4>
			<ul>
				<li><em>json</em><a href=""></a><span>
					概念：
					<br />它是一种表示结构化数据的形式，JSON是一个格式化的字符串，文件格式后缀为.json
					<hr>
					语法：
					<br />简单值：字符串、数值、布尔值、null，不支持undefined
					<br />对象：一组无序的键值对
					<br />数组：一组有序的值的列表，可以通过索引来访问
					<hr>
					JSON与JS的区别：
					<br />JSON字符串必须使用双引号（单引号会导致语法错误），且对象的属性必须加双引号
					<br />在JS中直接引入一段JSON数据应该用单引号将其括起来，因为它其实代表一个字符串
					<br />如：'{"name" : "Lee","age" : 100}' JSON数组与对象比普通JS少了分号与赋值，其本身表示的是字符串
					<hr>
					兼容性：
					<br>IE7及IE7-需要引用库文件 <a href="https://github.com/douglascrockford/JSON-js/">json-js</a>
					<textarea><!--[if lte IE 7]> json2.js <![endif]--></textarea>
					<hr>
					执行优先级：
					<br>toJSON() --> 过滤参数 --> 标准序列化 --> 缩进 
					<br>如在toJSON中已被过滤的键值则就算过滤参数中仍有设置也已无效
				</span></li>
				<li><a href="">JSON.stringify</a><em>(obj,[arr(key)|fn(key,val)|null],[space|num])</em><span>
					js对象 -> json字符串 <hr>
					参数1：传入的对象。<br>
					如有键值为函数时，会排除该成员。我们可以在转换前将函数用.toString()方法转换为字符串来避免以上问题的发生。<br>
					如有键值为日期对象时，会转为字符串。
					<hr>
					参数2：用于转换结果的函数或数组 <br>
					当为数组时，显示指定的key，['key1','key2'] <br>
					当为函数时，每个键值对根据函数规则处理，function(key,value){...return value}，<b>函数需返回新的value</b>。<b>如果此函数返回 undefined，则排除成员。</b>
					<hr>
					参数3：缩进空格，当不传入fn只设置缩进时，第2个参数传入null。如果space 是一个数字，则返回值文本在每个级别缩进指定数目的空格。
				</span></li>
				<li><a href="">JSON.parse</a>(json,[fn(key,val)])<span>
					json字符串 -> js对象 <br>
					转换函数需返回value值。
				</span></li>
				<li>obj.<a href="">toJSON</a><em>:fn(){return json}</em><span>
				   JS对象中添加toJSON()方法，自定义过滤一些数据，返回新的对象
<pre><code data-language="javascript">
	var xiaoming = {
	    name: '小明',
	    age: 14,
	    gender: true,
	    height: 1.65,
	    grade: null,
	    'middle-school': '\"W3C\" Middle School',
	    skills: ['JavaScript', 'Java', 'Python', 'Lisp'],
	    toJSON: function () {
	        return { // 只输出name和age，并且改变了key：
	            'Name': this.name,
	            'Age': this.age
	        };
	    }
	};

	JSON.stringify(xiaoming); // '{"Name":"小明","Age":14}'
</code></pre>
				</span></li>
			</ul>
			<h4>[<span>+</span>]Math</h4>
			<ul style="display:none">
				<li><a href="">Math.random()</a><span>
					返回 0 ~ 1 之间的随机数(大于等于 0.0且小于1.0的伪随机 double 值) <br>
					1.随机颜色16进制：Math.floor( Math.random() * 16777215 ).toString( 16 ) <br>
					2.2个值之间的随机值：function random(min,max){return min + (max-min)*Math.random();} <br>
					<a href="http://javascript.ruanyifeng.com/stdlib/math.html">参考资料</a>
				</span></li>
				<li><a href="">Math.max/min</a>(x,y,z..n)<span>
					返回 x,y,z,...,n 中的最高/低值 <br>
					参数中最大的值。如果没有参数，则返回 -Infinity。如果有某个参数为 NaN，或是不能转换成数字的非数字值，则返回 NaN。
				</span></li>
				<li><a href="">Math.abs</a>(x)<span>返回 x 的绝对值</span></li>
				<li>
					<a href="">Math.sign</a>(x)
					<span>
						判断一个数到底是正数、负数、还是零。 <hr>
						参数为正数，返回+1； <br>
						参数为负数，返回-1；<br>
						参数为 0，返回0；<br>
						参数为-0，返回-0;<br>
						其他值，返回NaN。
					</span>
				</li>
				<li><a href="">Math.ceil/floor/round</a>(x)<span>对数进行上/下舍入/四舍五入</span></li>
				<li>
					<a href="">Math.trunc</a>(x)
					<span>
						去除一个数的小数部分，返回整数部分
					</span>
				</li>
				<li><a href="">Math.sqrt</a>(x)<span>返回x的平方根</span></li>
				<li>
					<a href="">Math.cbrt</a>(x)
					<span>
						计算一个数的立方根
					</span>
				</li>
				<li><a href="">Math.pow</a>(x,y)<span>返回x的y次幂</span></li>
				<li><a href="">Math.exp</a>(x)<span>返回E(x)的指数</span></li>
				<li><a href="">Math.log</a>(x)<span>返回数的自然对数（底为e）</span></li>
				<li><a href="">Math.CONST</a><span>
					<table>
						<tr>
							<th>属性</th>
							<th>描述</th>
						</tr>
						<tr>
							<td>E</td>
							<td>返回算术常量 e，即自然对数的底数（约等于2.718）</td>
						</tr>
						<tr>
							<td>LN2</td>
							<td>返回 2 的自然对数（约等于0.693）</td>
						</tr>
						<tr>
							<td>LN10</td>
							<td>返回 10 的自然对数（约等于2.302）</td>
						</tr>
						<tr>
							<td>LOG2E</td>
							<td>返回以 2 为底的 e 的对数（约等于 1.414）</td>
						</tr>
						<tr>
							<td>LOG10E</td>
							<td>返回以 10 为底的 e 的对数（约等于0.434）</td>
						</tr>
						<tr>
							<td>PI</td>
							<td>返回圆周率（约等于3.14159）</td>
						</tr>
						<tr>
							<td>SQRT1_2</td>
							<td>返回返回 2 的平方根的倒数（约等于 0.707）</td>
						</tr>
						<tr>
							<td>SQRT2</td>
							<td>返回 2 的平方根（约等于 1.414）</td>
						</tr>
					</table>
				</span></li>
				<li><a href="">Math.三角函数</a><span>
					<table>
						<tr>
							<th>函数</th>
							<th>描述</th>
						</tr>
						<tr>
							<td>Math.sin(x)</td>
							<td>返回数的正弦</td>
						</tr>
						<tr>
							<td>>Math.asin(x)</td>
							<td>返回 x 的反正弦值</td>
						</tr>
						<tr>
							<td>Math.cos(x)</td>
							<td>返回数的余弦</td>
						</tr>
						<tr>
							<td>Math.acos(x)</td>
							<td>返回 x 的反余弦值</td>
						</tr>
						<tr>
							<td>Math.tan(x)</td>
							<td>返回角的正切</td>
						</tr>
						<tr>
							<td>Math.atan(x)</td>
							<td>以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值</td>
						</tr>
						<tr>
							<td>Math.atan2(y,x)</td>
							<td>返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）</td>
						</tr>
					</table>
				</span></li>
				<li>
					<a href="">Math.hypot</a>(x,y..)
					<span>
						返回所有参数的平方和的平方根
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]Date</h4>
			<ul style="display:none">
				<li><a href="">new Date</a>([arg..,timestamp])<span>
					返回：日期对象 <hr>
					无参数时：创建计算机当前时间的日期对象 <br>
					var date = new Date(); <br>
					Sat Oct 07 2017 01:20:24 GMT+0800 (中国标准时间) <hr>
					有参数时：创建指定时间的日期对象 <br>
					var date = new Date(2015, 5, 19, 20, 15, 30, 123); <br>
					var date = new Date(1435146562875); <br>
					当前时间是浏览器从本机操作系统获取的时间，所以不一定准确，因为用户可以把当前时间设定为任何值。
				</span></li>
				<li>date.<a href="">getFullYear()</a>{2017}<span>年份</span></li>
				<li>date.<a href="">getMonth()</a>{0~11}<span>月份，范围0~11</span></li>
				<li>date.<a href="">getDate()</a>{1~31}<span>日期</span></li>
				<li>date.<a href="">getDay()</a>{1~7}<span>星期</span></li>
				<li>date.<a href="">getHours()</a>{0~24}<span>时，24小时制</span></li>
				<li>date.<a href="">getMinutes()</a>{0~60}<span>分</span></li>
				<li>date.<a href="">getSeconds()</a>{0~60}<span>秒</span></li>
				<li>date.<a href="">getMilliseconds()</a>{0~1000}<span>毫秒</span></li>
				<li><a href="">Date.now()</a>{timestamp}<span>当前时间戳</span></li>
				<li>date.<a href="">getTime()</a>{timestamp}<span>时间戳，等同于date.valueOf()</span></li>
				<li><a href="">Date.parse(ISO)</a>{timestamp}<span>
					解析一个符合ISO 8601格式的字符串，并返回对应时间戳 <br>
					var d = Date.parse('2015-06-24T19:49:22.875+08:00'); <br>
					d; // 1435146562875
				</span></li>
				<li>date.<a href="">toString</a>()<span>
					Sat Oct 07 2017 01:36:58 GMT+0800 (中国标准时间)
				</span></li>
				<li>date.<a href="">toLocaleString</a>()<span>
					2017/10/7 上午1:33:06
				</span></li>
				<li>date.<a href="">toUTCString</a>()<span>
					Fri, 06 Oct 2017 17:33:06 GMT
				</span></li>
			</ul>
			<h4>[<span>+</span>]RegExp</h4>
			<ul style="display:none">
				<li><a href="">new RegExp</a>('exp')<span>
					第一种方式是直接通过/正则表达式/写出来，第二种方式是通过new RegExp('正则表达式')创建一个RegExp对象。<br>
					var re1 = /ABC\-001/; <br>
					var re2 = new RegExp('ABC\\-001');<br>
					注意，如果使用第二种写法，因为字符串的转义问题，字符串的两个\\实际上是一个\。 <hr>
					修饰符：<br>
					i：忽略大小写。 <br>
					g：全局匹配。 <br>
					m：多行模式。<br>
					<a href="http://javascript.ruanyifeng.com/stdlib/regexp.html">参考资料</a>
				</span></li>
				<li>RegExp.<a href="">test</a>(str)<span>
					返回：true/false
				</span></li>
				<li>RegExp.<a href="">exec</a>(str)<span>
					返回：匹配值/null <br>
					全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引。
				</span></li>
			</ul>
			<h4>[<span>+</span>]Proxy</h4>
			<ul style="display:none;">
				<li>
					<a href="">new Proxy</a>(target,handler)
					<span>
						在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 <br>
						<a href="http://es6.ruanyifeng.com/#docs/proxy">参考资料</a> <hr>
						通过改写return值，可实现链式操作
					</span>
				</li>
				<li>
					<a href="">get</a><em>(target, propKey, receiver)</em>
					<span>
						拦截对象属性的读取，比如proxy.foo和proxy['foo']。
					</span>
				</li>
				<li>
					<a href="">set</a><em>(target, propKey, value, receiver)</em>
					<span>
						拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">has</a><em>(target, propKey)</em>
					<span>
						拦截propKey in proxy的操作，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">deleteProperty</a><em>(target, propKey)</em>
					<span>
						拦截delete proxy[propKey]的操作，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">ownKeys</a><em>(target)</em>
					<span>
						拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
					</span>
				</li>
				<li>
					<a href="">getOwnPropertyDescriptor</a><em>(target, propKey)</em>
					<span>
						拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
					</span>
				</li>
				<li>
					<a href="">defineProperty</a><em>(target, propKey, propDesc)</em>
					<span>
						拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">preventExtensions</a><em>(target)</em>
					<span>
						拦截Object.preventExtensions(proxy)，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">getPrototypeOf</a><em>(target)</em>
					<span>
						拦截Object.getPrototypeOf(proxy)，返回一个对象。
					</span>
				</li>
				<li>
					<a href="">isExtensible</a><em>(target)</em>
					<span>
						拦截Object.isExtensible(proxy)，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">setPrototypeOf</a><em>(target, proto)</em>
					<span>
						拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
					</span>
				</li>
				<li>
					<a href="">apply</a><em>(target, object, args)</em>
					<span>
						拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
					</span>
				</li>
				<li>	
					<a href="">construct</a><em>(target, args)</em>
					<span>
						拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。
					</span>
				</li>
				<li>
					<a href="">Proxy.revocable</a>(target, handler)
					<span>
						返回一个可取消的 Proxy 实例
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]Reflect</h4>
			<ul style="display:none;">
				<li>
					<a href="">Reflect</a>
					<span>
						1.将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。 <br>
						2.修改某些Object方法的返回结果，让其变得更合理。 <br>
						3.让Object操作都变成函数行为。 <br>
						<a href="http://es6.ruanyifeng.com/#docs/reflect">参考资料</a>
					</span>
				</li>
				<li>
					Reflect.<a href="">get</a><em>(target,name,[receiver])</em>
					<span>
						查找并返回target对象的name属性，如果没有该属性，则返回undefined。
					</span>
				</li>
				<li>
					Reflect.<a href="">set</a><em>(target,name,value,[receiver])</em>
					<span>
						设置target对象的name属性等于value
					</span>
				</li>
				<li>
					Reflect.<a href="">has</a><em>(obj,name)</em>
					<span>
						对应name in obj里面的in运算符
					</span>
				</li>
				<li>
					Reflect.<a href="">deleteProperty</a><em>(obj,name)</em>
					<span>
						等同于delete obj[name]，用于删除对象的属性
					</span>
				</li>
				<li>
					Reflect.<a href="">construct</a><em>(target,args)</em>
					<span>
						等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。
					</span>
				</li>
				<li>
					Reflect.<a href="">getPrototypeOf</a><em>(obj)</em>
					<span>
						用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。
					</span>
				</li>
				<li>
					Reflect.<a href="">setPrototypeOf</a><em>(obj,newProto)</em>
					<span>
						用于设置对象的__proto__属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。
					</span>
				</li>
				<li>
					Reflect.<a href="">apply</a><em>(fn,thisArg,args)</em>
					<span>
						等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。
					</span>
				</li>
				<li>
					Reflect.<a href="">defineProperty</a><em>(target,propertyKey,attributes)</em>
					<span>
						基本等同于Object.defineProperty，用来为对象定义属性。
					</span>
				</li>
				<li>
					Reflect.<a href="">getOwnPropertyDescriptor</a><em>(target,propertyKey)</em>
					<span>
						基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象
					</span>
				</li>
				<li>
					Reflect.<a href="">isExtensible</a><em>(target)</em>
					<span>
						对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。
					</span>
				</li>
				<li>
					Reflect.<a href="">preventExtensions</a><em>(target)</em>
					<span>
						对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。
					</span>
				</li>
				<li>
					Reflect.<a href="">ownKeys</a><em>(target)</em>
					<span>
						返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]Promise</h4>
			<ul style="display:none;">
				<li>
					<a href="">new Promise</a><em>(fn(resolve,reject))</em>
					<span>
						<a href="http://es6.ruanyifeng.com/#docs/promise">参考资料</a> <br>
						Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 <br>
						resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 <br>
						Promise 新建后就会立即执行。
<pre><code data-language="javascript">
	const promise = new Promise(function(resolve, reject) {
	  // ... some code

	  if (/* 异步操作成功 */){
	    resolve(value);
	  } else {
	    reject(error);
	  }
	});
</code></pre>	
					</span>
				</li>
				<li>
					promise.<a href="">then</a><em>(fn(value),[fn(error)])</em>
					<span>
						Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。
<pre><code data-language="javascript">
	promise.then(function(value) {
	  // success
	}, function(error) {
	  // failure
	});
</code></pre>
					</span>
				</li>
				<li>
					promise.<a href="">then(fn).then(fn)</a>
					<span>
						采用链式的then，可以指定一组按照次序调用的回调函数。
					</span>
				</li>
				<li>
					promise.<a href="">catch</a><em>(fn(error))</em>
					<span>
						Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]Error</h4>
			<ul style="display: none;">
				<li><a href="">new Error</a>('msg')<span>
					错误对象属性：
					<table>
						<tr>
							<th>属性</th>
							<th>描述</th>
						</tr>
						<tr>
							<td>err.message</td>
							<td>错误提示信息</td>
						</tr>
						<tr>
							<td>err.name</td>
							<td>错误名称（非标准属性）</td>
						</tr>
						<tr>
							<td>err.stack</td>
							<td>错误的堆栈（非标准属性）</td>
						</tr>
					</table>
					<br>
					原生错误类型：
					<table>
						<tr>
							<th>名称</th>
							<th>描述</th>
						</tr>
						<tr>
							<td>SyntaxError</td>
							<td>解析代码时发生的语法错误</td>
						</tr>
						<tr>
							<td>ReferenceError</td>
							<td>引用一个不存在的变量时发生的错误；将一个值分配给无法分配的对象</td>
						</tr>
						<tr>
							<td>RangeError</td>
							<td>当一个值超出有效范围时发生的错误</td>
						</tr>
						<tr>
							<td>TypeError</td>
							<td>变量或参数不是预期类型时发生的错误</td>
						</tr>
						<tr>
							<td>URIError</td>
							<td>URI相关函数的参数不正确时抛出的错误</td>
						</tr>
						<tr>
							<td>EvalError</td>
							<td>eval函数没有被正确执行</td>
						</tr>
						<tr>
							<td>自定义错误</td>
							<td><a href="http://javascript.ruanyifeng.com/grammar/error.html">参考资料</a></td>
						</tr>
					</table>

					<br><br>
					如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。所以，我们不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获，一网打尽。<hr>
					涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。<br>
					类似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。
				</span></li>
				<li><a href="">throw</a> err<span>
					throw语句的作用是中断程序执行，抛出一个意外或错误。它接受一个表达式作为参数，可以抛出各种值。 <br>
					throw可以接受各种值作为参数。JavaScript引擎一旦遇到throw语句，就会停止执行后面的语句，并将throw语句的参数值，返回给用户。
				</span></li>
				<li><a href="">try{..}cath(e){..}finally{..}</a><span>
					<pre><code data-language="javascript">
						try {
						    //可能出错的语句
						    throw new Error('出错了!');
						} catch (e) {
						    //捕获e错误对象,try中抛出的错误对象
						} finally {
						    //总会执行
						    //执行finally代码块以后，程序就中断在错误抛出的地方。
						}
					</code></pre>
				</span></li>
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>参考资料<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>+</span>]文档</h4>
			<ul style="display: none;">
				<li><a href="https://developer.mozilla.org/zh-CN/docs/Web">MDN Web技术文档</a></li>
				<li><a href="http://kangax.github.io/compat-table/es6/">ES6支持程度</a></li>
				<li><a href="http://yanhaijing.com/es5/">ECMAScript5规范</a></li>
			</ul>
			<h4>[<span>+</span>]教程</h4>
			<ul style="display: none;">
				<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide">JS指南</a></li>
				<li><a href="http://javascript.ruanyifeng.com">ES5教程</a></li>
				<li><a href="http://es6.ruanyifeng.com">ES6教程</a></li>
			</ul>
			<h4>[<span>+</span>]动态</h4>
			<ul style="display: none;">
				<li><a href="https://www.awesomes.cn/">前端库大全</a></li>
				<li><a href="https://juejin.im/welcome/frontend">掘金社区</a></li>
				<li><a href="https://www.zhihu.com/topic/19550901/hot">知乎话题</a></li>
			</ul>
		</div>
	</div>
</div>