<!-- Map、Set -->
<div class="u-col">
	<div class="u-block">
		<h3>集合<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>+</span>]构建</h4>
			<ul style="display:none;">
				<li>
					<a href="">new Set</a>([arr])
					<span>
						Set是一组key的集合，但不存储value，且key不能重复。<br>
						[...$set] 解构成一个数组
					</span>
				</li>
				<li>
					<a href="">new Map</a>([[val1,val2]])
					<span>
						初始化Map需要一个二维数组 <br>
						map的键可以为任意数据类型，object只能为字符串 <br>
						[...$map] 解构成一个二维数组
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]属性</h4>
			<ul>
				<li>
					set/map.<a href="">size</a>
					<span>
						返回值：数值<br> 
						返回实例的长度
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]增删改查</h4>
			<ul>
				<li>
					set.<a href="">add</a>(key)
					<span>
						返回值：set本身<br>
						添加一个值
					</span>
				</li>
				<li>
					map.<a href="">set</a>(key,val)
					<span>
						返回值：map本身 <br>
						添加新的key-value键值对
					</span>
				</li>
				<li>
					map.<a href="">get</a>(key)
					<span>
						返回值：value | undefined <br>	
						取key的值
					</span>
				</li>
				<li>
					set/map.<a href="">has</a>(key)
					<span>
						返回值：布尔<br>	
						该值是否为实例的成员
					</span>
				</li>
				<li>
					set/map.<a href="">delete</a>(key)
					<span>
						返回值：布尔 <br>
						删除一个值
					</span>
				</li>
				<li>
					set/map.<a href="">clear()</a>
					<span>
						返回值：无 <br>
						清除所有成员
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]遍历</h4>
			<ul>
				<li>
					set/map.<a href="">keys()</a>
					<span>
						返回键名的遍历器 <br>
						set/map.keys()返回的是遍历器，而对象的Object.keys(obj)返回的是数组
					</span>
				</li>
				<li>
					set/map.<a href="">values()</a>
					<span>
						返回键值的遍历器
					</span>
				</li>
				<li>
					set/map.<a href="">entries()</a>
					<span>
						返回所有成员的遍历器
					</span>
				</li>
				<li>
					set/map.<a href="">forEach</a>(fn(val,key,sm))
					<span>
						使用回调函数遍历每个成员 <br>
						Set 结构的键名就是键值，因此第一个参数与第二个参数的值永远都是一样的(并非像数组是索引号)
					</span>
				</li>
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>迭代器/生成器<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]Iterator</h4>
			<ul>
				<li>
					<a href="">[...iterable]</a>
					<span>
						只要具有 Iterator 接口的对象，都可以使用扩展运算符<br>
						[...str] <br>
						[...arr|TypedArray] <br>
						[...set|map] <br>
						[...arguments] <br>
						[...nodeList] 
					</span>
				</li>
				<li>
					for<a href="">(.. of iterable)</a>
					<span>
						for(let key of iterable){} <br>
						任何部署了Interator接口的数据都可以用for..of来遍历 <br>
						String、Array、TypedArray、Map、Set、函数arguments对象、NodeList对象都内置Interator接口，因为它们的原型对象都有一个 Symbol.iterator 方法。 <hr>
						数组使用for .. of 直接取值更快捷
					</span>
				</li>
				<li>
					ite = o.<a href="">[Symbol.iterator]()</a>
					<span>
						一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的” <br>
						Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。<br>
						执行这个函数，就会返回一个遍历器。 <br>
						<a href="http://es6.ruanyifeng.com/#docs/iterator">给对象自定义一个遍历器</a>
					</span>
				</li>
				<li>
					ite.<a href="">next()</a>
					<span>
						每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。
					</span>
				</li>
				<li>
					ite.<a href="">return()</a>
					<span>
						如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法 <br>
						return方法必须返回一个对象 return { done: true };
					</span>
				</li>
				<li>
					ite.<a href="">throw()</a>
					<span>
						
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]Generator</h4>
			<ul>

			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>类型数组<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>+</span>]Buffer</h4>
			<h4>[<span>+</span>]Stream</h4>
			<h4>[<span>-</span>]TypedArray</h4>
			<ul>
				<li>
					<a href="">TypedArray</a>
					<span>
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays">参考资料1</a> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">参考资料2</a> | <a href="http://es6.ruanyifeng.com/#docs/arraybuffer">参考资料3</a>
					</span>
				</li>
			</ul>
		</div>
	</div>
</div>