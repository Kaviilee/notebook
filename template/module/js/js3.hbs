<!-- 函数、对象 -->
<div class="u-col">
	<div class="u-block">
		<h3>对象<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]Object</h4>
			<ul>
				<li><a href="">new Object()</a><span>
					<table>
						<tr>
							<th>创建方法</th>
							<th>演示</th>
						</tr>
						<tr>
							<td>字面量</td>
							<td>
								对象的所有键名都是字符串，可以不加引号。但如果不符合表示名的条件，则需要加引号。<a href="http://javascript.ruanyifeng.com/grammar/object.html">参考资料</a> <br>
								对象的属性之间用逗号分隔，最后一个属性后面可以加逗号，也可以不加。
<pre><code data-language="javascript">
var obj ={
	key:value,
	key:function(){...}
}
</code></pre>	
							</td>
						</tr>
						<tr>
							<td>new运算符</td>
							<td>
<pre><code data-language="javascript">
var obj = new Object();
obj.key = value;
obj.key = function(){...}
</code></pre>
							</td>
						</tr>
						<tr>
							<td>原型创建</td>
							<td>
<pre><code data-language="javascript">
var obj = Object.creat(Object.prototype)
</code></pre>
							</td>
						</tr>
						<tr>
							<td>构造函数</td>
							<td>
<pre><code data-language="javascript">
function Obj(name){
	this.name = value;
	this.key = function (){...}
}
var o = new Obj(name)
</code></pre>
注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。<br>
如果忘记写new运算符，在strict模式下，this.name = name将报错，因为this绑定为undefined，在非strict模式下，this.name = name不报错，因为this绑定为window，于是无意间创建了全局变量name，并且返回undefined，这个结果更糟糕。
							</td>
						</tr>
					</table>
				</span></li>
				<li>obj<a href=""></a>[key]<span>
					<ol>
						<li>访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。</li>
						<li><b>当属性含空格、关键字或为变量时，只能用中括号表示</b></li>
						<li>中括号表示法时，key需要加上引号</li>
					</ol>
				</span></li>
				<li>obj.<a href="">hasOwnProperty()</a><span>
					检测xiaoming是否拥有某一属性，可以用in操作符。<br>
					如果in判断一个属性存在，这个属性不一定是自身原有的，它可能是继承得到的。<br>
					要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法。
				</span></li>
				<li>
					<a href="">delete </a>obj.key
					<span>
						删除属性delete obj.key，删除成功后返回true <br>
						注意，删除一个不存在的属性，delete不报错，而且返回true。 <br>
						只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。<br>
						delete命令只能删除对象本身的属性，无法删除继承的属性 <br>
						delete命令不能删除var命令声明的变量，只能用来删除属性。
					</span>
				</li>
				<li>key <a href="">in</a> obj<span>
					in遍历访问对象的属性/属性值
<pre><code data-language="javascript">
	for (var property in obj) {
		console.log(property);  //遍历对象的全部属性
		console.log(obj[property]); //遍历所有对象的值
	} 
	
	var props = [];
	var i = 0;
	for (props[i++] in obj);
</code></pre>
					它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性 <br>
					它不仅遍历对象自身的属性，还遍历继承的属性。
				</span></li>
			</ul>
			<h4>[<span>-</span>]Map</h4>
			<ul>
				<li><a href="">new Map()</a><span>
					初始化Map需要一个二维数组，或者直接初始化一个空Map。没有字面量方法。
					<pre><code data-language="javascript">var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);</code></pre>
				</span></li>
				<li>map.<a href="">get</a>(key)<span>取key的值，返回值</span></li>
				<li>map.<a href="">set</a>(key,val)<span>添加新的key-value</span></li>
				<li>map.<a href="">has</a>(key)<span>是否存在key，返回布尔值</span></li>
				<li>map.<a href="">delete</a>(key)<span>删除key</span></li>
				<li>key <a href="">of</a> map<span>
					遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。<br>具有iterable类型的集合可以通过新的for ... of循环来遍历。
<pre><code data-language="javascript">
	var a = ['A', 'B', 'C'];
	var s = new Set(['A', 'B', 'C']);
	var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
	for (var x of a) { // 遍历Array
	    console.log('arr:' + x);
	}
	for (var x of s) { // 遍历Set
	    console.log('set:' + x);
	}
	for (var x of m) { // 遍历Map
	    console.log('map:' + x[0] + '=' + x[1]);
	}
</code></pre>
				</span></li>
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>OOP<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]对象</h4>
			<ul>
				<li>
					<em>object</em><a href=""></a>
					<span>
						如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 <br>
					但如果取消某一个变量对于原对象的引用，不会影响到另一个变量。 <br>
					这种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝。 <hr>
					如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。 <hr>
					如果读取一个不存在的键，会返回undefined，而不是报错。
					</span>
				</li>
				<li>
					<a href="">with</a>(obj)
					<span>
						操作同一个对象的多个属性时，提供一些书写的方便. <a href="http://javascript.ruanyifeng.com/grammar/object.html">参考资料</a> <br>
						注意，with区块内部的变量，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。这是因为with区块没有改变作用域，它的内部依然是当前作用域。
					</span>
				</li>
				<li>
					<a href="">Object.defineProperty</a><em>(obj,key,desc)</em>
					<span>
						desc是一个对象。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty()参考资料</a>|<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">Object.defineProperties()参考资料</a>
						<table>
							<tr>
								<th>设置</th>
								<th>描述</th>
							</tr>
							<tr>
								<td>configurable : false/true</td>
								<td>当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除</td>
							</tr>
							<tr>
								<td>enumerable : false/true</td>
								<td>当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中</td>
							</tr>
							<tr>
								<td>value : 属性值</td>
								<td></td>
							</tr>
							<tr>
								<td>writable : false/true</td>
								<td>当且仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变。</td>
							</tr>
						</table>
					</span>
				</li>
				<li>
					<a href="">Object.freeze</a>(obj)
					<span>
						冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。
					</span>
				</li>
				<li>
					<a href="">Object.keys</a>(obj)
					<span>
						查看一个对象的所有属性，返回一个key的数组
					</span>
				</li>
				<li>
					<a href="">Object.entries</a>(obj)
					<span>
						返回一个给定对象自身可枚举属性的键值对的二维数组 <br>
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">Object.create</a>(proto_obj)
					<span>
						使用指定的原型对象和其属性创建一个新的对象
					</span>
				</li>
				<li>
					<a href="">Object.assign</a>(to,from...)
					<span>
						将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。跳过那些值为 null 或 undefined 的源对象。
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">参考资料</a>
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]原型链</h4>
			<ul>
                <li>cst.<a href="">prototype</a><span>
                	构造函数创建的实例的原型，prototype是函数才会有的属性 <br>
                    为减少内存消耗，将公共方法写在构造函数的原型上，<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997235247b53be560ab041a7b10360a567422a78000">参考资料</a>
                </span></li>
                <li>obj.<a href="">__proto__</a><span>
					任何一个对象都有__proto__，实例对象的这个属性指向该对象的原型 <br>
					Object.getPrototypeOf(obj) === CST.prototype
				</span></li>
                <li>proto.<a href="">constructor</a><span>
                    原型对象的这个属性指向构造函数 <br>
                    <img src="image/js/prototype.png" alt=""> <br>
                    实例对象本身并没有constructor属性，但会直接从实例的原型对象查找，所以会得出结果。
                </span></li>
			</ul>
            <h4>[<span>-</span>]继承</h4>
            <ul>
				<li><a href="">Object.create</a>(proto_obj)<span>
					在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型，并且，低版本的IE也无法使用__proto__。 <br>
					Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有。
					<pre><code data-language="javascript">
						// 原型对象:
						var Student = {
						    name: 'Robot',
						    height: 1.2,
						    run: function () {
						        console.log(this.name + ' is running...');
						    }
						};

						function createStudent(name) {
						    // 基于Student原型创建一个新对象:
						    var s = Object.create(Student);
						    // 初始化新对象:
						    s.name = name;
						    return s;
						}

						var xiaoming = createStudent('小明');
						xiaoming.run(); // 小明 is running...
						xiaoming.__proto__ === Student; // true
					</code></pre>
				</span></li>
                <li><em>demo</em><a href=""></a><span>
					<pre><code data-language="javascript">
						function inherits(Child, Parent) {
						    var F = function () {};
						    F.prototype = Parent.prototype;
						    Child.prototype = new F();
						    Child.prototype.constructor = Child;
						}
					</code></pre>
					<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997013405abfb7f0e1904a04ba6898a384b1e925000">参考资料</a>
                </span></li>
                <li><em>demo</em><a href=""></a><span>
					<pre><code data-language="javascript">
					    function Student(props) {
					        this.name = props.name || '匿名'; // 默认值为'匿名'
					        this.grade = props.grade || 1; // 默认值为1
					    }

					    Student.prototype.hello = function () {
					        alert('Hello, ' + this.name + '!');
					    };

					    function createStudent(props) {
					        return new Student(props || {})
					    }
					</code></pre>
                    <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997235247b53be560ab041a7b10360a567422a78000">参考资料</a>
                </span></li>
            </ul>
            <h4>[<span>-</span>]类</h4>
            <ul>
                <li><a href="">class </a>ClassName<span>
					<pre><code data-language="javascript">
					class Student {
					    constructor(name) {
					        this.name = name;
					    }

					    hello() {
					        alert('Hello, ' + this.name + '!');
					    }
					}
					var test = new Student('test')
					</code></pre>
                </span></li>
                <li>class Child <a href="">extends</a> Parent<span>
					<pre><code data-language="javascript">
					class PrimaryStudent extends Student {
					    constructor(name, grade) {
					        super(name); // 记得用super调用父类的构造方法!
					        this.grade = grade;
					    }

					    myGrade() {
					        alert('I am at grade ' + this.grade);
					    }
					}
					</code></pre>
					PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。
                </span></li>
                <li><a href="">super</a>(parent_key)<span></span></li>
            </ul>
		</div>
	</div>
</div>