<!-- 函数、对象 -->
<div class="u-col">
	<div class="u-block">
		<h3>对象<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]Object</h4>
			<ul>
				<li><a href="">new Object()</a><span>
					<table>
						<tr>
							<th>创建方法</th>
							<th>演示</th>
						</tr>
						<tr>
							<td>字面量</td>
							<td>
<pre><code data-language="javascript">
var obj ={
	key:value,
	key:function(){...}
}
</code></pre>	
							</td>
						</tr>
						<tr>
							<td>new运算符</td>
							<td>
<pre><code data-language="javascript">
var obj = new Object();
obj.key = value;
obj.key = function(){...}
</code></pre>
							</td>
						</tr>
						<tr>
							<td>构造函数</td>
							<td>
<pre><code data-language="javascript">
function Obj(name){
	this.name = value;
	this.key = function (){...}
}
var o = new Obj(name)
</code></pre>
注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。<br>
如果忘记写new运算符，在strict模式下，this.name = name将报错，因为this绑定为undefined，在非strict模式下，this.name = name不报错，因为this绑定为window，于是无意间创建了全局变量name，并且返回undefined，这个结果更糟糕。
							</td>
						</tr>
					</table>
				</span></li>
				<li>obj<a href=""></a>[key]<span>
					<ol>
						<li>访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。</li>
						<li><b>当属性含空格、关键字或为变量时，只能用中括号表示</b></li>
						<li><strong>中括号表示法时，key需要加上引号法</strong></li>
					</ol>
				</span></li>
				<li>obj.<a href="">hasOwnProperty()</a><span>
					检测xiaoming是否拥有某一属性，可以用in操作符。<br>
					如果in判断一个属性存在，这个属性不一定是自身原有的，它可能是继承得到的。<br>
					要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法。
				</span></li>
				<li><a href="">delete </a>obj.key<span>删除属性delete obj.key</span></li>
				<li>key <a href="">in</a> obj<span>
					in遍历访问对象的属性/属性值
<pre><code data-language="javascript">
	for (var property in obj) {
		console.log(property);  //遍历对象的全部属性
		console.log(obj[property]); //遍历所有对象的值
	} 
</code></pre>
				</span></li>
			</ul>
			<h4>[<span>+</span>]Map</h4>
			<ul>
				<li><a href="">new Map()</a><span>
					初始化Map需要一个二维数组，或者直接初始化一个空Map。没有字面量方法。
					<pre><code data-language="javascript">var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);</code></pre>
				</span></li>
				<li>map.<a href="">get</a>(key)<span>取key的值，返回值</span></li>
				<li>map.<a href="">set</a>(key,val)<span>添加新的key-value</span></li>
				<li>map.<a href="">has</a>(key)<span>是否存在key，返回布尔值</span></li>
				<li>map.<a href="">delete</a>(key)<span>删除key</span></li>
				<li>key <a href="">of</a> map<span>
					遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。<br>具有iterable类型的集合可以通过新的for ... of循环来遍历。
<pre><code data-language="javascript">
	var a = ['A', 'B', 'C'];
	var s = new Set(['A', 'B', 'C']);
	var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
	for (var x of a) { // 遍历Array
	    console.log('arr:' + x);
	}
	for (var x of s) { // 遍历Set
	    console.log('set:' + x);
	}
	for (var x of m) { // 遍历Map
	    console.log('map:' + x[0] + '=' + x[1]);
	}
</code></pre>
				</span></li>
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>函数<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]Function</h4>
			<ul>
				<li><a href="">function</a>()<span>
					function fn(arg){...} <br>
					var fn = function(arg){...} <br>
					在第二种方式下，function (x) { ... }是一个匿名函数，它没有函数名。<br>
					但是，这个匿名函数赋值给了变量fn，所以，通过变量fn就可以调用该函数。<br>
					上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。
				</span></li>
				<li><a href="">(function(n){})(n)</a><span>
					匿名函数自执行,可以初始化各项值,但如果需要的变量并不是一开始初始化有的,则不可以,否则无法读取。<br>
					返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。<br>
					如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变
				</span></li>
				<li><a href="">x => x * x</a><span>
<pre><code data-language="javascript">
	//单个参数
	var result = x => x * x
	function (x) {
	    return x * x;
	}
	//语句块
	x => {
	    if (x > 0) {
	        return x * x;
	    }
	    else {
	        return - x * x;
	    }
	}
	//多个参数
	(x, y) => x * x + y * y
</code></pre>
				箭头函数相当于匿名函数，省略了return。<br>
				箭头函数本身返回的是一个函数，将一个箭头函数赋值给一个变量后，运行其才能执行该箭头函数，箭头函数左侧的为函数参数。<br>
				箭头函数内部的this是词法作用域，由上下文确定，修订了以前用that保存this的情况。
				<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000">参考资料</a>
				</span></li>
			</ul>
			<h4>[<span>+</span>]Generator</h4>
			<ul style="display:none;">
				<li><a href="">function*</a>()<span></span></li>
				<li><a href="">yield</a> val<span></span></li>
				<li>g.<a href="">next()</a><span></span></li>
			</ul>
			<h4>[<span>-</span>]内部</h4>
			<ul>
				<li><a href="">return</a><span>
					如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined.
				</span></li>
				<li><a href="">arguments</a><span>
					函数的参数对象，类数组对象，但不是数组，实际上arguments最常用于判断传入参数的个数。
					<table>
						<tr>
							<th>对象值</th>
							<th>描述</th>
						</tr>
						<tr>
							<td>arguments[0]</td>
							<td>第一个参数名字</td>
						</tr>
						<tr>
							<td>arguments.length</td>
							<td>参数的个数</td>
						</tr>
						<tr>
							<td>arguments.callee</td>
							<td>主体函数本身，拥有这个参数对象的函数</td>
						</tr>
					</table>
					rest参数：<br>
<pre><code data-language="javascript">
	function foo(a, b, ...rest) {
	    console.log('a = ' + a);
	    console.log('b = ' + b);
	    console.log(rest);
	    //rest: [array]
	}
</code></pre>
				</span></li>
				<li><a href="">this</a><span>
					<table>
						<tr>
							<th>当前环境</th>
							<th>this指向</th>
						</tr>
						<tr>
							<td>函数</td>
							<td>非严格模式：window <br>
							strict模式：undefined
							</td>
						</tr>
						<tr>
							<td>对象</td>
							<td>object<br>
							直接定义对象的函数，并单独存储函数后，调用函数时不可行，除非以obj.fn()进行调用。<br>
							对象属性函数里的函数（闭包）调用对象时可指定var that = this来获取正确this
							</td>
						</tr>
					</table>
					<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345005399057070809cfaa347dfb7207900cfd116fb000" target="_blank">参考资料</a>
				</span></li>
			</ul>
			<h4>[<span>-</span>]方法</h4>
			<ul>
				<li>fn<a href="">.apply</a>(obj,[arg])<span>
					fn.apply(作用域，[传递参数]/arguments) <br>
					要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。
				</span></li>
				<li>fn<a href="">.call</a>(obj,arg)<span>
					fn.call(作用域，[传递参数]),apply与call均让函数作用于特定作用域,call必须明确传入每一个参数。<br>
					apply()把参数打包成Array再传入；call()把参数按顺序传入 <br>
					对普通函数调用，我们通常把this绑定为null。
					</span></li>
				<li>fn<a href="">.bind</a>(obj)<span>
					bind(作用目标) 创建一个作用于某目标的函数实例 <br>
					bind()方法会创建一个新函数。当这个新函数被调用时，bind()的第一个参数将作为它运行时的 this, 之后的一序列参数将会在传递的实参前传入作为它的参数。
				</span></li>
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>类与面向对象<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]原型继承</h4>
			<ul>
				<li>obj.<a href="">__proto__</a><span>
					JS中所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。
				</span></li>
				<li><a href="">Object.create</a>(proto_obj)<span>
					在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型，并且，低版本的IE也无法使用__proto__。Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有。
<pre><code data-language="javascript">
	// 原型对象:
	var Student = {
	    name: 'Robot',
	    height: 1.2,
	    run: function () {
	        console.log(this.name + ' is running...');
	    }
	};

	function createStudent(name) {
	    // 基于Student原型创建一个新对象:
	    var s = Object.create(Student);
	    // 初始化新对象:
	    s.name = name;
	    return s;
	}

	var xiaoming = createStudent('小明');
	xiaoming.run(); // 小明 is running...
	xiaoming.__proto__ === Student; // true
</code></pre>
				</span></li>
                <li><em>demo</em><a href=""></a><span>
<pre><code data-language="javascript">
function inherits(Child, Parent) {
    var F = function () {};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
}
</code></pre>
<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997013405abfb7f0e1904a04ba6898a384b1e925000">参考资料</a>
                </span></li>
			</ul>
            <h4>[<span>-</span>]构造函数</h4>
            <ul>
                <li>obj.<a href="">constructor</a><span>
                    用new Obj()创建的对象还从原型上获得了一个constructor属性，它指向构造函数本身
                </span></li>
                <li>cst.<a href="">prototype</a><span>
                    为减少内存消耗，将公共方法写在构造函数的原型上 <br>
                    <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997235247b53be560ab041a7b10360a567422a78000">参考资料</a>
                </span></li>
                <li><em>demo</em><a href=""></a><span>
<pre><code data-language="javascript">
    function Student(props) {
        this.name = props.name || '匿名'; // 默认值为'匿名'
        this.grade = props.grade || 1; // 默认值为1
    }

    Student.prototype.hello = function () {
        alert('Hello, ' + this.name + '!');
    };

    function createStudent(props) {
        return new Student(props || {})
    }
</code></pre>
                    <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997235247b53be560ab041a7b10360a567422a78000">参考资料</a>
                </span></li>
            </ul>
            <h4>[<span>-</span>]类</h4>
            <ul>
                <li><a href="">class </a>ClassName<span>
<pre><code data-language="javascript">
class Student {
    constructor(name) {
        this.name = name;
    }

    hello() {
        alert('Hello, ' + this.name + '!');
    }
}
var test = new Student('test')
</code></pre>
                </span></li>
                <li>class Child <a href="">extends</a> Parent<span>
<pre><code data-language="javascript">
class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert('I am at grade ' + this.grade);
    }
}
</code></pre>
PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。
                </span></li>
                <li><a href="">super</a>(parent_key)<span></span></li>
            </ul>
		</div>
	</div>
</div>