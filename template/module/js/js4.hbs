<!-- 函数 -->
<div class="u-col">
	<div class="u-block">
		<h3>函数<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]Function</h4>
			<ul>
				<li>
					<em>fn</em><a href=""></a>
					<span>
						<b>参数</b> <br>
						函数不能省略靠前的参数，如果一定要省略靠前的参数，只有显式传入undefined。 <br>
						函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。即在函数内部，传入的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。这意味着，在函数体内修改参数值，不会影响到函数外部。 <br>
						函数参数如果是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。 <br>
						注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。<a href="http://javascript.ruanyifeng.com/grammar/function.html">参考资料</a> <br>
						如果有同名的参数，则取最后出现的那个值。
						<hr>
						<b>作用域</b> <br>
						函数作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。<br>
						函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。  <br>
						同样的，函数体内部声明的函数，作用域绑定函数体内部。
						<hr>
						<b>属性</b> <br>
						fn.name : 返回紧跟在function关键字之后的那个函数名(匿名函数为空字符串) <br>
						fn.length : 返回函数预期传入的参数个数，即函数定义之中的参数个数(定义之时的个数)。 <br>
						fn.toString() : 返回函数的源码，注释也可以返回。
						<hr>
						<b>闭包</b> <br>
						定义在一个函数内部的函数。闭包最大的特点，就是它可以“记住”诞生的环境。 <br>
						闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。 <br>
						返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 <br>
						如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变
					</span>
				</li>
				<li>
					<a href="">new</a> fn
					<span>
						<a href="http://javascript.ruanyifeng.com/oop/basic.html">new命令原理</a> <br>
						new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。 <br>
						函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined <hr>
						<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997235247b53be560ab041a7b10360a567422a78000">示例代码</a> <br>
						方法应挂载在prototype上，避免内存占用
					</span>
				</li>
				<li><a href="">function</a>()<span>
					<b>1.function命令 - 函数的声明</b><br>
					function fn(arg){...} <br>
					<hr>
					<b>2.函数表达式</b> <br>
					var fn = function(arg){...} <br>
					在第二种方式下，function (x) { ... }是一个匿名函数，它没有函数名。<br>
					但是，这个匿名函数赋值给了变量fn，所以，通过变量fn就可以调用该函数。<br>
					上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。 <br>
					采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。 <br>
					<hr>
					<b>3.Function构造函数</b> <br>
					var fn = new Function(arg..,函数体) <br>
					你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。
					<hr>
					如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 <br>
					如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。 <a href="http://javascript.ruanyifeng.com/grammar/function.html">参考资料</a> <br>
					根据ECMAScript的规范，不得在非函数的代码块中声明函数。
				</span></li>
				<li><a href="">(function(n){})(n)</a><span>
					IIFE = Immediately-Invoked Function Expression,立即调用的函数表达式 <br>
					匿名函数自执行,可以初始化各项值,但如果需要的变量并不是一开始初始化有的,则不可以,否则无法读取。<br>
				</span></li>
				<li><a href="">x => x * x</a><span>
					<pre><code data-language="javascript">
						//单个参数
						var result = x => x * x
						function (x) {
						    return x * x;
						}
						//语句块
						x => {
						    if (x > 0) {
						        return x * x;
						    }
						    else {
						        return - x * x;
						    }
						}
						//多个参数
						(x, y) => x * x + y * y
					</code></pre>
				箭头函数相当于匿名函数，省略了return。<br>
				箭头函数本身返回的是一个函数，将一个箭头函数赋值给一个变量后，运行其才能执行该箭头函数，箭头函数左侧的为函数参数。<br>
				箭头函数内部的this是词法作用域，由上下文确定，修订了以前用that保存this的情况。
				<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000">参考资料</a>
				</span></li>
			</ul>
			<h4>[<span>-</span>]内部</h4>
			<ul>
				<li><a href="">return</a><span>
					如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined.
				</span></li>
				<li><a href="">arguments</a><span>
					函数的参数对象，类数组对象，但不是数组，实际上arguments最常用于判断传入参数的个数。 <br>
					严格模式下为只读对象，不允许修改。
						<tr>
							<th>对象值</th>
							<th>描述</th>
						</tr>
						<tr>
							<td>arguments[0]</td>
							<td>第一个参数名字</td>
						</tr>
						<tr>
							<td>arguments.length</td>
							<td>参数的个数</td>
						</tr>
						<tr>
							<td>arguments.callee</td>
							<td>主体函数本身，拥有这个参数对象的函数 (严格模式禁用)</td>
						</tr>
					</table>
					rest参数：<br>
					<pre><code data-language="javascript">
						function foo(a, b, ...rest) {
						    console.log('a = ' + a);
						    console.log('b = ' + b);
						    console.log(rest);
						    //rest: [array]
						}
					</code></pre>
				</span></li>
				<li><a href="">this</a><span>
					<table>
						<tr>
							<th>当前环境</th>
							<th>this指向</th>
						</tr>
						<tr>
							<td>函数</td>
							<td>非严格模式：window <br>
							strict模式：undefined
							</td>
						</tr>
						<tr>
							<td>对象</td>
							<td>object<br>
							直接定义对象的函数，并单独存储函数后，调用函数时不可行，除非以obj.fn()进行调用。<br>
							对象属性函数里的函数（闭包）调用对象时可指定var that = this来获取正确this
							</td>
						</tr>
					</table>
					<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345005399057070809cfaa347dfb7207900cfd116fb000" target="_blank">参考资料1</a> | <a href="http://javascript.ruanyifeng.com/oop/this.html">参考资料2</a>
				</span></li>
			</ul>
			<h4>[<span>-</span>]方法</h4>
			<ul>
				<li>fn<a href="">.apply</a>(obj,[arg])<span>
					fn.apply(作用域，[传递参数]/arguments) <br>
					要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。
				</span></li>
				<li>fn<a href="">.call</a>(obj,arg)<span>
					fn.call(作用域，[传递参数]),apply与call均让函数作用于特定作用域,call必须明确传入每一个参数。<br>
					apply()把参数打包成Array再传入；call()把参数按顺序传入 <br>
					对普通函数调用，我们通常把this绑定为null。 <br>
					如果参数为空、null和undefined，则默认传入全局对象。
					</span></li>
				<li>fn<a href="">.bind</a>(obj)<span>
					bind(作用目标) 创建一个作用于某目标的函数实例 <br>
					bind()方法会创建一个新函数。当这个新函数被调用时，bind()的第一个参数将作为它运行时的 this, 之后的一序列参数将会在传递的实参前传入作为它的参数。
				</span></li>
			</ul>
			<h4>[<span>+</span>]Generator</h4>
			<ul style="display:none;">
				<li><a href="">function*</a>()<span></span></li>
				<li><a href="">yield</a> val<span></span></li>
				<li>g.<a href="">next()</a><span></span></li>
			</ul>
			<h4>[<span>-</span>] 定时器</h4>
            <ul>
            	<li>
            		<a href="">setTimeout</a>(fn,time)
            		<span>
            			在指定的毫秒数后调用函数或计算表达式 <br>
            			setTimeout还允许添加更多的参数，它们将被传入推迟执行的函数（回调函数），IE 9.0及以下版本，只允许setTimeout有两个参数，不支持更多的参数。 <br>
            			<a href="http://javascript.ruanyifeng.com/advanced/timer.html#toc4">当time=0时的应用，同样需等待队列完成</a>
            		</span>
            	</li>
            	<li>
            		<a href="">setInterval</a>(fn,time)
            		<span>
            			按照指定的周期（以毫秒计）来调用函数或计算表达式
            		</span>
            	</li>
            	<li>
            		<a href="">clearTimeout</a>(timeout)
            		<span>
            			取消由 setTimeout() 方法设置的 timeout
            		</span>
            	</li>
            	<li>
            		<a href="">clearInterval</a>(timeout)
            		<span>
            			取消由 setInterval() 设置的 timeout
            		</span>
            	</li>
            </ul>
		</div>
	</div>
	<div class="u-block">
		<h3>数据<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]JSON</h4>
			<ul>
				<li><em>json</em><a href=""></a><span>
					概念：
					<br />它是一种表示结构化数据的形式，JSON是一个格式化的字符串，文件格式后缀为.json
					<hr>
					语法：
					<br />简单值：字符串、数值、布尔值、null，不支持undefined
					<br />对象：一组无序的键值对
					<br />数组：一组有序的值的列表，可以通过索引来访问
					<hr>
					JSON与JS的区别：
					<br />JSON字符串必须使用双引号（单引号会导致语法错误），且对象的属性必须加双引号
					<br />在JS中直接引入一段JSON数据应该用单引号将其括起来，因为它其实代表一个字符串
					<br />如：'{"name" : "Lee","age" : 100}' JSON数组与对象比普通JS少了分号与赋值，其本身表示的是字符串
					<hr>
					兼容性：
					<br>IE7及IE7-需要引用库文件 <a href="https://github.com/douglascrockford/JSON-js/">json-js</a>
					<textarea><!--[if lte IE 7]> json2.js <![endif]--></textarea>
					<hr>
					执行优先级：
					<br>toJSON() --> 过滤参数 --> 标准序列化 --> 缩进 
如在toJSON中已被过滤的键值则就算过滤参数中仍有设置也已无效
				</span></li>
				<li><a href="">JSON.stringify</a><em>(obj,[arr(key)|fn(key,val)|null],[space|num])</em><span>
					js对象 -> json字符串 <hr>
					参数1：传入的对象。<br>
					如有键值为函数时，会排除该成员。我们可以在转换前将函数用.toString()方法转换为字符串来避免以上问题的发生。<br>
					如有键值为日期对象时，会转为字符串。
					<hr>
					参数2：用于转换结果的函数或数组 <br>
					当为数组时，显示指定的key，['key1','key2'] <br>
					当为函数时，每个键值对根据函数规则处理，function(key,value){...return value}，<b>函数需返回新的value</b>。<b>如果此函数返回 undefined，则排除成员。</b>
					<hr>
					参数3：缩进空格，当不传入fn只设置缩进时，第2个参数传入null。如果space 是一个数字，则返回值文本在每个级别缩进指定数目的空格。
				</span></li>
				<li><a href="">JSON.parse</a>(json,[fn(key,val)])<span>
					json字符串 -> js对象 <br>
					转换函数需返回value值。
				</span></li>
				<li>obj.<a href="">toJSON</a><em>:fn(){return json}</em><span>
				   JS对象中添加toJSON()方法，自定义过滤一些数据，返回新的对象
<pre><code data-language="javascript">
	var xiaoming = {
	    name: '小明',
	    age: 14,
	    gender: true,
	    height: 1.65,
	    grade: null,
	    'middle-school': '\"W3C\" Middle School',
	    skills: ['JavaScript', 'Java', 'Python', 'Lisp'],
	    toJSON: function () {
	        return { // 只输出name和age，并且改变了key：
	            'Name': this.name,
	            'Age': this.age
	        };
	    }
	};

	JSON.stringify(xiaoming); // '{"Name":"小明","Age":14}'
</code></pre>
				</span></li>
			</ul>
			<h4>[<span>-</span>]Ajax</h4>
			<ul>
				<li></li>
			</ul>
			<h4>[<span>-</span>]Cookie</h4>
			<ul>
				<li>
					document.<a href="">cookie</a>
					<span>
						key=val1,val2;key=val3,val4
					</span>
				</li>
			</ul>
		</div>
	</div>
</div>