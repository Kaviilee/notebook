<!-- 对象 -->
<div class="u-col">
	<div class="u-block">
		<h3>对象<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>+</span>]构建</h4>
			<ul style="display:none;">
				<li>
					<a href="">{key:val,...}</a>
					<span>
						字面量创建方法 <br>
						对象的属性之间用逗号分隔，最后一个属性后面可以加逗号，也可以不加。 <br>
						对象的所有键名都是字符串，可以不加引号。但如果不符合表示名的条件，则需要加引号。<a href="http://javascript.ruanyifeng.com/grammar/object.html">参考资料</a> <hr>
						如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 <br>
						但如果取消某一个变量对于原对象的引用，不会影响到另一个变量。 <br>
						这种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝。 <br>
						故在设置一个新的对象继承旧对象时，不能直接通过new.prototype = old.prototype进行设置，否则对new原型的任何修改，将直接会影响旧的原型对象。
						<hr>
						如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。 <hr>
						如果读取一个不存在的键，会返回undefined，而不是报错。
					</span>
				</li>
				<li>
					<a href="">new Constructor()</a>
					<span>
						用构造函数创建 <br>
						<pre><code data-language="javascript">
							function Obj(opts){
								this.key = value
							}
							var o = new Obj(opts)
						</code></pre>
						注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。<br>
						如果忘记写new运算符，在strict模式下，this.name = name将报错，因为this绑定为undefined，在非strict模式下，this.name = name不报错，因为this绑定为window，于是无意间创建了全局变量name，并且返回undefined，这个结果更糟糕。
					</span>
				</li>
				<li>
					<a href="">new Object()</a>
					<span>
						var obj = new Object(); <br>
						obj.key = value;
					</span>
				</li>
				<li>
					<a href="">Object.creat(Object.prototype)</a>
					<span>
						var obj = Object.creat(Object.prototype) <br>
						从Object原型创建
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]属性</h4>
			<ul style="display:none;">
				<li>
					obj.<a href=""></a>key
					<span>
						当属性含空格、关键字或为变量时，只能用中括号表示 <br>
						不能对一个未声明的对象直接指定属性
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]属性描述</h4>
			<ul>
				<li>
					Desciptor<a href=""></a>
					<span>
						属性描述对象。 <br>
						数据对象与DOM对象的双向绑定：<a href="http://javascript.ruanyifeng.com/stdlib/attributes.html">参考资料</a>
					</span>
				</li>
				<li>
					desciptor.<a href="">value</a>
					<span>
						存放该属性的属性值，默认为undefined
					</span>
				</li>
				<li>
					desciptor.<a href="">writable</a>
					<span>
						存放一个布尔值，表示属性值是否可改变	
					</span>
				</li>
				<li>
					desciptor.<a href="">enumerable</a>
					<span>
						存放一个布尔值，表示该属性是否可枚举
					</span>
				</li>
				<li>
					desciptor.<a href="">configurable</a>
					<span>
						存放一个布尔值，表示“可配置性”。如果设为false，将阻止某些操作改写该属性，比如，无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。
					</span>
				</li>
				<li>
					desciptor.<a href="">get</a>
					<span>
						存放一个函数，表示该属性的取值函数（getter），默认为undefined
					</span>
				</li>
				<li>
					desciptor.<a href="">set</a>
					<span>
						存放一个函数，表示该属性的存值函数（setter），默认为undefined
					</span>
				</li>
				<li>
					<a href="">Object.getOwnPropertyDescriptor</a>(o,prop)
					<span>
						返回指定对象上一个自有属性对应的属性描述符。
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">Ojbect.defineProperty</a><em>(o,prop,desciptor)</em>
					<span>
						在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 <br>
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">参考资料</a>
					</span>
				</li>
				<li>
					obj.<a href="">propertyIsEnumerable</a>(key)
					<span>
						判断某个属性是否可枚举
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]检测</h4>
			<ul>
				<li>
					obj.<a href="">hasOwnProperty</a>(key)
					<span>
						检测对象是否拥有某一属性（非原型继承） <br>
						返回值：布尔
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]继承/克隆</h4>
			<ul>
				<li>
					<a href="">Object.assign</a>(to,from...)
					<span>
						将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。跳过那些值为 null 或 undefined 的源对象。
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">参考资料</a>
						<hr>
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]取值方法</h4>
			<ul style="display:none;">
				<li>
					<a href="">Object.getOwnPropertyNames</a><em>(obj)</em>
					<span>
						返回直接定义在某个对象上面的全部属性的名称。 <br>
						返回一个数组，成员是对象本身的所有属性的键名，不包含继承的属性键名。
					</span>
				</li>
				<li>
					<a href="">Object.keys</a>(obj)
					<span>
						查看一个对象的所有属性，返回一个key的数组，返回可枚举的属性 <br>
						Object.getOwnPropertyNames(obj)方法还返回不可枚举的属性名 <br>
						由于JavaScript没有提供计算对象属性个数的方法，所以可以用这两个方法代替 <br>
						Object.keys(o).length <br>
						Object.getOwnPropertyNames(o).length
					</span>
				</li>
				<li>
					<a href="">Object.values</a>(obj)
					<span>
						返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。
					</span>
				</li>
				<li>
					<a href="">Object.entries</a>(obj)
					<span>
						返回一个给定对象自身可枚举属性的键值对的二维数组 <br>
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">Object.getOwnPropertySymbols</a>(obj)
					<span>
						返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]状态控制</h4>
			<ul style="display:none;">
				<li>
					<a href="">Object.preventExtensions</a>(obj)
					<span>
						防止对象扩展
					</span>
				</li>
				<li>
					<a href="">Object.isExtensible</a>(obj)
					<span>
						判断对象是否可扩展
					</span>
				</li>
				<li>
					<a href="">Object.seal</a>(obj)
					<span>
						禁止对象配置
					</span>
				</li>
				<li>
					<a href="">Object.isSealed</a>(obj)
					<span>
						判断一个对象是否可配置
					</span>
				</li>
				<li>
					<a href="">Object.freeze</a>(obj)
					<span>
						冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。
					</span>
				</li>
				<li>
					<a href="">Object.isFrozen</a>(obj)
					<span>
						判断一个对象是否被冻结
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]其它</h4>
			<ul>
				<li>
					obj.<a href="">valueOf</a>()
					<span>
						可通过自定义valueOf的返回值来替换原型的返回值，以达到自动转换计算时预期的结果。
					</span>
				</li>
				<li>
					obj.<a href="">toString</a>()
					<span>
						可通过自定义toString方法替换原型的返回值。  <br>
						Object.prototype.toString.call(value) 可判断其构造函数：
						<table>
							<tr>
								<th>value</th>
								<th>返回值</th>
							</tr>
							<tr>
								<td>数值</td>
								<td>[object Number]</td>
							</tr>
							<tr>
								<td>字符串</td>
								<td>[object String]</td>
							</tr>
							<tr>
								<td>布尔值</td>
								<td>[object Boolean]</td>
							</tr>
							<tr>
								<td>undefined</td>
								<td>[object Undefined]</td>
							</tr>
							<tr>
								<td>null</td>
								<td>[object Null]</td>
							</tr>
							<tr>
								<td>数组</td>
								<td>[object Array]</td>
							</tr>
							<tr>
								<td>arguments对象</td>
								<td>[object Arguments]</td>
							</tr>
							<tr>
								<td>函数</td>
								<td>[object Function]</td>
							</tr>
							<tr>
								<td>Error对象</td>
								<td>[object Error]</td>
							</tr>
							<tr>
								<td>Date对象</td>
								<td>[object Date]</td>
							</tr>
							<tr>
								<td>RegExp对象</td>
								<td>[object RegExp]</td>
							</tr>
							<tr>
								<td>其他对象</td>
								<td>[object Object]</td>
							</tr>
						</table>
					</span>
				</li>
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>类<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]类</h4>
			<ul>
				<li><a href="">class </a>Name<span>
<pre><code data-language="javascript">
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
var test = new Point(1,2)
</code></pre>
					1.constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 <br>
					2.类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 <br>
					3.类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。 <br>
					4.var MyClass = class Me{...} 表达式的方式 <a href="http://es6.ruanyifeng.com/#docs/class#Class-表达式">参考资料</a> <br>
					5.类不存在变量提升 <br>
					6.
                </span></li>
                <li>
                	<a href="">static</a> fn
                	<span>
                		类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 <br>
                		注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。 <hr>
                		ES6 明确规定，Class 内部只有静态方法，没有静态属性。 <br>
                		目前需要通过在类外面使用Class.prop来定义
                	</span>
                </li>
			</ul>
			<h4>[<span>-</span>]类继承</h4>
			<ul>
				<li><a href="">class $child extends $parent</a><span>
<pre><code data-language="javascript">
class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert('I am at grade ' + this.grade);
    }
}
</code></pre>
					PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。
                </span></li>
                <li><a href="">super</a>(parent_key)<span>
                	super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。<br>
                	1.super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。 <br>
                	2.super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
                </span></li>
			</ul>
			<h4>[<span>-</span>]原型链</h4>
			<ul>
				<li>
					cst.<a href="">prototype|super</a>
					<span>
                		返回值：构造函数创建的实例的原型（prototype是函数才会有的属性） <br>
                    	为减少内存消耗，将公共方法写在构造函数的原型上，<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997235247b53be560ab041a7b10360a567422a78000">参考资料</a> <br>
						在改变原型对象时，一般要同时设置constructor属性 <br>
                	</span>
				</li>
				<li>
					pro.<a href="">constructor</a>
					<span>
                    	原型对象的这个属性指向构造函数 <br>
                    	<img src="image/js/prototype.png" alt="">
                	</span>
				</li>
				<li>
					obj.<a href="">constructor</a>
					<span>
						返回值：Object / 构造函数 <br>
						实例本身没有constructor，通过在原型上查找获取
					</span>
				</li>
				<li>
					obj.<a href="">__proto__</a>
					<span>
						返回值：Object / 构造函数原型对象（仅浏览器环境） <br>
						在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型，并且，低版本的IE也无法使用__proto__。 
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]原型方法</h4>
			<ul style="display:none;">
				<li>
					pro.<a href="">isPrototypeOf</a>(obj)
					<span>
						判断当前对象是否为另一个对象的原型 <br>
						Object.prototype处于原型链的最顶端，所以对各种实例都返回true，只有继承null的对象除外。
					</span>
				</li>
				<li>
					<a href="">Object.getPrototypeOf</a>(obj)
					<span>
						获取对象的原型对象
					</span>
				</li>
				<li>
					<a href="">Object.setPrototypeOf</a>(obj,proto)
					<span>
						为现有对象设置原型，返回新对象。
					</span>
				</li>
			</ul>
            <h4>[<span>-</span>]原型继承</h4>
            <ul>
				<li>
					<a href="">Object.create</a>(proto)
					<span>
						于一个原型创建新对象 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">参考资料</a><br>
						不能直接将b的原型赋值给a，否则当b的原型修改时，a的原型也会被更改 <hr>
						Child.prototype = Object.create(Parent.prototype) <br>	Child.prototype.constructor = Child
					</span>
				</li>
            </ul>
        </div>
    </div>
</div>