<!-- Map、Set -->
<div class="u-col">
	<div class="u-block">
		<h3>集合<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>+</span>] 构建</h4>
			<ul style="display:none;">
				<li>
					<a href="">new Set</a>([arr])
					<span>
						Set是一组key的集合，但不存储value，且key不能重复。<br>
						[...$set] 解构成一个数组
					</span>
				</li>
				<li>
					<a href="">new Map</a>([[val1,val2]])
					<span>
						初始化Map需要一个二维数组 <br>
						map的键可以为任意数据类型，object只能为字符串 <br>
						[...$map] 解构成一个二维数组
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] 属性</h4>
			<ul>
				<li>
					set/map.<a href="">size</a>
					<span>
						返回值：数值<br> 
						返回实例的长度
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] 增删改查</h4>
			<ul>
				<li>
					set.<a href="">add</a>(key)
					<span>
						返回值：set本身<br>
						添加一个值
					</span>
				</li>
				<li>
					map.<a href="">set</a>(key,val)
					<span>
						返回值：map本身 <br>
						添加新的key-value键值对
					</span>
				</li>
				<li>
					map.<a href="">get</a>(key)
					<span>
						返回值：value | undefined <br>	
						取key的值
					</span>
				</li>
				<li>
					set/map.<a href="">has</a>(key)
					<span>
						返回值：布尔<br>	
						该值是否为实例的成员
					</span>
				</li>
				<li>
					set/map.<a href="">delete</a>(key)
					<span>
						返回值：布尔 <br>
						删除一个值
					</span>
				</li>
				<li>
					set/map.<a href="">clear()</a>
					<span>
						返回值：无 <br>
						清除所有成员
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] 遍历</h4>
			<ul>
				<li>
					set/map.<a href="">keys()</a>
					<span>
						返回键名的遍历器 <br>
						set/map.keys()返回的是遍历器，而对象的Object.keys(obj)返回的是数组
					</span>
				</li>
				<li>
					set/map.<a href="">values()</a>
					<span>
						返回键值的遍历器
					</span>
				</li>
				<li>
					set/map.<a href="">entries()</a>
					<span>
						返回所有成员的遍历器
					</span>
				</li>
				<li>
					set/map.<a href="">forEach</a>(fn(val,key,sm))
					<span>
						使用回调函数遍历每个成员 <br>
						Set 结构的键名就是键值，因此第一个参数与第二个参数的值永远都是一样的(并非像数组是索引号)
					</span>
				</li>
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>类型数组<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>] Buffer</h4>
			<h4>[<span>-</span>] Stream</h4>
			<h4>[<span>-</span>] TypedArray</h4>
			<ul>
				<li>
					<a href="">TypedArray</a>
					<span>
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Typed_arrays">参考资料1</a> | <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">参考资料2</a> | <a href="http://es6.ruanyifeng.com/#docs/arraybuffer">参考资料3</a>
					</span>
				</li>
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>可迭代对象<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>] Iterable</h4>
			<ul>
				<li>
					<a href="">[...iterable]</a>
					<span>
						只要具有 Iterator 接口的对象，都可以使用扩展运算符<br>
						[...str] <br>
						[...arr|TypedArray] <br>
						[...set|map] <br>
						[...arguments] <br>
						[...nodeList] 
					</span>
				</li>
				<li>
					<a href="">for(.. of iterable)</a>
					<span>
						for(let key of iterable){} <br>
						任何部署了Interator接口的数据都可以用for..of来遍历 <br>
						String、Array、TypedArray、Map、Set、函数arguments对象、NodeList对象都内置Interator接口，因为它们的原型对象都有一个 Symbol.iterator 方法。 <hr>
						数组使用for .. of 直接取值更快捷
					</span>
				</li>
				<li>
					<a href="">for await(.. of iterable)</a>
					<span>
						遍历异步的 Iterator 接口
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] Iterator</h4>
			<ul>
				<li>
					o.<a href="">[Symbol.iterator]</a>
					<span>
						一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的” <br>
						Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。<br>
						执行这个函数，就会返回一个遍历器。 <br>
						<a href="http://es6.ruanyifeng.com/#docs/iterator">给对象自定义一个遍历器</a> <hr>
						由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。
					</span>
				</li>
				<li>
					ite.<a href="">next([val])</a>
					<span>
						每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。
					</span>
				</li>
				<li>
					ite.<a href="">return([val])</a>
					<span>
						如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法 <br>
					</span>
				</li>
				<li>
					ite.<a href="">throw([val])</a>
					<span>
						<a href="http://es6.ruanyifeng.com/#docs/generator#next、throw、return-的共同点">next、throw、return的共同点</a>
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] Generator</h4>
			<ul>
				<li>
					<a href="">function*</a> {ite}
					<span>
						执行 Generator 函数会返回一个遍历器对象 <hr>
						这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法 <br>
						<a href="http://es6.ruanyifeng.com/#docs/generator#Generator-函数的this">Generator的this与new</a> <br>
						var g = Generator.call(Generator.prototype) <br>
						此时Generator函数中的this指向实例g <br>
						var F() = {return Generator.call(Generator.prototype)} <br>
						则可通过 var f = new F() 来生成实例 
					</span>
				</li>
				<li>
					<a href="">yield[*]</a>
					<span>
						暂停标志，遍历器每执行一次next则执行当前yield。<hr>
						yield表达式本身没有返回值，或者说总是返回undefined。<br> 
						next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值，作为当下一个yield依赖上一个yield时使用。 <hr>
						yield表达式后面执行一个函数，函数的返回值，相当于生成器运行了该步骤并返回给遍历器对象value的值。
						Generator 函数也可以不用yield表达式，这时就变成了一个单纯的暂缓执行函数。<hr>
						在Generator函数内部，调用另一个 Generator 函数，需要使用yield* Generator() <br>
						会一次执行完被代理对象的全部步骤
					</span>
				</li>
				<li>
					<a href="">return</a>
					<span>
						结束标志
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] Async Function</h4>
            <ul>
            	<li>
            		<a href="">async function</a> {promise}
            		<span>
            			async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。
            		</span>
            	</li>
            	<li>
            		<a href="">await</a> promise
            		<span>
            			await表示紧跟在后面的表达式需要等待结果 <br>
						async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）
            		</span>
            	</li>
            	<li>
            		<a href="">return</a>
            		<span>
            			async函数内部return语句返回的值，会成为then方法回调函数的参数
            		</span>
            	</li>
            </ul>
			<h4>[<span>-</span>] Async Iterator</h4>
			<ul>
				<li>
					o.<a href="">[Symbol.asyncIterator]</a>
					<span>
						asyncIterator是一个异步遍历器
					</span>
				</li>
				<li>
					aite.<a href="">next()</a> {promise}
					<span>
						调用next方法以后，返回一个 Promise 对象。<br>
						因此，可以使用then方法指定，这个 Promise 对象的状态变为resolve以后的回调函数。<br>
						回调函数的参数，则是一个具有value和done两个属性的对象，这个跟同步遍历器是一样的。
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>] Async Generator</h4>
			<ul>
				<li>
					async <a href="">function*</a> {aite}
					<span>
						返回一个异步遍历器对象
					</span>
				</li>
				<li>
					<a href="">yield*</a>
					<span>
						yield*语句也可以跟一个异步遍历器
					</span>
				</li>
			</ul>
		</div>
	</div>
</div>