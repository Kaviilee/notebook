<!-- ES6 -->
<div class="u-col">
	<div class="u-block">
		<h3>遍历器<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]Set</h4>
			<ul>
				<li><a href="">new Set()</a><span>
					Set是一组key的集合，但不存储value，且key不能重复。<br>
					要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set。
<pre><code data-language="javascript">
	var s1 = new Set(); // 空Set
	var s2 = new Set([1, 2, 3]); // 含1, 2, 3
</code></pre>
				</span></li>
				<li>set.<a href="">add</a>(key)<span>
					s.add(4)
					//Set {1,2,3,4}
				</span></li>
			</ul>
			<h4>[<span>-</span>]Map</h4>
			<ul>
				<li><a href="">new Map()</a><span>
					初始化Map需要一个二维数组，或者直接初始化一个空Map。没有字面量方法。
					<pre><code data-language="javascript">var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);</code></pre>
				</span></li>
				<li>map.<a href="">get</a>(key)<span>取key的值，返回值</span></li>
				<li>map.<a href="">set</a>(key,val)<span>添加新的key-value</span></li>
			</ul>
			<h4>[<span>-</span>]Set/Map</h4>
			<ul>
				<li>
					set/map.<a href="">size</a>
					<span>
						返回实例的成员总数
					</span>
				</li>
				<li>
					set/map.<a href="">has</a>(key)
					<span>
						返回一个布尔值，表示该值是否为实例的成员。
					</span>
				</li>
				<li>set/map.<a href="">delete</a>(key)<span>
					s.delete(3)
				</span></li>
				<li>
					set/map.<a href="">clear()</a>
					<span>
						清除所有成员，没有返回值
					</span>
				</li>
				<li>
					set/map.<a href="">keys()</a>
					<span>
						返回键名的遍历器
					</span>
				</li>
				<li>
					set/map.<a href="">values()</a>
					<span>
						返回键值的遍历器
					</span>
				</li>
				<li>
					set/map.<a href="">entries()</a>
					<span>
						返回所有成员的遍历器
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]Iterable</h4>
			<ul>
				
				<li>ite.<a href="">forEach</a><em>(fn(val,[i],[o]))</em><span>
				每个元素都执行一次回调函数，可应用与Iterable类型 (Array/Map/Set)<br>
				Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身<br>
				Map的回调函数参数依次为value、key和map本身 <br>
				forEach方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用for循环。
				<table>
					<tr>
						<th>类型</th>
						<th>参数</th>
					</tr>
					<tr>
						<td>array</td>
						<td>value,index,array</td>
					</tr>
					<tr>
						<td>set</td>
						<td>value,value,set</td>
					</tr>
					<tr>
						<td>map</td>
						<td>value,key,map</td>
					</tr>
				</table>
<pre><code data-language="javascript">
	var a = ['A', 'B', 'C'];
	a.forEach(function (element, index, array) {
		// element: 指向当前元素的值
		// index: 指向当前索引
		// array: 指向Array对象本身
	alert(element);
	});
</code></pre>
				</span></li>
				<li>key <a href="">of</a> ite<span>
					遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。<br>具有iterable类型的集合可以通过新的for ... of循环来遍历。
<pre><code data-language="javascript">
	var a = ['A', 'B', 'C'];
	var s = new Set(['A', 'B', 'C']);
	var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
	for (var x of a) { // 遍历Array
	    console.log('arr:' + x);
	}
	for (var x of s) { // 遍历Set
	    console.log('set:' + x);
	}
	for (var x of m) { // 遍历Map
	    console.log('map:' + x[0] + '=' + x[1]);
	}
</code></pre>
				</span></li>
			</ul>
			<h4>[<span>+</span>]Iterator</h4>
			<ul style="display:none;">
				<li>
					iterator<a href=""></a>
					<span>
						原生具备 Iterator 接口的数据结构如下 : <br>
						Array,Map,Set,String,TypedArray,函数的 arguments 对象,NodeList 对象
					</span>
				</li>
				<li>
					obj.<a href="">[Symbol.iterator]</a>
					<span>
						<a href="http://es6.ruanyifeng.com/#docs/iterator#默认-Iterator-接口">参考资料</a> <br>
						Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。
					</span>
				</li>
				<li>
					ite.<a href="">next()</a>
					<span>
						每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。
					</span>
				</li>
				<li>
					ite.<a href="">return()</a>
					<span>
						return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。
					</span>
				</li>
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>ES6对象<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>+</span>]Proxy</h4>
			<ul style="display:none;">
				<li>
					<a href="">new Proxy</a>(target,handler)
					<span>
						在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 <br>
						<a href="http://es6.ruanyifeng.com/#docs/proxy">参考资料</a> <hr>
						通过改写return值，可实现链式操作
					</span>
				</li>
				<li>
					<a href="">get</a><em>(target, propKey, receiver)</em>
					<span>
						拦截对象属性的读取，比如proxy.foo和proxy['foo']。
					</span>
				</li>
				<li>
					<a href="">set</a><em>(target, propKey, value, receiver)</em>
					<span>
						拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">has</a><em>(target, propKey)</em>
					<span>
						拦截propKey in proxy的操作，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">deleteProperty</a><em>(target, propKey)</em>
					<span>
						拦截delete proxy[propKey]的操作，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">ownKeys</a><em>(target)</em>
					<span>
						拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
					</span>
				</li>
				<li>
					<a href="">getOwnPropertyDescriptor</a><em>(target, propKey)</em>
					<span>
						拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
					</span>
				</li>
				<li>
					<a href="">defineProperty</a><em>(target, propKey, propDesc)</em>
					<span>
						拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">preventExtensions</a><em>(target)</em>
					<span>
						拦截Object.preventExtensions(proxy)，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">getPrototypeOf</a><em>(target)</em>
					<span>
						拦截Object.getPrototypeOf(proxy)，返回一个对象。
					</span>
				</li>
				<li>
					<a href="">isExtensible</a><em>(target)</em>
					<span>
						拦截Object.isExtensible(proxy)，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">setPrototypeOf</a><em>(target, proto)</em>
					<span>
						拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
					</span>
				</li>
				<li>
					<a href="">apply</a><em>(target, object, args)</em>
					<span>
						拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
					</span>
				</li>
				<li>	
					<a href="">construct</a><em>(target, args)</em>
					<span>
						拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。
					</span>
				</li>
				<li>
					<a href="">Proxy.revocable</a>(target, handler)
					<span>
						返回一个可取消的 Proxy 实例
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]Reflect</h4>
			<ul style="display:none;">
				<li>
					<a href="">Reflect</a>
					<span>
						1.将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。 <br>
						2.修改某些Object方法的返回结果，让其变得更合理。 <br>
						3.让Object操作都变成函数行为。 <br>
						<a href="http://es6.ruanyifeng.com/#docs/reflect">参考资料</a>
					</span>
				</li>
				<li>
					Reflect.<a href="">get</a><em>(target,name,[receiver])</em>
					<span>
						查找并返回target对象的name属性，如果没有该属性，则返回undefined。
					</span>
				</li>
				<li>
					Reflect.<a href="">set</a><em>(target,name,value,[receiver])</em>
					<span>
						设置target对象的name属性等于value
					</span>
				</li>
				<li>
					Reflect.<a href="">has</a><em>(obj,name)</em>
					<span>
						对应name in obj里面的in运算符
					</span>
				</li>
				<li>
					Reflect.<a href="">deleteProperty</a><em>(obj,name)</em>
					<span>
						等同于delete obj[name]，用于删除对象的属性
					</span>
				</li>
				<li>
					Reflect.<a href="">construct</a><em>(target,args)</em>
					<span>
						等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。
					</span>
				</li>
				<li>
					Reflect.<a href="">getPrototypeOf</a><em>(obj)</em>
					<span>
						用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。
					</span>
				</li>
				<li>
					Reflect.<a href="">setPrototypeOf</a><em>(obj,newProto)</em>
					<span>
						用于设置对象的__proto__属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。
					</span>
				</li>
				<li>
					Reflect.<a href="">apply</a><em>(fn,thisArg,args)</em>
					<span>
						等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。
					</span>
				</li>
				<li>
					Reflect.<a href="">defineProperty</a><em>(target,propertyKey,attributes)</em>
					<span>
						基本等同于Object.defineProperty，用来为对象定义属性。
					</span>
				</li>
				<li>
					Reflect.<a href="">getOwnPropertyDescriptor</a><em>(target,propertyKey)</em>
					<span>
						基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象
					</span>
				</li>
				<li>
					Reflect.<a href="">isExtensible</a><em>(target)</em>
					<span>
						对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。
					</span>
				</li>
				<li>
					Reflect.<a href="">preventExtensions</a><em>(target)</em>
					<span>
						对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。
					</span>
				</li>
				<li>
					Reflect.<a href="">ownKeys</a><em>(target)</em>
					<span>
						返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]Promise</h4>
			<ul style="display:none;">
				<li>
					<a href="">new Promise</a><em>(fn(resolve,reject))</em>
					<span>
						<a href="http://es6.ruanyifeng.com/#docs/promise">参考资料</a> <br>
						Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 <br>
						resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 <br>
						Promise 新建后就会立即执行。
<pre><code data-language="javascript">
	const promise = new Promise(function(resolve, reject) {
	  // ... some code

	  if (/* 异步操作成功 */){
	    resolve(value);
	  } else {
	    reject(error);
	  }
	});
</code></pre>	
					</span>
				</li>
				<li>
					promise.<a href="">then</a><em>(fn(value),[fn(error)])</em>
					<span>
						Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。
<pre><code data-language="javascript">
	promise.then(function(value) {
	  // success
	}, function(error) {
	  // failure
	});
</code></pre>
					</span>
				</li>
				<li>
					promise.<a href="">then(fn).then(fn)</a>
					<span>
						采用链式的then，可以指定一组按照次序调用的回调函数。
					</span>
				</li>
				<li>
					promise.<a href="">catch</a><em>(fn(error))</em>
					<span>
						Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。
					</span>
				</li>
			</ul>
		</div>
	</div>
</div>