<!-- 函数 -->
<div class="u-col">
	<div class="u-block">
		<h3>函数<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>+</span>]构建与调用</h4>
			<ul style="display:none;">
				<li>
					<a href="">function name</a><em>(arg){}</em>
					<span>
						函数声明 <br>
						1.使用函数声明时，会提升优先级（一等公民），不包括函数表达式。 <br>
						2.如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。<br>
						3.函数参数是拷贝值传递：对于基本类型，不会修改原值；对于引用类型，拷贝的是指针，如修改原数据属性会改变原数据，如替换整个目标则不修改原数据，此外始终不改变原指针的指向。<a href="http://javascript.ruanyifeng.com/grammar/function.html">参考资料</a> <br>
						4.函数可以被递归，函数可以调用其本身。 <br>
						5.ES6中块级作用域中声明的函数，在块级作用域之外不可引用
					</span>
				</li>
				<li>
					var handle = <a href="">function [name]</a><em>(arg){}</em>
					<span>
						函数表达式<br>
						1.函数表达式是一个匿名函数 <br>
						2.当定义name时，此时可以用name在函数内部指代函数本身，但在函数体外部无效 <br>
						3.函数表达式，不会被提升。<br>
						4.如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。 <a href="http://javascript.ruanyifeng.com/grammar/function.html#toc5">参考资料</a> <br>
					</span>
				</li>
				<li>
					(x) <a href="">=></a> x*x
					<span>
						箭头函数 <br>
						1.不可以当做构造函数，即不能使用new操作符 <br>
						2.不可以使用arguments、super、new.target，均指向外层函数的对应变量 <br>
						3.不可以使用yield命令，因此箭头函数不能用作 Generator 函数 <br>
						4.没有自己的this，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象，且固定不可变，即使使用call也无法修改，更多的可在构造函数或闭包内使用，则可替代普通函数需要用that指代this。 <br>
						this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。所以call的绑定也是无效，但上层的普通函数的call绑定有效。 <br>
						5.没有prototype属性，也不能使用yield关键字
						<hr>
						例：<br>
						1.当只有一行直接返回变量的处理时，x=>x*x，返回x的平方 <br>
						2.当只有一行且无需返回值时，x=>void dosomething <br>
						3.当有多个参数或多条语句时，需添加括号和花括号，(x,y)=>{dosomething / return xx}
					</span>
				</li>
				<li>
					var handle = <a href="">new Function</a><em>('arg..','fnbody')</em>
					<span>
						Function构造函数构建<br>
						1.此形式构建的是匿名函数 <br>
						2.参数为字符串<br>
						3.只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。
					</span>
				</li>
				<li>
					<a href="">IIFE</a>
					<span>
						( function(){}() ); <br>
						( function(){} )(); <br>
						[ function(){}() ]; <br>
						<br>
						~ function() {}(); <br>
						! function() {}(); <br>
						+ function() {}(); <br>
						- function() {}(); <br>
						<br>
						delete function() {}(); <br>
						typeof function() {}(); <br>
						void function() {}(); <br>
						new function() {}(); <br>
						new function() {}; <br>
						<br>
						var f = function() {}(); <br>
						<br>
						1, function() {}(); <br>
						1 ^ function() {}(); <br>
						1 > function() {}(); 
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]参数</h4>
			<ul style="display:none;">
				<li>
					<a href="">(arg=x)</a>
					<span>
						一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域 <a href="http://es6.ruanyifeng.com/#docs/function#作用域">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">...args</a>
					<span>
						rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 <br>
						rest 参数之后不能再有其他参数（即只能是最后一个参数）
					</span>
				</li>
				<li>
					<a href="">arguments</a>
					<span>
						函数的实参，一个类数组对象。 <br>
						1.在JavaScript中，函数参数的默认值是undefined <br>
						2.严格模式下为只读对象，不允许修改。 <br>
						3.箭头函数不存在(浏览器)
						<table>
							<tr>
								<th>对象值</th>
								<th>描述</th>
							</tr>
							<tr>
								<td>arguments[0]</td>
								<td>第一个参数名字</td>
							</tr>
							<tr>
								<td>arguments.length</td>
								<td>参数的个数</td>
							</tr>
							<tr>
								<td>arguments.callee</td>
								<td>主体函数本身，拥有这个参数对象的函数 (严格模式禁用)</td>
							</tr>
						</table>
					</span>
				</li>
				<li>
					fn.<a href="">length</a>
					<span>
						返回函数预期传入的参数个数，即函数定义之中的参数个数(定义之时的个数) <br>
						指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]内部</h4>
			<ul style="display:none;">
				<li>
					<a href="">理论</a>
					<span>
						作用域：静态/词法作用域，取决于函数声明时所在的作用域，与其运行时所在的作用域无关。 <hr>
						执行上下文栈：变量对象、作用域链、this <br>
						1.变量对象：函数的所有形参、函数声明、变量声明（如果变量名称与声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性）<a href="https://github.com/mqyqingfeng/Blog/issues/5">参考资料</a><br>
						<b>变量对象为进入执行上下文阶段，在执行阶段，可能被重新赋值。</b><br>
						2.作用域链：[VO=>AO压入栈顶,全局作用域链] <hr>
						闭包：<a href="https://github.com/mqyqingfeng/Blog/issues/9">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">this</a>
					<span>
						<a href="https://github.com/mqyqingfeng/Blog/issues/7">从ES规范解读this</a> <hr> 
						普通函数：严格模式(undefined)、严格模式(全局对象) <br>
						构造函数：对象的实例 <br>
						对象方法：对象本身 <br>
						call/apply/bind：绑定的对象 <br>
						箭头函数：函数所在的块的this
					</span>
				</li>
				<li>
					<a href="">return</a> [val]
					<span>
						如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined. <br>
						<a href="http://es6.ruanyifeng.com/#docs/function#尾调用优化">尾调用优化</a>
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]方法</h4>
			<ul>
				<li>
					fn<a href="">.call</a>(obj,arg)
					<span>
						fn.call(作用域，[传递参数]) <br>	
						apply与call均让函数作用于特定作用域,call必须明确传入每一个参数。<br>
						apply()把参数打包成Array再传入；call()把参数按顺序传入 <br>
						对普通函数调用，我们通常把this绑定为null。 <br>
						在非严格模式下，如果参数为空、null和undefined，则默认传入全局对象。
					</span>
				</li>
				<li>
					fn<a href="">.apply</a>(obj,[argArr])
					<span>
						fn.apply(作用域，[传递参数Arr]) 
					</span>
				</li>
				<li>
					fn<a href="">.bind</a>(obj)
					<span>
						返回由指定的this值和初始化参数改造的原函数拷贝
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">参考资料</a>
				</span></li>
				<li>
					fn.<a href="">toString()</a>
					<span>
						返回一个表示当前函数源代码的字符串，注释也可以返回
					</span>
				</li>
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>内置函数<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]全局函数</h4>
			<ul>
				<li>
                    <a href="">eval</a>(str)
                    <span>
                        将传入的字符串当做 JavaScript 代码进行执行。<br>
						1.eval没有自己的作用域，都在当前作用域内执行。<br>
                        2.JavaScript规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。 <br>
						3.在严格模式下，eval依然可以读写当前作用域的变量。<br>
                        4.eval“间接调用”时作用域总是全局作用域
                        <a href="http://javascript.ruanyifeng.com/grammar/function.html#toc24">参考资料</a>
                    </span>
                </li>
			</ul>
            <h4>[<span>+</span>] Generator</h4>
            <ul style="display: none;">
            	<li>
            		<a href="">function*</a> name(arg)
            		<span>
            			定义一个generator函数.调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象.
            		</span>
            	</li>
            	<li>
            		<a href="">yield</a> value
            		<span>
            			暂停性地return
            		</span>
            	</li>
            	<li>
            		gnt.<a href="">next()</a>
            		<span>
            			必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行
            		</span>
            	</li>
            </ul>
            <h4>[<span>+</span>] Async</h4>
            <ul style="display: none;">
            	<li>
            		<a href="">async function</a> name(arg)
            		<span>
            			async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。
            		</span>
            	</li>
            	<li>
            		<a href="">await</a> promise
            		<span>
            			await表示紧跟在后面的表达式需要等待结果
            		</span>
            	</li>
            	<li>
            		asc.<a href="">then</a>(fn)
            		<span>
            			async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。
            		</span>
            	</li>
            </ul>
			<h4>[<span>+</span>]Promise</h4>
			<ul style="display:none;">
				<li>
					<a href="">new Promise</a><em>(fn(resolve,reject))</em>
					<span>
						<a href="http://es6.ruanyifeng.com/#docs/promise">参考资料</a> <br>
						Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 <br>
						resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 <br>
						Promise 新建后就会立即执行。
<pre><code data-language="javascript">
	const promise = new Promise(function(resolve, reject) {
	  // ... some code

	  if (/* 异步操作成功 */){
	    resolve(value);
	  } else {
	    reject(error);
	  }
	});
</code></pre>	
					</span>
				</li>
				<li>
					promise.<a href="">then</a><em>(fn(value),[fn(error)])</em>
					<span>
						Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。
<pre><code data-language="javascript">
	promise.then(function(value) {
	  // success
	}, function(error) {
	  // failure
	});
</code></pre>
					</span>
				</li>
				<li>
					promise.<a href="">then(fn).then(fn)</a>
					<span>
						采用链式的then，可以指定一组按照次序调用的回调函数。
					</span>
				</li>
				<li>
					promise.<a href="">catch</a><em>(fn(error))</em>
					<span>
						Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。
					</span>
				</li>
			</ul>
		</div>
	</div>
</div>