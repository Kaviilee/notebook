<!-- 对象 -->
<div class="u-col">
	<div class="u-block">
		<h3>对象<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]Object</h4>
			<ul>
				<li><a href="">new Object()</a><span>
					<table>
						<tr>
							<th>创建方法</th>
							<th>演示</th>
						</tr>
						<tr>
							<td>字面量</td>
							<td>
								对象的所有键名都是字符串，可以不加引号。但如果不符合表示名的条件，则需要加引号。<a href="http://javascript.ruanyifeng.com/grammar/object.html">参考资料</a> <br>
								对象的属性之间用逗号分隔，最后一个属性后面可以加逗号，也可以不加。
<pre><code data-language="javascript">
	var obj ={
		key:value,
		key:function(){...}
	}
</code></pre>	
							</td>
						</tr>
						<tr>
							<td>new运算符</td>
							<td>
<pre><code data-language="javascript">
	var obj = new Object();
	obj.key = value;
	obj.key = function(){...}
</code></pre>
							</td>
						</tr>
						<tr>
							<td>原型创建</td>
							<td>
<pre><code data-language="javascript">
	var obj = Object.creat(Object.prototype)
</code></pre>
							</td>
						</tr>
						<tr>
							<td>构造函数</td>
							<td>
<pre><code data-language="javascript">
	function Obj(name){
		this.name = value;
		this.key = function (){...}
	}
	var o = new Obj(name)
</code></pre>
								注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。<br>
								如果忘记写new运算符，在strict模式下，this.name = name将报错，因为this绑定为undefined，在非strict模式下，this.name = name不报错，因为this绑定为window，于是无意间创建了全局变量name，并且返回undefined，这个结果更糟糕。
							</td>
						</tr>
					</table>
				</span></li>
				<li>obj<a href=""></a>[key]<span>
					<ol>
						<li>访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。</li>
						<li><b>当属性含空格、关键字或为变量时，只能用中括号表示</b></li>
						<li>中括号表示法时，key需要加上引号</li>
						<li>不能对一个未声明的对象直接指定属性</li>
					</ol>
				</span></li>
				<li>obj.<a href="">hasOwnProperty()</a><span>
					检测xiaoming是否拥有某一属性，可以用in操作符。<br>
					如果in判断一个属性存在，这个属性不一定是自身原有的，它可能是继承得到的。<br>
					要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法。
				</span></li>
				<li>
					<a href="">delete </a>obj.key
					<span>
						删除属性delete obj.key，删除成功后返回true <br>
						注意，删除一个不存在的属性，delete不报错，而且返回true。 <br>
						只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。<br>
						delete命令只能删除对象本身的属性，无法删除继承的属性 <br>
						delete命令不能删除var命令声明的变量，只能用来删除属性。
					</span>
				</li>
				<li>key <a href="">in</a> obj<span>
					in遍历访问对象的属性/属性值
<pre><code data-language="javascript">
	for (var property in obj) {
		console.log(property);  //遍历对象的全部属性
		console.log(obj[property]); //遍历所有对象的值
	} 
	
	var props = [];
	var i = 0;
	for (props[i++] in obj);
</code></pre>
					它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性 <br>
					它不仅遍历对象自身的属性，还遍历继承的属性。
				</span></li>
			</ul>
			<h4>[<span>-</span>]属性</h4>
			<ul>
				<li>
					obj.<a href="">constructor</a>
					<span>
						返回值：Object
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]取值方法</h4>
			<ul style="display:none;">
				<li>
					<a href="">Object.getOwnPropertyNames</a><em>(obj)</em>
					<span>
						返回直接定义在某个对象上面的全部属性的名称。 <br>
						返回一个数组，成员是对象本身的所有属性的键名，不包含继承的属性键名。
					</span>
				</li>
				<li>
					<a href="">Object.keys</a>(obj)
					<span>
						查看一个对象的所有属性，返回一个key的数组，返回可枚举的属性 <br>
						Object.getOwnPropertyNames(obj)方法还返回不可枚举的属性名 <br>
						由于JavaScript没有提供计算对象属性个数的方法，所以可以用这两个方法代替 <br>
						Object.keys(o).length <br>
						Object.getOwnPropertyNames(o).length
					</span>
				</li>
				<li>
					<a href="">Object.values</a>(obj)
					<span>
						返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。
					</span>
				</li>
				<li>
					<a href="">Object.entries</a>(obj)
					<span>
						返回一个给定对象自身可枚举属性的键值对的二维数组 <br>
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">Object.getOwnPropertySymbols</a>(obj)
					<span>
						返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]属性描述</h4>
			<ul style="display:none;">
				<li>
					Desciptor<a href=""></a>
					<span>
						属性描述对象。 <br>
						数据对象与DOM对象的双向绑定：<a href="http://javascript.ruanyifeng.com/stdlib/attributes.html">参考资料</a>
					</span>
				</li>
				<li>
					desciptor.<a href="">value</a>
					<span>
						存放该属性的属性值，默认为undefined
					</span>
				</li>
				<li>
					desciptor.<a href="">writable</a>
					<span>
						存放一个布尔值，表示属性值是否可改变	
					</span>
				</li>
				<li>
					desciptor.<a href="">enumerable</a>
					<span>
						存放一个布尔值，表示该属性是否可枚举
					</span>
				</li>
				<li>
					desciptor.<a href="">configurable</a>
					<span>
						存放一个布尔值，表示“可配置性”。如果设为false，将阻止某些操作改写该属性，比如，无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。
					</span>
				</li>
				<li>
					desciptor.<a href="">get</a>
					<span>
						存放一个函数，表示该属性的取值函数（getter），默认为undefined
					</span>
				</li>
				<li>
					desciptor.<a href="">set</a>
					<span>
						存放一个函数，表示该属性的存值函数（setter），默认为undefined
					</span>
				</li>
				<li>
					<a href="">Object.getOwnPropertyDescriptor</a>(o,prop)
					<span>
						返回指定对象上一个自有属性对应的属性描述符。
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">Ojbect.defineProperty</a><em>(o,prop,desciptor)</em>
					<span>
						在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 <br>
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">参考资料</a>
					</span>
				</li>
				<li>
					obj.<a href="">propertyIsEnumerable</a>(key)
					<span>
						判断某个属性是否可枚举
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]状态控制</h4>
			<ul style="display:none;">
				<li>
					<a href="">Object.preventExtensions</a>(obj)
					<span>
						防止对象扩展
					</span>
				</li>
				<li>
					<a href="">Object.isExtensible</a>(obj)
					<span>
						判断对象是否可扩展
					</span>
				</li>
				<li>
					<a href="">Object.seal</a>(obj)
					<span>
						禁止对象配置
					</span>
				</li>
				<li>
					<a href="">Object.isSealed</a>(obj)
					<span>
						判断一个对象是否可配置
					</span>
				</li>
				<li>
					<a href="">Object.freeze</a>(obj)
					<span>
						冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。
					</span>
				</li>
				<li>
					<a href="">Object.isFrozen</a>(obj)
					<span>
						判断一个对象是否被冻结
					</span>
				</li>
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>ES5面向对象<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]原型链</h4>
			<ul>
				<li>
					<em>object</em><a href=""></a>
					<span>
						如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 <br>
						但如果取消某一个变量对于原对象的引用，不会影响到另一个变量。 <br>
						这种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝。 <br>
						故在设置一个新的对象继承旧对象时，不能直接通过new.prototype = old.prototype进行设置，否则对new原型的任何修改，将直接会影响旧的原型对象。
						<hr>
						如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。 <hr>
						如果读取一个不存在的键，会返回undefined，而不是报错。
					</span>
				</li>
                <li>cst.<a href="">prototype</a> / super<span>
                	构造函数创建的实例的原型，prototype是函数才会有的属性 <br>
                    为减少内存消耗，将公共方法写在构造函数的原型上，<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997235247b53be560ab041a7b10360a567422a78000">参考资料</a> <hr>
                    在改变原型对象时，一般要同时设置constructor属性 <hr>
                    this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。
                </span></li>
                <li>proto.<a href="">constructor</a><span>
                    原型对象的这个属性指向构造函数 <br>
                    <img src="image/js/prototype.png" alt=""> <br>
                    实例对象本身并没有constructor属性，但会直接从实例的原型对象查找，所以会得出结果。 <br>
                    prototype.constructor.name 获取构造函数的名称
                </span></li>
                <li>obj.<a href="">__proto__</a><span>
                	等价于 obj.constructor.prototype <br>
                	仅浏览器环境。 <br>
					任何一个对象都有__proto__，实例对象的这个属性指向该对象的原型 <br>
					在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型，并且，低版本的IE也无法使用__proto__。 
				</span></li>
			</ul>
			<h4>[<span>+</span>]原型方法</h4>
			<ul style="display:none;">
				<li>
					proto.<a href="">isPrototypeOf</a>(obj)
					<span>
						判断当前对象是否为另一个对象的原型 <br>
						Object.prototype处于原型链的最顶端，所以对各种实例都返回true，只有继承null的对象除外。
					</span>
				</li>
				<li>
					<a href="">Object.getPrototypeOf</a>(obj)
					<span>
						等价cst.prototype。获取对象的原型对象
					</span>
				</li>
				<li>
					<a href="">Object.setPrototypeOf</a>(obj,proto)
					<span>
						为现有对象设置原型，返回新对象。
					</span>
				</li>
			</ul>
            <h4>[<span>-</span>]继承</h4>
            <ul>
				<li><a href="">Object.create</a>(proto)<span>
					基于一个原型创建新对象，用于当对象不是一个构造函数时。 <br>
					如果想要生成一个不继承任何属性，参数传入null。 <br>
					<a href="http://javascript.ruanyifeng.com/oop/prototype.html#toc8">参考资料</a>
<pre><code data-language="javascript">
	// 原型对象:
	var Student = {
	    name: 'Robot',
	    height: 1.2,
	    run: function () {
	        console.log(this.name + ' is running...');
	    }
	};

	function createStudent(name) {
	    // 基于Student原型创建一个新对象:
	    var s = Object.create(Student);
	    // 初始化新对象:
	    s.name = name;
	    return s;
	}

	var xiaoming = createStudent('小明');
	xiaoming.run(); // 小明 is running...
	xiaoming.__proto__ === Student; // true
</code></pre>
				</span></li>
                <li><em>inherits</em><a href=""></a><em>(child,parent)</em><span>
<pre><code data-language="javascript">
	function inherits(Child, Parent) {
	    var F = function () {};
	    F.prototype = Parent.prototype;
	    Child.prototype = new F();
	    Child.prototype.constructor = Child;
	}
</code></pre>
					<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997013405abfb7f0e1904a04ba6898a384b1e925000">参考资料</a>
                </span></li>
                <li>
					<a href="">Object.assign</a>(to,from...)
					<span>
						将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。跳过那些值为 null 或 undefined 的源对象。
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">参考资料</a>
						<hr>
<pre><code data-language="javascript">
	var extend = function (to, from) {
	  for (var property in from) {
	    var descriptor = Object.getOwnPropertyDescriptor(from, property);

	    if (descriptor && ( !descriptor.writable
	      || !descriptor.configurable
	      || !descriptor.enumerable
	      || descriptor.get
	      || descriptor.set)) {
	      Object.defineProperty(to, property, descriptor);
	    } else {
	      to[property] = from[property];
	    }
	  }
	}
</code></pre>
					</span>
				</li>
            </ul>
            <h4>[<span>+</span>]其它</h4>
			<ul style="display:none;">
				<li>
					obj.<a href="">valueOf</a>()
					<span>
						可通过自定义valueOf的返回值来替换原型的返回值，以达到自动转换计算时预期的结果。
					</span>
				</li>
				<li>
					obj.<a href="">toString</a>()
					<span>
						可通过自定义toString方法替换原型的返回值。  <br>
						Object.prototype.toString.call(value) 可判断其构造函数：
						<table>
							<tr>
								<th>value</th>
								<th>返回值</th>
							</tr>
							<tr>
								<td>数值</td>
								<td>[object Number]</td>
							</tr>
							<tr>
								<td>字符串</td>
								<td>[object String]</td>
							</tr>
							<tr>
								<td>布尔值</td>
								<td>[object Boolean]</td>
							</tr>
							<tr>
								<td>undefined</td>
								<td>[object Undefined]</td>
							</tr>
							<tr>
								<td>null</td>
								<td>[object Null]</td>
							</tr>
							<tr>
								<td>数组</td>
								<td>[object Array]</td>
							</tr>
							<tr>
								<td>arguments对象</td>
								<td>[object Arguments]</td>
							</tr>
							<tr>
								<td>函数</td>
								<td>[object Function]</td>
							</tr>
							<tr>
								<td>Error对象</td>
								<td>[object Error]</td>
							</tr>
							<tr>
								<td>Date对象</td>
								<td>[object Date]</td>
							</tr>
							<tr>
								<td>RegExp对象</td>
								<td>[object RegExp]</td>
							</tr>
							<tr>
								<td>其他对象</td>
								<td>[object Object]</td>
							</tr>
						</table>
					</span>
				</li>
			</ul>
        </div>
    </div>
    <div class="u-block">
		<h3>ES6面向对象<span>-</span></h3>
		<div class="u-list">
        	<h4>[<span>-</span>]类</h4>
        	<ul>
            	<li><a href="">class </a>Name<span>
<pre><code data-language="javascript">
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
var test = new Point(1,2)
</code></pre>
					1.constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 <br>
					2.类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 <br>
					3.类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。 <br>
					4.var MyClass = class Me{...} 表达式的方式 <a href="http://es6.ruanyifeng.com/#docs/class#Class-表达式">参考资料</a> <br>
					5.类不存在变量提升 <br>
					6.
                </span></li>
                <li>
                	<a href="">static</a> fn
                	<span>
                		类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 <br>
                		注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。 <hr>
                		ES6 明确规定，Class 内部只有静态方法，没有静态属性。 <br>
                		目前需要通过在类外面使用Class.prop来定义
                	</span>
                </li>
                <!-- <li>
                	<a href="">Object.assign</a>(class,fn,fn..)
                	<span>
                		Object.assign方法可以很方便地一次向类添加多个方法。
                	</span>
                </li> -->
        	</ul>
        	<h4>[<span>-</span>]继承</h4>
        	<ul>
        		<li><a href="">class $child extends $parent</a><span>
<pre><code data-language="javascript">
class PrimaryStudent extends Student {
    constructor(name, grade) {
        super(name); // 记得用super调用父类的构造方法!
        this.grade = grade;
    }

    myGrade() {
        alert('I am at grade ' + this.grade);
    }
}
</code></pre>
					PrimaryStudent需要name和grade两个参数，并且需要通过super(name)来调用父类的构造函数，否则父类的name属性无法正常初始化。
                </span></li>
                <li><a href="">super</a>(parent_key)<span>
                	super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。<br>
                	1.super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。 <br>
                	2.super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。
                </span></li>
        	</ul>
		</div>
	</div>
</div>