<!-- 函数 -->
<div class="u-col">
	<div class="u-block">
		<h3>函数<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]构建</h4>
			<ul>
				<li>
					x <a href="">=></a> x*x
					<span>
						1.当只有一行直接返回变量的处理时，x=>x*x，返回x的平方 <br>
						2.当只有一行且无需返回值时，x=>void dosomething <br>
						3.当有多个参数或多条语句时，需添加括号和花括号，(x,y)=>{dosomething / return xx} <hr>

						1.不可以当做构造函数 <br>
						2.不可以使用arguments、super、new.target，均指向外层函数的对应变量 <br>
						3.不可以使用yield命令，因此箭头函数不能用作 Generator 函数 <br>
						4.函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象，且固定不可辨，即使使用call也无法修改，更多的可在构造函数或闭包内使用，则可替代普通函数需要用that指代this。 <hr>

						this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。所以call的绑定也是无效，但上层的普通函数的call绑定有效。

					</span>
				</li>
				<li>
					IIFE<a href=""></a>
					<span>
						匿名函数写法：
						匿名函数自执行
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]Function</h4>
			<ul>
				<li>
					<a href="">function</a> <em>name(arg)</em>
					<span>
						<b>参数</b> <br>
						函数不能省略靠前的参数，如果一定要省略靠前的参数，只有显式传入undefined。 <br>
						函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。即在函数内部，传入的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。这意味着，在函数体内修改参数值，不会影响到函数外部。 <br>
						函数参数如果是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。 <br>
						注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。<a href="http://javascript.ruanyifeng.com/grammar/function.html">参考资料</a> <br>
						如果有同名的参数，则取最后出现的那个值。
						<hr>
						<b>作用域</b> <br>
						函数作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。<br>
						函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。  <br>
						同样的，函数体内部声明的函数，作用域绑定函数体内部。<br>
                        <a href="https://github.com/mqyqingfeng/Blog/issues/3">参考资料</a> <br>
                        ES6中块级作用域中声明的函数，在块级作用域之外不可引用
						<hr>
						<b>属性</b> <br>
						fn.name : 返回紧跟在function关键字之后的那个函数名(匿名函数为空字符串) <br>
						fn.length : 返回函数预期传入的参数个数，即函数定义之中的参数个数(定义之时的个数)。 <br>
						fn.toString() : 返回函数的源码，注释也可以返回。
						<hr>
						<b>闭包</b> <br>
						定义在一个函数内部的函数。闭包最大的特点，就是它可以“记住”诞生的环境。 <br>
						闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。 <br>
						返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 <br>
						如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变 <hr>
						避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 <br>
						对于函数，只有函数声明会被提升到顶部，而不包括函数表达式。
					</span>
				</li>
				<li>
					<a href="">new</a> fn
					<span>
						<a href="http://javascript.ruanyifeng.com/oop/basic.html">new命令原理</a> <br>
						new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。 <br>
						函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined <hr>
						<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997235247b53be560ab041a7b10360a567422a78000">示例代码</a> <br>
						方法应挂载在prototype上，避免内存占用
					</span>
				</li>
				<li><a href="">function</a>(arg)<span>
					<b>1.function命令 - 函数的声明</b><br>
					function fn(arg){...} <br>
					<hr>
					<b>2.函数表达式</b> <br>
					var fn = function(arg){...} <br>
					在第二种方式下，function (x) { ... }是一个匿名函数，它没有函数名。<br>
					但是，这个匿名函数赋值给了变量fn，所以，通过变量fn就可以调用该函数。<br>
					上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。 <br>
					采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。 <br>
					<hr>
					<b>3.Function构造函数</b> <br>
					var fn = new Function(arg..,函数体) <br>
					你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。
					<hr>
					如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。 <br>
					如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。 <a href="http://javascript.ruanyifeng.com/grammar/function.html">参考资料</a> <br>
					根据ECMAScript的规范，不得在非函数的代码块中声明函数。
				</span></li>
				<li><a href="">(function(n){})(n)</a><span>
					IIFE = Immediately-Invoked Function Expression,立即调用的函数表达式 <br>
					匿名函数自执行,可以初始化各项值,但如果需要的变量并不是一开始初始化有的,则不可以,否则无法读取。<br>
				</span></li>
			</ul>
			<h4>[<span>-</span>]内部</h4>
			<ul>
				<li><a href="">arguments</a><span>
					函数的参数对象，类数组对象，但不是数组，实际上arguments最常用于判断传入参数的个数。 <br>
					严格模式下为只读对象，不允许修改。
						<tr>
							<th>对象值</th>
							<th>描述</th>
						</tr>
						<tr>
							<td>arguments[0]</td>
							<td>第一个参数名字</td>
						</tr>
						<tr>
							<td>arguments.length</td>
							<td>参数的个数</td>
						</tr>
						<tr>
							<td>arguments.callee</td>
							<td>主体函数本身，拥有这个参数对象的函数 (严格模式禁用)</td>
						</tr>
					</table>
					rest参数：<br>
					<pre><code data-language="javascript">
						function foo(a, b, ...rest) {
						    console.log('a = ' + a);
						    console.log('b = ' + b);
						    console.log(rest);
						    //rest: [array]
						}
					</code></pre>
				</span></li>
				<li>
					<a href="">...rest</a>
					<span>
						rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 <br>
						rest 参数之后不能再有其他参数（即只能是最后一个参数）
					</span>
				</li>
				<li><a href="">return</a> value<span>
					如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined.
				</span></li>
				<li><a href="">this</a><span>
					<table>
						<tr>
							<th>当前环境</th>
							<th>this指向</th>
						</tr>
						<tr>
							<td>函数</td>
							<td>非严格模式：window <br>
							strict模式：undefined
							</td>
						</tr>
						<tr>
							<td>对象</td>
							<td>object<br>
							直接定义对象的函数，并单独存储函数后，调用函数时不可行，除非以obj.fn()进行调用。<br>
							对象属性函数里的函数（闭包）调用对象时可指定var that = this来获取正确this
							</td>
						</tr>
					</table>
					<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345005399057070809cfaa347dfb7207900cfd116fb000" target="_blank">参考资料1</a> | <a href="http://javascript.ruanyifeng.com/oop/this.html">参考资料2</a>
				</span></li>
			</ul>
			<h4>[<span>-</span>]方法</h4>
			<ul>
				<li>fn<a href="">.apply</a>(obj,[arg])<span>
					fn.apply(作用域，[传递参数]/arguments) <br>
					要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。
				</span></li>
				<li>fn<a href="">.call</a>(obj,arg)<span>
					fn.call(作用域，[传递参数]),apply与call均让函数作用于特定作用域,call必须明确传入每一个参数。<br>
					apply()把参数打包成Array再传入；call()把参数按顺序传入 <br>
					对普通函数调用，我们通常把this绑定为null。 <br>
					如果参数为空、null和undefined，则默认传入全局对象。
					</span></li>
				<li>fn<a href="">.bind</a>(obj)<span>
					bind(作用目标) 创建一个作用于某目标的函数实例 <br>
					bind()方法会创建一个新函数。当这个新函数被调用时，bind()的第一个参数将作为它运行时的 this, 之后的一序列参数将会在传递的实参前传入作为它的参数。
				</span></li>
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>内置函数<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>] 定时器</h4>
            <ul>
            	<li>
            		<a href="">setTimeout</a>(fn,time,[arg])
            		<span>
            			在指定的毫秒数后调用函数或计算表达式 <br>
            			setTimeout还允许添加更多的参数，它们将被传入推迟执行的函数（回调函数），IE 9.0及以下版本，只允许setTimeout有两个参数，不支持更多的参数。 <br>
            			<a href="http://javascript.ruanyifeng.com/advanced/timer.html#toc4">当time=0时的应用，同样需等待队列完成</a>
            		</span>
            	</li>
            	<li>
            		<a href="">setInterval</a>(fn,time)
            		<span>
            			按照指定的周期（以毫秒计）来调用函数或计算表达式
            		</span>
            	</li>
            	<li>
            		<a href="">clearTimeout</a>(timeout)
            		<span>
            			取消由 setTimeout() 方法设置的 timeout
            		</span>
            	</li>
            	<li>
            		<a href="">clearInterval</a>(timeout)
            		<span>
            			取消由 setInterval() 设置的 timeout
            		</span>
            	</li>
				<li>val.<a href="">toString</a>()<span>
					<table>
                        <tr>
                            <th>目标</th>
                            <th>返回值</th>
                        </tr>
                        <tr>
                            <td>array</td>
                            <td>参数直接用,隔开的字符串</td>
                        </tr>
                    </table>
				</span></li>
				<li>
					<a href="">vauleOf</a>
					<span>
						
					</span>
				</li>
            </ul>
            <h4>[<span>+</span>] Generator</h4>
            <ul style="display: none;">
            	<li>
            		<a href="">function*</a> name(arg)
            		<span>
            			定义一个generator函数.调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象.
            		</span>
            	</li>
            	<li>
            		<a href="">yield</a> value
            		<span>
            			暂停性地return
            		</span>
            	</li>
            	<li>
            		gnt.<a href="">next()</a>
            		<span>
            			必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行
            		</span>
            	</li>
            </ul>
            <h4>[<span>+</span>] Async</h4>
            <ul style="display: none;">
            	<li>
            		<a href="">async function</a> name(arg)
            		<span>
            			async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。
            		</span>
            	</li>
            	<li>
            		<a href="">await</a> promise
            		<span>
            			await表示紧跟在后面的表达式需要等待结果
            		</span>
            	</li>
            	<li>
            		asc.<a href="">then</a>(fn)
            		<span>
            			async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。
            		</span>
            	</li>
            </ul>
		</div>
	</div>
	<div class="u-block">
		<h3>模块<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>] Module</h4>
			<ul>
				<li>
            		<a href="">export</a><em>{v1,v2..}</em>
            		<span>
            			export {var..} <br>
            			export fn
            		</span>
            	</li>
            	<li>
            		<a href="">import</a><em>{v1,v2...} from 'path/file'</em>
            		<span>
            			import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js后缀可以省略。
            		</span>
            	</li>
            	<li>
            		<a href="">export</a><em>{$inner as $outer}</em>
            		<span>
            			export输出的变量就是本来的名字，但是可以使用as关键字重命名。
            		</span>
            	</li>
            	<li>
            		<a href="">import</a><em>{$old as $new} from 'path/file'</em>
            		<span>
            			如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。
            		</span>
            	</li>
            	<li>
            		<a href="">import * as $obj</a><em> from 'path/file'</em>
            		<span>
            			除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。
            		</span>
            	</li>
            	<li>
            		<a href="">export</a><em>{v1,v2...} from 'path/file'</em>
            		<span>
            			如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。
            		</span>
            	</li>
			</ul>
			<h4>[<span>-</span>] Default</h4>
			<ul>
				<li>
            		<a href="">export default $name</a>
            		<span>
            			此时import命令，可以用任意名称指向输出的方法，这时就不需要知道原模块输出的函数名。
            			
            		</span>
            	</li>
            	<li>
            		<a href="">import $custom form 'path/file'</a>
            		<span>
            			需要注意的是，这时import命令后面，不使用大括号。 
            		</span>
            	</li>
			</ul>
            <ul>
            	
            	
            </ul>
		</div>
	</div>
</div>