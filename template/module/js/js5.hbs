<!-- 对象 -->
<div class="u-col">
	<div class="u-block">
		<h3>对象<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>+</span>]构建</h4>
			<ul style="display:none;">
				<li>
					<a href="">{key:val,[$key]:val...}</a>
					<span>
						字面量创建方法 <br>
						对象有时也被叫作关联数组。对象的属性之间用逗号分隔，最后一个属性后面可以加逗号，也可以不加。 <br>
						对象的所有键名都是字符串，可以不加引号。但如果不符合表示名的条件，则需要加引号。<a href="http://javascript.ruanyifeng.com/grammar/object.html">参考资料</a> <hr>
						如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 <br>
						但如果取消某一个变量对于原对象的引用，不会影响到另一个变量。 <br>
						这种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝。 <br>
						故在设置一个新的对象继承旧对象时，不能直接通过new.prototype = old.prototype进行设置，否则对new原型的任何修改，将直接会影响旧的原型对象。
						<hr>
						如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。 <hr>
						如果读取一个不存在的键，会返回undefined，而不是报错。 <br>
						但不能对一个未声明的对象直接指定属性，这样会报错 
					</span>
				</li>
				<li>
					<a href="">new </a>Fn()
					<span>
						用构造函数创建 <br>
						<pre><code data-language="javascript">
							function Obj(opts){
								this.key = value
							}
							var o = new Obj(opts)
						</code></pre>
						new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。 <br>
						new 构造函数时，this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this<br>
						函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined
					</span>
				</li>
				<li>
					<a href="">new Object()</a>
					<span>
						var obj = new Object(); <br>
						var obj = Object.creat(Object.prototype) <hr>
						obj.key = value; <br>
						从Object原型创建
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]属性表示</h4>
			<ul style="display:none;">
				<li>
					obj.<a href="">key</a>
					<span>
						一个对象的属性可以被解释成一个附加到对象上的变量，使用.表示法时必须是一个合法的标识符 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors">参考资料</a>
					</span>
				</li>
				<li>
					obj<a href="">['key']</a>
					<span>
						对象的属性也可以通过方括号访问或者设置，对象有时也被叫作关联数组, 因为每个属性都有一个用于访问它的字符串值。<br> 
						一个对象的属性名可以是任何有效的 JavaScript 字符串，或者可以被转换为字符串的任何类型，包括空字符串。<br>
						当属性含空格、关键字时，只能用中括号表示
					</span>
				</li>
				<li>
					obj<a href="">[$key]</a>
					<span>
						当属性为变量时，只能用中括号表示
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]属性设置</h4>
			<ul>
				<li>
					{<a href="">key:val</a>}
					<span>
						定义一个属性，值可以为任意类型 <br>
						对于一个已经存在的对象，可用obj.key = val 来进行设置
					</span>
				</li>
				<li>
					{<a href="">get|set key([x]){}</a>}
					<span>
						使用对象初始化器定义getter/setter方法 <br>
						getter方法必须是无参数的，setter方法只接受一个参数 <br>
						对于已经存在的对象，则需使用Object.defineProperties
					</span>
				</li>
				<li>
					<a href="">Object.defineProperty</a><em>(obj,key,desc)</em>
					<span>
						在一个对象上定义一个新属性或者修改现有属性， 并返回这个对象。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">Object.defineProperties</a><em>(obj,{key:{desc}})</em>
					<span>
						在一个对象上定义新的属性或修改现有属性， 并返回这个对象。
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">delete </a>obj.key
					<span>
						delete 操作符删除一个不是继承而来的属性 <br>
						删除成功后返回true，注意，删除一个不存在的属性，delete不报错，而且返回true。 <br>
						只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]属性描述对象</h4>
			<ul style="display:none;">
				<li>
					<a href="">Object.getOwnPropertyDescriptor</a><em>(obj,key)</em>
					<span>
						返回指定对象上一个自有属性对应的属性描述符。
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">参考资料</a> <br>
						注意，Object.getOwnPropertyDescriptor方法只能用于对象自身的属性，不能用于继承的属性
					</span>
				</li>
				<li>
					<a href="">Object.getOwnPropertyDescriptors</a><em>(obj)</em>
					<span>
						获取一个对象的所有自身属性的描述符 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">configurable</a>
					<span>
						false|true <br>
						表示该属性的描述对象是否可以修改(属性是否可被删除)。<br>
						数据描述符和存取描述符均具有此键值
					</span>
				</li>
				<li>
					<a href="">enumerable</a>
					<span>
						false|true  <br>
						表示该属性是否可枚举 <br>
						数据描述符和存取描述符均具有此键值
					</span>
				</li>
				<li>
					<a href="">value</a>
					<span>
						undefined|val <br>
						该属性对应的值<br>
						数据描述符具有此键值
					</span>
				</li>
				<li>
					<a href="">writable</a>
					<span>
						false|true	<br>
						表示属性值是否可改变 <br>
						数据描述符具有此键值
					</span>
				</li>
				<li>
					<a href="">get</a>
					<span>
						undefined|fn <br>
						存放一个函数，表示该属性的取值函数（getter）<br>
						存取描述符具有此键值
					</span>
				</li>
				<li>
					<a href="">set</a>
					<span>
						undefined|fn <br>
						存放一个函数，表示该属性的存值函数（setter）<br>
						存取描述符具有此键值
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]属性判断</h4>
			<ul>
				<li>
					obj.<a href="">hasOwnProperty</a>(key)
					<span>
						检测对象是否拥有某一属性（非原型继承） <br>
						返回值：布尔
					</span>
				</li>
				<li>
					obj.<a href="">propertyIsEnumerable</a>(key)
					<span>
						判断某个属性是否可枚举
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]属性枚举</h4>
			<ul>
				<li>
					<a href="">for $key in</a> obj
					<span>
						依次访问一个 [对象及其原型链] 中所有 [可枚举的属性]
					</span>
				</li>
				<li>
					<a href="">Object.keys</a>(obj)
					<span>
						返回 [对象] 自身（不包括原型中）的所有 [可枚举的属性] 的数组
					</span>
				</li>
				<li>
					<a href="">Object.getOwnPropertyNames</a><em>(obj)</em>
					<span>
						返回 [对象] 自身（不包括继承的）的所有 [属性] 的数组
					</span>
				</li>
				<li>
					<a href="">Object.getOwnPropertySymbols</a>(obj)
					<span>
						返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
					</span>
				</li>
				<li>
					<a href="">Reflect.ownKeys</a>(obj)
					<span>
						返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 <hr>
						<a href="http://es6.ruanyifeng.com/#docs/object#属性的遍历">参考资料</a> <br>
						首先遍历所有数值键，按照数值升序排列。<br>
						其次遍历所有字符串键，按照加入时间升序排列。<br>
						最后遍历所有 Symbol 键，按照加入时间升序排列。<br>
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]状态控制</h4>
			<ul>
				<li>
					<a href="">Object.preventExtensions</a>(obj)
					<span>
						防止对象扩展
					</span>
				</li>
				<li>
					<a href="">Object.isExtensible</a>(obj)
					<span>
						判断对象是否可扩展
					</span>
				</li>
				<li>
					<a href="">Object.seal</a>(obj)
					<span>
						禁止对象配置，既无法添加新属性，也无法删除旧属性，但并不影响修改某个属性的值
					</span>
				</li>
				<li>
					<a href="">Object.isSealed</a>(obj)
					<span>
						判断一个对象是否可配置
					</span>
				</li>
				<li>
					<a href="">Object.freeze</a>(obj)
					<span>
						冻结一个对象，无法添加新属性、无法删除旧属性、也无法改变属性的值 <br>	
						冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。
					</span>
				</li>
				<li>
					<a href="">Object.isFrozen</a>(obj)
					<span>
						判断一个对象是否被冻结
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]其它</h4>
			<ul style="display:none;">
				<li>
					<a href="">Object.assign</a>(to,from...)
					<span>
						将所有可枚举属性的值从一个或多个源对象复制到目标对象，将返回目标对象。<br>
						1.浅拷贝，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用 <br>
						2.只会拷贝源对象自身的并且可枚举的属性到目标对象 <br> 
						Object.assign 不会跳过那些值为 null 或 undefined 的源对象 <br>
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">参考资料</a>
						<hr>
					</span>
				</li>
				<li>
					<a href="">Object.is</a>(x,y)
					<span>
						判断两个值是否全等（必须引用地址也一致）
					</span>
				</li>
				<li>
					obj.<a href="">toString</a>()
					<span>
						可通过自定义toString方法替换原型的返回值。  <br>
						Object.prototype.toString.call(value) 可判断其构造函数：
						<table>
							<tr>
								<th>value</th>
								<th>返回值</th>
							</tr>
							<tr>
								<td>数值</td>
								<td>[object Number]</td>
							</tr>
							<tr>
								<td>字符串</td>
								<td>[object String]</td>
							</tr>
							<tr>
								<td>布尔值</td>
								<td>[object Boolean]</td>
							</tr>
							<tr>
								<td>undefined</td>
								<td>[object Undefined]</td>
							</tr>
							<tr>
								<td>null</td>
								<td>[object Null]</td>
							</tr>
							<tr>
								<td>数组</td>
								<td>[object Array]</td>
							</tr>
							<tr>
								<td>arguments对象</td>
								<td>[object Arguments]</td>
							</tr>
							<tr>
								<td>函数</td>
								<td>[object Function]</td>
							</tr>
							<tr>
								<td>Error对象</td>
								<td>[object Error]</td>
							</tr>
							<tr>
								<td>Date对象</td>
								<td>[object Date]</td>
							</tr>
							<tr>
								<td>RegExp对象</td>
								<td>[object RegExp]</td>
							</tr>
							<tr>
								<td>其他对象</td>
								<td>[object Object]</td>
							</tr>
						</table>
					</span>
				</li>
				<li>
					obj.<a href="">valueOf</a>()
					<span>
						返回指定对象的原始值 <br>
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf">参考资料</a>
					</span>
				</li>
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>面向对象<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]类与继承</h4>
			<ul>
				<li>
					<a href="">class</a> name
					<span>
						1.类的内部所有定义的方法，都是不可枚举的。 <br>
						2.类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。<br>
						3.类不存在变量提升 <br>
						4.类不能继承常规（非可构造）对象，如要继承常规对象，则改用Object.setPrototypeOf()
					</span>
				</li>
				<li>
					<a href="">class $child extends $parent</a>
					<span>
						1.如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。<br>
						2.在子类的构造函数中，只有调用super之后，才可以使用this关键字
                	</span>
				</li>
				<li>
					class.<a href="">constructor</a>([opt]){}
					<span>
						1.constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法<br>	
						2.一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。
					</span>
				</li>
				<li>
					class.<a href="">super</a>(key)|.fn
					<span>
						1.super作为函数调用时，代表父类的构造函数。 <br>
						2.super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。

						<table>
							<tr>
								<td>环境</td>
								<td>this</td>
								<td>super</td>
							</tr>
							<tr>
								<td>构造函数</td>
								<td>实例对象</td>
								<td>父类构造函数</td>
							</tr>
							<tr>
								<td>普通方法</td>
								<td>实例对象</td>
								<td>父类原型对象</td>
							</tr>
							<tr>
								<td>静态方法</td>
								<td>类</td>
								<td>父类</td>
							</tr>
						</table>
					</span>
				</li>
				<li>
					class.<a href="">fn</a>(){}
					<span>
						原型方法
					</span>
				</li>
                <li>
                	class.<a href="">static fn</a>(){}
                	<span>
                		1.静态方法不会被实例继承，而是直接通过类来调用 <br>
						2.静态方法会被子类继承 <br>
                		3.如果静态方法包含this关键字，这个this指的是类，而不是实例。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes">参考资料</a>
                	</span>
                </li>
				<li>
					class.<a href="">get|set prop</a>(){}
					<span>
						getter/setter
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]类修饰器</h4>
			<ul style="display:none;">
				<li>
					<a href="">@decorator</a>(cls)
					<span>
						修饰器是一个对类进行处理的函数
					</span>
				</li>
				<li>
					<a href="">@decorator</a>(cls,prop,desc)
					<span>
						修饰器不仅可以修饰类，还可以修饰类的属性
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]原型链</h4>
			<ul style="display:none;">
				<li>
					cst.<a href="">prototype</a>
					<span>
                		返回值：构造函数创建的实例的原型（prototype是函数才会有的属性） <br>
                    	为减少内存消耗，将公共方法写在构造函数的原型上，<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997235247b53be560ab041a7b10360a567422a78000">参考资料</a> <br>
						在改变原型对象时，一般要同时设置constructor属性 <br>
                	</span>
				</li>
				<li>
					pro.<a href="">constructor</a>
					<span>
                    	原型对象的这个属性指向构造函数 <br>
                    	<img src="image/js/prototype.png" alt="" style="background-color:#fff;"> <br>
                        <a href="https://github.com/mqyqingfeng/Blog/issues/2">参考资料</a>
                	</span>
				</li>
				<li>
					obj.<a href="">__proto__</a>
					<span>
						返回值：Object / 构造函数原型对象（仅浏览器环境） <br>
						在编写JavaScript代码时，不要直接用obj.__proto__去改变一个对象的原型，并且，低版本的IE也无法使用__proto__。 
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]原型方法</h4>
			<ul style="display:none;">
                <li>
					<a href="">Object.create</a>(obj)
					<span>
						基于一个对象创建新对象，源对象会成为新对象的原型对象，原型对象属性并不能在自身默认可见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create">参考资料</a><br>
						不能直接将b的原型赋值给a，否则当b的原型修改时，a的原型也会被更改 <hr>
						Child.prototype = Object.create(Parent.prototype) <br>	Child.prototype.constructor = Child
					</span>
				</li>
				<li>
					pro.<a href="">isPrototypeOf</a>(obj)
					<span>
						判断当前对象是否为另一个对象的原型 <br>
						Object.prototype处于原型链的最顶端，所以对各种实例都返回true，只有继承null的对象除外。
					</span>
				</li>
				<li>
					<a href="">Object.getPrototypeOf</a>(obj)
					<span>
						获取对象的原型对象
					</span>
				</li>
				<li>
					<a href="">Object.setPrototypeOf</a><em>(obj,proto)</em>
					<span>
						为现有对象设置原型，返回新对象。
					</span>
				</li>
			</ul>
        </div>
    </div>
</div>