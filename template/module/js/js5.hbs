<!-- 对象 -->
<div class="u-col">
	<div class="u-block">
		<h3>对象<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>+</span>]构建</h4>
			<ul style="display:none;">
				<li>
					<a href="">{key:val,...}</a>
					<span>
						字面量创建方法 <br>
						对象的属性之间用逗号分隔，最后一个属性后面可以加逗号，也可以不加。 <br>
						对象的所有键名都是字符串，可以不加引号。但如果不符合表示名的条件，则需要加引号。<a href="http://javascript.ruanyifeng.com/grammar/object.html">参考资料</a> <hr>
						如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 <br>
						但如果取消某一个变量对于原对象的引用，不会影响到另一个变量。 <br>
						这种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝。 <br>
						故在设置一个新的对象继承旧对象时，不能直接通过new.prototype = old.prototype进行设置，否则对new原型的任何修改，将直接会影响旧的原型对象。
						<hr>
						如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。 <hr>
						如果读取一个不存在的键，会返回undefined，而不是报错。
					</span>
				</li>
				<li>
					<a href="">new Constructor()</a>
					<span>
						用构造函数创建 <br>
						<pre><code data-language="javascript">
							function Obj(opts){
								this.key = value
							}
							var o = new Obj(opts)
						</code></pre>
						注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。<br>
						如果忘记写new运算符，在strict模式下，this.name = name将报错，因为this绑定为undefined，在非strict模式下，this.name = name不报错，因为this绑定为window，于是无意间创建了全局变量name，并且返回undefined，这个结果更糟糕。
					</span>
				</li>
				<li>
					<a href="">new Object()</a>
					<span>
						var obj = new Object(); <br>
						obj.key = value;
					</span>
				</li>
				<li>
					<a href="">Object.creat(Object.prototype)</a>
					<span>
						var obj = Object.creat(Object.prototype) <br>
						从Object原型创建
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]属性</h4>
			<ul style="display:none;">
				<li>
					obj.<a href=""></a>key
					<span>
						当属性含空格、关键字或为变量时，只能用中括号表示 <br>
						不能对一个未声明的对象直接指定属性
					</span>
				</li>
				<li>
					obj.<a href="">hasOwnProperty</a>(key)
					<span>
						检测对象是否拥有某一属性（非原型继承） <br>
						返回值：布尔
					</span>
				</li>
				<li>
					<a href="">Object.getOwnPropertyNames</a><em>(obj)</em>
					<span>
						返回直接定义在某个对象上面的全部属性的名称。 <br>
						返回一个数组，成员是对象本身的所有属性的键名，不包含继承的属性键名。
					</span>
				</li>
				<li>
					<a href="">Object.keys</a>(obj)
					<span>
						查看一个对象的所有属性，返回一个key的数组，返回可枚举的属性 <br>
						Object.getOwnPropertyNames(obj)方法还返回不可枚举的属性名 <br>
						由于JavaScript没有提供计算对象属性个数的方法，所以可以用这两个方法代替 <br>
						Object.keys(o).length <br>
						Object.getOwnPropertyNames(o).length
					</span>
				</li>
				<li>
					<a href="">Object.values</a>(obj)
					<span>
						返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。
					</span>
				</li>
				<li>
					<a href="">Object.entries</a>(obj)
					<span>
						返回一个给定对象自身可枚举属性的键值对的二维数组 <br>
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">Object.getOwnPropertySymbols</a>(obj)
					<span>
						返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]属性描述</h4>
			<ul>
				<li>
					Desciptor<a href=""></a>
					<span>
						属性描述对象。 <br>
						数据对象与DOM对象的双向绑定：<a href="http://javascript.ruanyifeng.com/stdlib/attributes.html">参考资料</a>
					</span>
				</li>
				<li>
					desciptor.<a href="">value</a>
					<span>
						存放该属性的属性值，默认为undefined
					</span>
				</li>
				<li>
					desciptor.<a href="">writable</a>
					<span>
						存放一个布尔值，表示属性值是否可改变	
					</span>
				</li>
				<li>
					desciptor.<a href="">enumerable</a>
					<span>
						存放一个布尔值，表示该属性是否可枚举
					</span>
				</li>
				<li>
					desciptor.<a href="">configurable</a>
					<span>
						存放一个布尔值，表示“可配置性”。如果设为false，将阻止某些操作改写该属性，比如，无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。
					</span>
				</li>
				<li>
					desciptor.<a href="">get</a>
					<span>
						存放一个函数，表示该属性的取值函数（getter），默认为undefined
					</span>
				</li>
				<li>
					desciptor.<a href="">set</a>
					<span>
						存放一个函数，表示该属性的存值函数（setter），默认为undefined
					</span>
				</li>
				<li>
					<a href="">Object.getOwnPropertyDescriptor</a>(o,prop)
					<span>
						返回指定对象上一个自有属性对应的属性描述符。
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">参考资料</a>
					</span>
				</li>
				<li>
					<a href="">Ojbect.defineProperty</a><em>(o,prop,desciptor)</em>
					<span>
						在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 <br>
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">参考资料</a>
					</span>
				</li>
				<li>
					obj.<a href="">propertyIsEnumerable</a>(key)
					<span>
						判断某个属性是否可枚举
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]状态控制</h4>
			<ul style="display:none;">
				<li>
					<a href="">Object.preventExtensions</a>(obj)
					<span>
						防止对象扩展
					</span>
				</li>
				<li>
					<a href="">Object.isExtensible</a>(obj)
					<span>
						判断对象是否可扩展
					</span>
				</li>
				<li>
					<a href="">Object.seal</a>(obj)
					<span>
						禁止对象配置
					</span>
				</li>
				<li>
					<a href="">Object.isSealed</a>(obj)
					<span>
						判断一个对象是否可配置
					</span>
				</li>
				<li>
					<a href="">Object.freeze</a>(obj)
					<span>
						冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。
					</span>
				</li>
				<li>
					<a href="">Object.isFrozen</a>(obj)
					<span>
						判断一个对象是否被冻结
					</span>
				</li>
			</ul>
			<h4>[<span>-</span>]操作</h4>
			<ul>
				<li>
					<a href="">Object.assign</a>(to,from...)
					<span>
						浅拷贝。将所有可枚举属性的值从一个或多个源对象复制到目标对象，将返回目标对象。<br>
						只会拷贝源对象自身的并且可枚举的属性到目标对象 <br> 
						Object.assign 不会跳过那些值为 null 或 undefined 的源对象 <br>
						<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">参考资料</a>
						<hr>
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]其它</h4>
			<ul>
				<li>
					obj.<a href="">valueOf</a>()
					<span>
						可通过自定义valueOf的返回值来替换原型的返回值，以达到自动转换计算时预期的结果。
					</span>
				</li>
				<li>
					obj.<a href="">toString</a>()
					<span>
						可通过自定义toString方法替换原型的返回值。  <br>
						Object.prototype.toString.call(value) 可判断其构造函数：
						<table>
							<tr>
								<th>value</th>
								<th>返回值</th>
							</tr>
							<tr>
								<td>数值</td>
								<td>[object Number]</td>
							</tr>
							<tr>
								<td>字符串</td>
								<td>[object String]</td>
							</tr>
							<tr>
								<td>布尔值</td>
								<td>[object Boolean]</td>
							</tr>
							<tr>
								<td>undefined</td>
								<td>[object Undefined]</td>
							</tr>
							<tr>
								<td>null</td>
								<td>[object Null]</td>
							</tr>
							<tr>
								<td>数组</td>
								<td>[object Array]</td>
							</tr>
							<tr>
								<td>arguments对象</td>
								<td>[object Arguments]</td>
							</tr>
							<tr>
								<td>函数</td>
								<td>[object Function]</td>
							</tr>
							<tr>
								<td>Error对象</td>
								<td>[object Error]</td>
							</tr>
							<tr>
								<td>Date对象</td>
								<td>[object Date]</td>
							</tr>
							<tr>
								<td>RegExp对象</td>
								<td>[object RegExp]</td>
							</tr>
							<tr>
								<td>其他对象</td>
								<td>[object Object]</td>
							</tr>
						</table>
					</span>
				</li>
			</ul>
		</div>
	</div>
	<div class="u-block">
        <h3>对象扩展<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>-</span>]Symbol</h4>
            <ul>
                <li>
                    <a href="">Symbol</a>([des])
                    <span>
                        它是一种类似于字符串的数据类型，但独一无二。 <hr>
                        1.Symbol函数前不能使用new命令，否则会报错 <br>
                        2.Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。 <br>
                        3.Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 <br>
                        4.Symbol 值不能与其他类型的值进行运算 <br>
                        5.Symbol 值可以通过toString或String方法显式转为字符串 <br>
                        6.Symbol 值也可以转为布尔值，但是不能转为数值 <br>
                        7.不能使用.运算符，必须使用[] <br>
                        8.Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。
                    </span>
                </li>
                <li>
                    <a href="">Symbol.for</a>(str)
                    <span>
                        接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。
                    </span>
                </li>
                <li>
                    <a href="">Symbol.keyfor</a>(sb)
                    <span>
                        返回一个已登记的 Symbol 类型值的key
                    </span>
                </li>
            </ul>
			<h4>[<span>+</span>]Proxy</h4>
			<ul style="display:none;">
				<li>
					<a href="">new Proxy</a>(target,handler)
					<span>
						在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。 <br>
						<a href="http://es6.ruanyifeng.com/#docs/proxy">参考资料</a> <hr>
						通过改写return值，可实现链式操作
					</span>
				</li>
				<li>
					<a href="">get</a><em>(target, propKey, receiver)</em>
					<span>
						拦截对象属性的读取，比如proxy.foo和proxy['foo']。
					</span>
				</li>
				<li>
					<a href="">set</a><em>(target, propKey, value, receiver)</em>
					<span>
						拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">has</a><em>(target, propKey)</em>
					<span>
						拦截propKey in proxy的操作，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">deleteProperty</a><em>(target, propKey)</em>
					<span>
						拦截delete proxy[propKey]的操作，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">ownKeys</a><em>(target)</em>
					<span>
						拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。
					</span>
				</li>
				<li>
					<a href="">getOwnPropertyDescriptor</a><em>(target, propKey)</em>
					<span>
						拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
					</span>
				</li>
				<li>
					<a href="">defineProperty</a><em>(target, propKey, propDesc)</em>
					<span>
						拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">preventExtensions</a><em>(target)</em>
					<span>
						拦截Object.preventExtensions(proxy)，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">getPrototypeOf</a><em>(target)</em>
					<span>
						拦截Object.getPrototypeOf(proxy)，返回一个对象。
					</span>
				</li>
				<li>
					<a href="">isExtensible</a><em>(target)</em>
					<span>
						拦截Object.isExtensible(proxy)，返回一个布尔值。
					</span>
				</li>
				<li>
					<a href="">setPrototypeOf</a><em>(target, proto)</em>
					<span>
						拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
					</span>
				</li>
				<li>
					<a href="">apply</a><em>(target, object, args)</em>
					<span>
						拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。
					</span>
				</li>
				<li>	
					<a href="">construct</a><em>(target, args)</em>
					<span>
						拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。
					</span>
				</li>
				<li>
					<a href="">Proxy.revocable</a>(target, handler)
					<span>
						返回一个可取消的 Proxy 实例
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]Reflect</h4>
			<ul style="display:none;">
				<li>
					<a href="">Reflect</a>
					<span>
						1.将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。 <br>
						2.修改某些Object方法的返回结果，让其变得更合理。 <br>
						3.让Object操作都变成函数行为。 <br>
						<a href="http://es6.ruanyifeng.com/#docs/reflect">参考资料</a>
					</span>
				</li>
				<li>
					Reflect.<a href="">get</a><em>(target,name,[receiver])</em>
					<span>
						查找并返回target对象的name属性，如果没有该属性，则返回undefined。
					</span>
				</li>
				<li>
					Reflect.<a href="">set</a><em>(target,name,value,[receiver])</em>
					<span>
						设置target对象的name属性等于value
					</span>
				</li>
				<li>
					Reflect.<a href="">has</a><em>(obj,name)</em>
					<span>
						对应name in obj里面的in运算符
					</span>
				</li>
				<li>
					Reflect.<a href="">deleteProperty</a><em>(obj,name)</em>
					<span>
						等同于delete obj[name]，用于删除对象的属性
					</span>
				</li>
				<li>
					Reflect.<a href="">construct</a><em>(target,args)</em>
					<span>
						等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。
					</span>
				</li>
				<li>
					Reflect.<a href="">getPrototypeOf</a><em>(obj)</em>
					<span>
						用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。
					</span>
				</li>
				<li>
					Reflect.<a href="">setPrototypeOf</a><em>(obj,newProto)</em>
					<span>
						用于设置对象的__proto__属性，返回第一个参数对象，对应Object.setPrototypeOf(obj, newProto)。
					</span>
				</li>
				<li>
					Reflect.<a href="">apply</a><em>(fn,thisArg,args)</em>
					<span>
						等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。
					</span>
				</li>
				<li>
					Reflect.<a href="">defineProperty</a><em>(target,propertyKey,attributes)</em>
					<span>
						基本等同于Object.defineProperty，用来为对象定义属性。
					</span>
				</li>
				<li>
					Reflect.<a href="">getOwnPropertyDescriptor</a><em>(target,propertyKey)</em>
					<span>
						基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象
					</span>
				</li>
				<li>
					Reflect.<a href="">isExtensible</a><em>(target)</em>
					<span>
						对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。
					</span>
				</li>
				<li>
					Reflect.<a href="">preventExtensions</a><em>(target)</em>
					<span>
						对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。
					</span>
				</li>
				<li>
					Reflect.<a href="">ownKeys</a><em>(target)</em>
					<span>
						返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。
					</span>
				</li>
			</ul>
			<h4>[<span>+</span>]Error</h4>
			<ul style="display: none;">
				<li><a href="">new Error</a>('msg')<span>
					错误对象属性：
					<table>
						<tr>
							<th>属性</th>
							<th>描述</th>
						</tr>
						<tr>
							<td>err.message</td>
							<td>错误提示信息</td>
						</tr>
						<tr>
							<td>err.name</td>
							<td>错误名称（非标准属性）</td>
						</tr>
						<tr>
							<td>err.stack</td>
							<td>错误的堆栈（非标准属性）</td>
						</tr>
					</table>
					<br>
					原生错误类型：
					<table>
						<tr>
							<th>名称</th>
							<th>描述</th>
						</tr>
						<tr>
							<td>SyntaxError</td>
							<td>解析代码时发生的语法错误</td>
						</tr>
						<tr>
							<td>ReferenceError</td>
							<td>引用一个不存在的变量时发生的错误；将一个值分配给无法分配的对象</td>
						</tr>
						<tr>
							<td>RangeError</td>
							<td>当一个值超出有效范围时发生的错误</td>
						</tr>
						<tr>
							<td>TypeError</td>
							<td>变量或参数不是预期类型时发生的错误</td>
						</tr>
						<tr>
							<td>URIError</td>
							<td>URI相关函数的参数不正确时抛出的错误</td>
						</tr>
						<tr>
							<td>EvalError</td>
							<td>eval函数没有被正确执行</td>
						</tr>
						<tr>
							<td>自定义错误</td>
							<td><a href="http://javascript.ruanyifeng.com/grammar/error.html">参考资料</a></td>
						</tr>
					</table>

					<br><br>
					如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被JavaScript引擎捕获，代码终止执行。所以，我们不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获，一网打尽。<hr>
					涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。<br>
					类似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。
				</span></li>
				<li><a href="">throw</a> err<span>
					throw语句的作用是中断程序执行，抛出一个意外或错误。它接受一个表达式作为参数，可以抛出各种值。 <br>
					throw可以接受各种值作为参数。JavaScript引擎一旦遇到throw语句，就会停止执行后面的语句，并将throw语句的参数值，返回给用户。
				</span></li>
				<li><a href="">try{..}cath(e){..}finally{..}</a><span>
					<pre><code data-language="javascript">
						try {
						    //可能出错的语句
						    throw new Error('出错了!');
						} catch (e) {
						    //捕获e错误对象,try中抛出的错误对象
						} finally {
						    //总会执行
						    //执行finally代码块以后，程序就中断在错误抛出的地方。
						}
					</code></pre>
				</span></li>
			</ul>
        </div>
    </div>
</div>