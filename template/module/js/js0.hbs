<!-- 基本语法、标准库 -->
<div class="u-col">
    <div class="u-block">
		<h3>基本语法<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]变量</h4>
			<ul>
				<li><a href="">var</a><span>
					x1 = 1;<br />
					var x2 = 2;<br />
					window.x3 = 3;<br />
					<a href="http://snandy.iteye.com/blog/720816">3种全局变量的异同</a> <hr>
					判断某个全局变量是否存在用typeof window.myVar === 'undefined' <br>
					函数内部判断某个变量是否存在用typeof myVar === 'undefined'
				</span></li>
				<li><a href="">let</a><span>
					let i = 1;<br>
					申明一个块级作用域的变量
				</span></li>
				<li><a href="">const</a><span>
					const来定义常量，const与let都具有块级作用域。
					常量通常使用全大写。
					const PI = 3.14
				</span></li>
			</ul>
			<h4>[<span>+</span>]运算</h4>
			<ul style="display:none;">
				<li><a href="">一元运算符</a><span>
					<h2>一元运算符</h2>
						<div>
						<table width="100%">
						<tbody>
						<tr>
						<td>i++后置递增，++i前置递增，i--后置递减，--i前置递减，+i取正，-i取负</td>
						</tr>
						</tbody>
						</table>
						<div></div>
						</div>
						<ul>
							<li>只能操作一个值的运算符叫做一元运算符</li>
							<li>递增++和递减--、取正+、取负-</li>
							<li>递增递减中前置和后置的区别</li>
						</ul>
						<div>
						<blockquote>
						<div>在没有赋值操作， 前置和后置是一样的。 但在赋值操作时， 如果递增或递减运算符前置 ，
						那么前置的运算符会先累加或累减再赋值，如果是后置运算符则先赋值再累加或累减。</div>
						<div>var box = 100;
						var age = ++box; //age 值为 101
						var height = box++; //height 值为 100</div></blockquote>
						</div>
						<div>
						<ul>
							<li>非数值执行运算，会隐藏自动转型为数值（除+）</li>
						</ul>
						其他类型应用一元运算符的规则</div>
						<blockquote>
						<div>var box = '89'; box++; //90，数值字符串自动转换成数值</div>
						<div>var box = 'ab'; box++; //NaN，字符串包含非数值转成 NaN</div>
						<div>var box = false; box++; //1，false 转成数值是 0，累加就是 1</div>
						<div>var box = 2.3; box++; //3.3，直接加 1</div>
						<div>var box = { //1，不设置 toString 或 valueOf 即为 NaN</div>
						<div>toString : function() {</div>
						<div>return 1;</div>
						<div>}</div>
						<div>}; box++;</div></blockquote>
					</span></li>
				<li><a href="">算数运算符</a><span>
						<div><b>算术运算符</span></b></div>
								<div>
								<table width="100%">
								<tbody>
								<tr>
								<td>+加法，-减法，*乘法，/除法，%求模</span></td>
								</tr>
								</tbody>
								</table>
								<div></div>
								</div>
								<ul>
									<li><span style="color: #e30000; font-size: small;"><b>加法操作中，数值字符串与数值运算，则改变为字符串串联，减法中，会继续自动转换数值进行运算</b></span></li>
									<li>加法操作中，非数值字符串与数值运算，会串联字符串，减法中，则会得到NaN</span></li>
									<li>加法操作中，数值+object类型=字符串（Num[object]），减法中，则会得到NaN</span></li>
									<li>乘法操作中，数值*非数值字符串或对象返回NaN，除法与求模同NaN</span></li>
								</ul>
								<div></div></span></li>
				<li><a href="">关系运算符</a><span><div><b>关系运算符 <span style="color: #e30000;">（返回一个布尔值）</span></span></b></div>
						<div>
						<table width="100%">
						<tbody>
						<tr>
						<td>&gt;大于，&lt;小于，&gt;=大于等于，&lt;=小于等于，==相等，!=不等，===全等，!==不全等</span></td>
						</tr>
						</tbody>
						</table>
						<div></div>
						</div>
						<div>
						<ul>
							<li>两个操作数都是数值，则数值比较；</span></li>
							<li><span style="color: #0000ff; font-size: small;">两个操作数都是字符串，则比较两个字符串对应的字符编码值；</span></li>
							<li>两个操作数有一个是数值，则将另一个转换为数值，再进行数值比较；</span></li>
							<li>两个操作数有一个是对象，则先调用 valueOf()方法或 toString()方法，再用结果比较；</span></li>
							<li>不需要任何转换的情况下，null 和 undefined 是相等的；</span></li>
							<li>一个操作数是 NaN，则==返回 false，!=返回 true；并且 NaN 和自身不等；</span></li>
							<li>两个操作数都是对象，则比较他们是否是同一个对象，如果都指向同一个对象，则返回 true，否则返回 false。</span></li>
						</ul>
						</div>
						<blockquote>
						<div>var box = {} == {}; //false，比较的是他们的地址，每个新创建对象的</span></div>
						<div>引用地址都不同</span></div>
						<div>var age = {};</span></div>
						<div>var height = age;</span></div>
						<div>var box = age == height; </span><a>//true，引用地址一样，所以相等</span></a></div>
						<div> </span></div></blockquote></span></li>
				<li><a href="">逻辑运算符</a><span>
						<div><b>逻辑运算符</b><span style="color: #0000ff;">（通常用于布尔值的操作）</span></span></div>
						<div>
						<table width="100%">
						<tbody>
						<tr>
						<td>&amp;&amp;逻辑与(AND)、||逻辑或(OR)、!逻辑非(NOT)。</span></td>
						</tr>
						</tbody>
						</table>
						<div> </span></div>
						</div>
						<blockquote>
						<div><span style="color: #e30000;">如果两边的操作数有一个操作数不是布尔值的情况下，逻辑与运算就不一定返回布尔值</span>，此时，遵循已下规则：</span></div>
						<div> </span></div>
						<div><b>&amp;&amp;逻辑与</span></b></div></blockquote>
						<div>
						<ul>
							<li>
						<ul>
							<li>第一个操作数是对象，则返回第二个操作数；</span></li>
							<li>第二个操作数是对象，则第一个操作数返回 true， 才返回第二个操作数， 否则返回 false;</span></li>
							<li>有一个操作数是 null，则返回 null；</span></li>
							<li>有一个操作数是 undefined，则返回 undefined。</span></li>
						</ul>
						</li>
						</ul>
						</div>
						<blockquote>
						<blockquote>
						<div>var box = 对象 &amp;&amp; (5 &gt; 4); //true，返回第二个操作数</span></div></blockquote>
						<blockquote>
						<div>var box = (5 &gt; 4) &amp;&amp; 对象; //[object Object]</span></div></blockquote>
						<blockquote>
						<div>var box = (3 &gt; 4) &amp;&amp; 对象; //false</span></div></blockquote>
						<blockquote>
						<div>var box = (5 &gt; 4) &amp;&amp; null; </span><a>//null</span></a></div></blockquote>
						<blockquote>
						<div> </span></div></blockquote>
						<div><b>||逻辑或</span></b></div></blockquote>
						<div>
						<ul>
							<li>
						<ul>
							<li>第一个操作数是对象，则返回第一个操作数</span></li>
							<li>第一个操作数的求值结果为 false，则返回第二个操作数；</span></li>
							<li>两个操作数都是对象，则返回第一个操作数；</span></li>
							<li>两个操作数都是 null，则返回 null；</span></li>
							<li>两个操作数都是 NaN，则返回 NaN；</span></li>
							<li>两个操作数都是 undefined，则返回 undefined；</span></li>
						</ul>
						</li>
						</ul>
						</div>
						<blockquote>
						<blockquote>
						<div>var box = 对象 || (5 &gt; 3); //[object Object]</span></div></blockquote>
						<blockquote>
						<div>var box = (5 &gt; 3) || 对象; //true</span></div></blockquote>
						<blockquote>
						<div>var box = 对象 1 || 对象 2; //[object Object]</span></div></blockquote>
						<blockquote>
						<div>var box = null || null; //null</span></div></blockquote>
						<blockquote>
						<div>var box = NaN || NaN; //NaN</span></div></blockquote>
						<blockquote>
						<div>var box = undefined || undefined; //undefined</span></div></blockquote>
						<div> </span></div>
						<div><b>!逻辑非 </span></b></div>
						<div>逻辑非运算符可以用于任何值。 无论这个值是什么数据类型， 这个运算符都会<b><span style="color: #0000ff;">返回一个布尔值</span></b>。它的流程是：先将这个值转换成布尔值，然后取反。</span></div>
						<div>通常来说， 使用一个逻辑非运算符和两个逻辑非运算符可以得到相应的布尔值。</span></div></blockquote>
						<ul>
							<li>
						<ul>
							<li>操作数是一个对象，返回 false；</span></li>
							<li>操作数是一个空字符串，返回 true；</span></li>
							<li>操作数是一个非空字符串，返回 false；</span></li>
							<li>操作数是数值 0，返回 true；</span></li>
							<li>操作数是任意非 0 数值(包括 Infinity)，false；</span></li>
							<li>操作数是 null，返回 true；</span></li>
							<li>操作数是 NaN，返回 true；</span></li>
							<li>操作数是 undefined，返回 true；</span></li>
						</ul>
						</li>
						</ul>
						<div></div>
				</span></li>
				<li><a href="">其他运算符</a><span>
						<h2>赋值运算符</span></h2>
							<table width="100%">
							<tbody>
							<tr>
							<td>乘/赋(*=)  除/赋(/=)  模/赋(%=)  加/赋(+=)  减/赋(-=)  左移/赋(&lt;&lt;=)  有符号右移/赋(&gt;&gt;=)  无符号有移/赋(&gt;&gt;&gt;=)</span></td>
							</tr>
							</tbody>
							</table>
							<div> </span></div>
							<div>

							<hr />

							</div>
							<h2>位操作符</span></h2>
							<div>
							<table width="100%">
							<tbody>
							<tr>
							<td>~按位非，&amp;按位与，|按位或，^按位异或，&lt;&lt;左移，&gt;&gt;有符号右移，&gt;&gt;&gt;无符号右移</span></td>
							</tr>
							</tbody>
							</table>
							<div>
							</span>
							</span></div>
							</div>
							<div>

							<hr />

							 </span></div>
							<div><b>其他运算符</span></b></div>
							<div>
							<table width="100%">
							<tbody>
							<tr>
							<td>+ 字符串运算符 、 ,逗号运算符 、三元运算符</span></td>
							</tr>
							</tbody>
							</table>
							<div> </span></div>
							</div>
							<div>字符串运算符只有一个，即："+"。它的作用是将两个字符串相加。</span></div>
							<div>逗号运算符可以在一条语句中执行多个操作。</span></div>
							<div>三元条件运算符 a ? b : c</span></div>
				</span></li>
				<li><a href="">运算符优先级</a><span>
					<div><b>运算符优先级</span></b></div>
							<div><span>如果没有使用<strong>圆括号强制优先级</strong>，我们必须遵循以下顺序：
							</span><strong>算术操作符 → 比较操作符 → 逻辑操作符 → "="赋值符号</strong></span></div>
							<div>
							<table width="100%">
							<tbody>
							<tr>
							<td>
							<div>运算符</span></div></td>
							<td>
							<div>描述</span></div></td>
							</tr>
							<tr>
							<td>
							<div>. [] () </span></div></td>
							<td>
							<div>对象成员存取、数组下标、函数调用等</span></div></td>
							</tr>
							<tr>
							<td>
							<div>++ -- ~ ! delete new typeof void</span></div></td>
							<td>
							<div>一元运算符</span></div></td>
							</tr>
							<tr>
							<td>
							<div>* / %</span></div></td>
							<td>
							<div>乘法、除法、去模</span></div></td>
							</tr>
							<tr>
							<td>
							<div>+ - +</span></div></td>
							<td>
							<div>加法、减法、字符串连接</span></div></td>
							</tr>
							<tr>
							<td>
							<div>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</span></div></td>
							<td>
							<div>移位</span></div></td>
							</tr>
							<tr>
							<td>
							<div>&lt; &lt;= &gt; &gt;= instanceof </span></div></td>
							<td>
							<div>关系比较、检测类实例</span></div></td>
							</tr>
							<tr>
							<td>
							<div>== != === !==</span></div></td>
							<td>
							<div>恒等(全等)</span></div></td>
							</tr>
							<tr>
							<td>
							<div>&amp; </span></div></td>
							<td>
							<div>位与</span></div></td>
							</tr>
							<tr>
							<td>
							<div>^ </span></div></td>
							<td>
							<div>位异或</span></div></td>
							</tr>
							<tr>
							<td>
							<div>|</span></div></td>
							<td>
							<div>位或</span></div></td>
							</tr>
							<tr>
							<td>
							<div>&amp;&amp;</span></div></td>
							<td>
							<div>逻辑与</span></div></td>
							</tr>
							<tr>
							<td>
							<div>||</span></div></td>
							<td>
							<div>逻辑或</span></div></td>
							</tr>
							<tr>
							<td>
							<div>?:</span></div></td>
							<td>
							<div>三元条件</span></div></td>
							</tr>
							<tr>
							<td>
							<div>= x=</span></div></td>
							<td>
							<div>赋值、运算赋值</span></div></td>
							</tr>
							<tr>
							<td>
							<div>, </span></div></td>
							<td>
							<div>多重赋值、数组元素</span></div></td>
							</tr>
							</tbody>
							</table>
							</div>
				</span></li>
			</ul>
			<h4>[<span>+</span>]语句</h4>
			<ul style="display:none;">
				<li><a href="">if</a><span>if else else if</span></li>
				<li><a href="">switch</a><span>
					1.<a href="http://www.qttc.net/201207151.html">switch中的case为全等判断</a><br>
					2.多个case使用同一个执行块应写为case 1: case2: ...
				</span></li>
				<li><a href="">for</a><span>
					for...in... <br>
					for...of...
				</span></li>
				<li><a href="">while</a><span>do...while...</span></li>
				<li><a href="">continue</a><span></span></li>
				<li><a href="">break</a><span></span></li>
				<li><a href="">throw</a><span></span></li>
				<li><a href="">try</a><span>try {} catch (e) {} finally {}</span></li>
				<li><a href="">export</a><span>用来导出函数，以便这些函数能够被导入到外部模块或其他script中。</span></li>
				<li><a href="">import</a><span>用来引入外部的模块或另一个script中导出的函数。</span></li>
				<li><a href="">eval</a>(str)<span>计算 JavaScript 字符串，并把它作为脚本代码来执行。</span></li>
			</ul>
			<h4>[<span>+</span>]其它</h4>
			<ul>
				<li><a href="">'use strict'</a><span>
					严格模式下，函数中的this指向Undefined，非window对象。
				</span></li>
			</ul>
		</div>
    </div>
    <div class="u-block">
    	<h3>数据类型<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]类型检测</h4>
			<ul>
				<li><a href="">typeof</a> val<span>
					返回的是字符串。
						<table>
							<tr>
								<th>测试值</th>
								<th>结果</th>
							</tr>
							<tr>
								<td>true/false</td>
								<td>boolean</td>
							</tr>
							<tr>
								<td>数值/NaN</td>
								<td>boolean</td>
							</tr>
							<tr>
								<td>字符串/JSON</td>
								<td>string</td>
							</tr>
							<tr>
								<td>fn</td>
								<td>function</td>
							</tr>
							<tr>
								<td>obj/数组/null</td>
								<td>object</td>
							</tr>
							<tr>
								<td>undefined/不存在的属性或方法</td>
								<td>undefined</td>
							</tr>
						</table>
						<ol>
							<li>判断null请使用myVar === null</li>
							<li>
						不存在的变量与未声明的变量typeof检测均为undefined，但两者其实不同，故建议总是初始化。</li>
							<li>
						Null 类型是一个只有一个值的数据类型，即特殊的值 null。它表示一个空对象引用(指针)，而 typeof 操作符检测 null 会返回 object。如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null。这样， 当检查 null 值就知道是否已经变量是否已经分配了对象引用了。</li>
							<li>
						undefined 是派生自 null 的，因此 ECMA-262 规定对它们的相等性测试返回 true。alert(undefined == null);但typeof数据类型不等。</li>
						</ol>
					</span></li>
				<li><a href="">Array.isArray</a>(arr)<span>检测是否为数组（EC5）</span></li>
				<li>val <a href="">instanceof</a> type
					<span>instanceof引用类型数据测试，返回布尔值。
						<table>
							<tr>
								<th>测试目标</th>
								<th>测试结果</th>
							</tr>
							<tr>
								<td>数组</td>
								<td>arr instanceof Array</td>
							</tr>
							<tr>
								<td>函数/构造函数</td>
								<td>fn instanceof Function</td>
							</tr>
							<tr>
								<td>构造函数实例</td>
								<td>child instanceof parent</td>
							</tr>
							<tr>
								<td>泛对象</td>
								<td>obj instanceof Object</td>
							</tr>
							<tr>
								<td>日期</td>
								<td>value instanceof Date</td>
							</tr>
							<tr>
								<td>正则表达式</td>
								<td>value instanceof RegExp</td>
							</tr>
							<tr>
								<td>数学</td>
								<td>value instanceof Math</td>
							</tr>
						</table>
					</span></li>
			</ul>
			<h4>[<span>-</span>]类型转换</h4>
			<ul>
				<li><a href="">Boolean</a>(val)
					<span>Boolean(val)布尔转换规则 （控制流会自动转换）
						<table>
							<tbody>
							<tr>
							<th>Boolean(value)</th>
							<th>true</th>
							<th>false</th>
							</tr>
							<tr>
							<td>undefined</td>
							<td></td>
							<td>undefined</td>
							</tr>
							<tr>
							<td>boolean</td>
							<td>true</td>
							<td>false</td>
							</tr>
							<tr>
							<td>string</td>
							<td>非空</td>
							<td>空</td>
							</tr>
							<tr>
							<td>number</td>
							<td>非零数值</td>
							<td>0与NaN</td>
							</tr>
							<tr>
							<td>object</td>
							<td>对象（包括空的对象）</td>
							<td>null（空对象）</td>
							</tr>
							</tbody>
						</table>
					</span></li>
				<li><a href="">Number</a>(val)<span>
						用于任何数据类型
						<table>
							<tr>
								<th>value</th>
								<th>返回值</th>
							</tr>
							<tr>
								<td>number</td>
								<td>number</td>
							</tr>
							<tr>
								<td>boolean</td>
								<td>1 / 0</td>
							</tr>
							<tr>
								<td>null</td>
								<td>0</td>
							</tr>
							<tr>
								<td>空字符串</td>
								<td>0</td>
							</tr>
							<tr>
								<td>undefined</td>
								<td>NaN</td>
							</tr>
							<tr>
								<td>非数值(string+/object)</td>
								<td>NaN</td>
							</tr>
						</table>
					</span></li>
				<li><a href="">String</a>(val)
					<span>不确定null和undefined时,返回null和undefined</span></li>
				<li><em>包装对象</em><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143449957099176f55ba07b764c3daa522217d0e42643000"></a><span></span></li>
			</ul>
		</div>
    </div>
    <div class="u-block">
    	<h3>数字<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>+</span>]Number</h4>
			<ul style="display: none;">
				<li><a href="">Finity</a><span>
					Finity isFinite(---) 判断是否为无穷
						<table>
						<tbody>
						<tr>
						<td>
						最大值</td>
						<td>
						Number.MAX_VALUE 1.79e+308</td>
						</tr>
						<tr>
						<td>
						<div>最小值</div></td>
						<td>
						Number.MIN_VALUE 5e-324</td>
						</tr>
						<tr>
						<td>
						<div>正无穷</div></td>
						<td>
						Number.POSITIVE_INFINITY</td>
						</tr>
						<tr>
						<td>
						<div>负无穷</div></td>
						<td>
						Number.NEGATIVE_INFINITY</td>
						</tr>
						</tbody>
						</table>
						<ul>
							<li>科学计数法，浮点数+e+10的指数</li>
							<li>0/0=NaN，正数/0=正无穷，负数/0=负无穷</li>
							<li>正无穷+正无穷=正无穷，负无穷+负无穷=负无穷，正无穷+负无穷=NaN</li>
							<li>无穷乘法操作得到无穷，无穷除法与求余操作得到NaN</li>
						</ul>
				</span></li>
				<li><a href="">NaN</a><span>
						NaN isNaN(---) 判断是否为NaN
							<table>
							<tbody>
							<tr>
							<td>Number.NaN</td>
							<td>
							得到 NaN 值</td>
							</tr>
							<tr>
							<td>
							var box = 0 / 0; //NaN
							var box = 12 / 0; //Infinity
							var box = 12 / 0 * 0; //NaN</td>
							<td>
							任何与 NaN 进行运算的结果均为 NaN</td>
							</tr>
							<tr>
							<td>alert(NaN == NaN) //false</td>
							<td>NaN 与自身不相等(NaN 不与任何值相等)</td>
							</tr>
							</tbody>
							</table>
							<ul>
								<li>isNaN()函数也适用于对象。</li>
								<li>在调用 isNaN()函数过程中，首先会调用 valueOf()方法， 然后确定返回值是否能够转换成数值。如果不能，则基于这个返回值再调用 toString()方法，再测试返回值。</li>
								<li>只要NaN参与的运算均为NaN</li>
							</ul>
				</span></li>
				<li>Number.<a href="">MAX_VALUE</a><span>1.7976931348623157e+308</span></li>
				<li>Number.<a href="">MIN_VALUE</a><span>5e-324 <br>MIN_VALUE 是 JavaScript 最接近0的数,不是负值</span></li>
				<li>Number.<a href="">NEGATIVE_INFINITY</a><span>-Infinity 负无穷</span></li>
				<li>Number.<a href="">POSITIVE_INFINITY</a><span>Infinity 正无穷</span></li>
			</ul>
			<h4>[<span>-</span>]表示</h4>
			<ul>
				<li>num.<a href="">toFixed</a>([bit])<span>
					指定小数点后位数。<br>
					把 Number 四舍五入为指定小数位数的数字，返回的是一个字符串。<br>
					规定小数的位数，是 0 ~ 20 之间的值，包括 0 和 20，有些实现可以支持更大的数值范围。如果省略了该参数，将用 0 代替并四舍五入。
				</span></li>
				<li>num.<a href="">toString</a>([ary])<span>
					转为字符串，并指定进制，默认为10进制。<br>
					直接转换时写为123..toString()或(123).toString()
				</span></li>
				<li>num.<a href="">toLocaleString</a>(local,[opt])<span>
					根据本地数字格式转换为字符串 1,000.789 <br>
					<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString">参考资料</a>
				</span></li>
				<li>num.<a href="">toExponential</a>([bit])<span>
					使用指数计数法。<br>
					把对象的值转换为指数计数法，返回的是一个字符串。<br>
					参数可选。规定指数计数法中的小数位数，是 0 ~ 20 之间的值，包括 0 和 20，有些实现可以支持更大的数值范围。如果省略了该参数，将使用尽可能多的数字。
				</span></li>
				<li>num.<a href="">toPrecision</a>([bit])<span>
					把数字格式化为指定的长度。N为显示位数，自动选择toFixed() toExponential(N)两者之一。
				</span></li>
			</ul>
			<h4>[<span>-</span>]检测</h4>
			<ul>
				<li>[Number.]<a href="">isNaN</a>(val)<span>
					是否为非数值,转换后非数值为true，数值false
					<br>1. 非数值执行运算，会隐藏自动转型（除+）
					<br>2. 加法操作中，数值字符串与数值运算，则改变为字符串串联，减法中，会继续自动转换数值进行运算</span></li>
				<li>[Number.]<a href="">isFinite</a>(val)<span>判断是否为无穷值超出计算范围</span></li>
				<li>Number.<a href="">isInteger</a>(val)<span>
					判断给定的参数是否为整数
				</span></li>
			</ul>
			<h4>[<span>-</span>]转换</h4>
			<ul>
				<li>[Number.]<a href="">parseInt</a>(val)<span>
					自动判定进制，忽略空格。
					<table>
						<tr>
							<th>value</th>
							<th>结果</th>
						</tr>
						<tr>
							<td>空字符串</td>
							<td>NaN</td>
						</tr>
						<tr>
							<td>第一个非空字符不是数值或负号</td>
							<td>NaN</td>
						</tr>
						<tr>
							<td>第一个非空字符是数值，遇到非数值时停止解析</td>
							<td>number</td>
						</tr>
					</table>
					</span></li>
				<li>[Number.]<a href="">parseFloat</a>(val)<span>
					第一个小数点有效，第二个无效</span></li>
			</ul>
		</div>
    </div>
</div>