<!-- 数组 -->
<div class="u-col">
	<div class="u-block">
		<h3>数组<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]Array</h4>
			<ul>
				<li><a href="">new Array()</a><span>
					<table>
						<tr>
							<th>创建方法</th>
							<th>演示</th>
						</tr>
						<tr>
							<td>构造函数</td>
							<td>
								var arr = new Array(); <br>
								arr[0]=value; <br>
								var arr = new Array(element0, element1, ..., elementn);<br>
								var arr = new Array(size);  [size=数组项目的个数,只写1位,且必须是数字]
							</td>
						</tr>
						<tr>
							<td>字面量</td>
							<td>var arr = [66,80,90,77,59]</td>
						</tr>
					</table>
					注意：<br>
					1. ECMAScript中的数组每个元素可以保存任何类型<br>
					2. ECMAScript 中数组的大小也是可以调整的。<br>
					3. var arr = new Array(10)  不等于 var arr = [10]
					</span></li>
				<li>arr.<a href="">length</a><span>
					<table>
						<tr>
							<th>对象</th>
							<th>含义</th>
						</tr>
						<tr>
							<td>str.length</td>
							<td>字符串长度</td>
						</tr>
						<tr>
							<td>arr.length</td>
							<td>数组长度</td>
						</tr>
						<tr>
							<td>function.length</td>
							<td>参数长度/个数</td>
						</tr>
						<tr>
							<td>number</td>
							<td>-</td>
						</tr>
						<tr>
							<td>object</td>
							<td>-</td>
						</tr>
					</table>
				</span></li>
				<li>arr.<a href="">[index]</a><span>
<pre><code data-language="javascript">
	var  box =[];
	box['name']=iRuxu;
	alert(box);  //空
	alert(box['name']); //iRuxu
	alert(box[0]); //iRuxu 
</code></pre>
如果是字符串下标，不会体现在数组上，需要指定下标键打印，如果是索引下标，则可以直接打印
				</span></li>
			</ul>
			<h4>[<span>-</span>]Set</h4>
			<ul>
				<li><a href="">new Set()</a><span>
					Set是一组key的集合，但不存储value，且key不能重复。<br>
					要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set。
<pre><code data-language="javascript">
	var s1 = new Set(); // 空Set
	var s2 = new Set([1, 2, 3]); // 含1, 2, 3
</code></pre>
				</span></li>
				<li>set.<a href="">add</a>(key)<span>
					s.add(4)
					//Set {1,2,3,4}
				</span></li>
				<li>set.<a href="">delete</a>(key)<span>
					s.delete(3)
				</span></li>
			</ul>
			<h4>[<span>-</span>]添加移除</h4>
			<ul>
				<li><a href="">push()</a><span>栈：后方添加项目，返回总数。</span></li>
				<li><a href="">pop()</a><span>栈：后方移除项目，返回移除项。</span></li>
				<li><a href="">unshift()</a><span>队列：前方添加项目，返回总数。</span></li>
				<li><a href="">shift()</a><span>队列：前方移除项目，返回移除项。</span></li>
			</ul>
			<h4>[<span>-</span>]串联分割</h4>
			<ul>
				<li><a href="">concat()</a><span>连接两个或更多的数组，并返回结果，返回新数组。（合并数组->新）</span></li>
				<li><a href="">slice</a>(n,m)<span>从某个已有的数组返回选定的元素，返回新数组。（过滤数组->新）
						<br>当含1个参数时，起始到末尾全部：slice(1)——索引为1开始到末尾
						<br>当含2个参数时，起始到末尾-1：slice(1,4)——索引为1~3，不包含4</span></li>
				<li><a href="">splice</a>(n,m,[val])<span>
							方法向/从数组中添加/删除/替换项目，然后返回被删除的项目。
							<br>注释：请注意，splice() 方法与 slice() 方法的作用是不同的，splice()方法会直接对数组进行修改。
							<br>第1个参数为起始索引位置，第2个参数为删除的数目，当数目为0时则为添加项目，第3个参数开始为添加新的项目（如只删除无此参数）。
							<br>splice(0,1)——位置0删除1项
							<br>splice(2,0,arr1,arr2) ——位置2开始添加2项
							<br>splice(1,1,100) —— 位置1删除并添加1项 
				</span></li>
				<li><a href="">join</a>(符号)<span>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</span></li>
			</ul>
			<h4>[<span>-</span>]排序</h4>
			<ul>
				<li><a href="">reverse()</a><span>反转</span></li>
				<li><a href="">sort()</a><span>默认升序排列</span></li>
				<li><a href="">sort</a>(fn)<span>严格升序或降序排列
					<br>function sortNumber(a,b){return a - b  //降序b-a}
					<br>sort方法参数如果提供一个函数，那么该函数必须返回以下值之一：
					<br>负值，所传递的第一个参数比第二个参数小；
					<br>正值，所传递的第一个参数比第二个参数大；
					<br>零，两个参数相等。</span></li>
				</ul>
			<h4>[<span>-</span>]查找位置</h4>
			<ul>
				<li><a href="">indexOf</a>(value,n)<span>正向查找,n为起始索引,如查找不到则返回-1</span></li>
				<li><a href="">lastIndexOf</a>(value,n)<span>逆向查找 </span></li>
			</ul>
			<h4>[<span>-</span>]迭代方法</h4>
			<ul>
				<li><a href="">every</a>(fn[item,index,arr])<span>每一项为true，返回true
						<br>arr.every(function(item,index,array){
						<br>要求
						<br>})</span></li>
				<li><a href="">some</a>(fn[item,index,arr])<span>某一项为true，返回true
						<br>arr.some(function(item,index,array){
						<br>要求
						<br>})</span></li>
				<li><a href="">filter</a>(fn[item,index,arr])<span>			
						返回为true的新数组，按某个函数方法过滤
						<br>arr.filter(function(item,index,array){
						<br>要求
						<br>})</span></li>
				<li><a href="">map</a>(fn[item,index,arr])<span>返回执行函数后的新数组
						<br>arr.map(function(item,index,array){
						要求
						<br>})</span></li>
			</ul>
			<h4>[<span>-</span>]递归方法</h4>
			<ul>
				<li><a href="">reduce</a><span>返回正向函数执行后的归并值
							arr.reduce(function(prev,cur,index,array){
							<br>return prev+cur;
							<br>})</span></li>
				<li><a href="">reduceRight</a><span>
							<br>var arr=[1,2,3]
							<br>var sum=arr.reduce(function(prev,cur,index,array){
							<br>return prev+cur;
							<br>})
							<br>alert(sum); //6 
				</span></li>
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>iterable<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]迭代</h4>
			<ul>
				<li><a href="">forEach</a>(fn[val,i,o])<i>ES5.1</i><span>
				Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身<br>
				Map的回调函数参数依次为value、key和map本身
				<table>
					<tr>
						<th>类型</th>
						<th>参数</th>
					</tr>
					<tr>
						<td>array</td>
						<td>value,index,array</td>
					</tr>
					<tr>
						<td>set</td>
						<td>value,value,set</td>
					</tr>
					<tr>
						<td>map</td>
						<td>value,key,map</td>
					</tr>
				</table>
<pre><code data-language="javascript">
	var a = ['A', 'B', 'C'];
	a.forEach(function (element, index, array) {
		// element: 指向当前元素的值
		// index: 指向当前索引
		// array: 指向Array对象本身
	alert(element);
	});
</code></pre>
				</span></li>
			</ul>
		</div>
	</div>
</div>