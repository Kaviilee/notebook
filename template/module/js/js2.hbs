<!-- 数组 -->
<div class="u-col">
	<div class="u-block">
		<h3>数组<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]Array</h4>
			<ul>
				<li><a href="">new Array()</a><span>
					<table>
						<tr>
							<th>创建方法</th>
							<th>演示</th>
						</tr>
						<tr>
							<td>构造函数</td>
							<td>
								var arr = new Array(); <br>
								arr[0]=value; <br>
								var arr = new Array(element0, element1, ..., elementn);<br>
								var arr = new Array(size);  [size=数组项目的个数,只写1位,且必须是数字]
							</td>
						</tr>
						<tr>
							<td>字面量</td>
							<td>var arr = [66,80,90,77,59]</td>
						</tr>
					</table>
					注意：<br>
					1. ECMAScript中的数组每个元素可以保存任何类型<br>
					2. ECMAScript 中数组的大小也是可以调整的。<br>
					3. var arr = new Array(10)  不等于 var arr = [10]
					</span></li>
				<li>arr.<a href="">length</a><span>
					<table>
						<tr>
							<th>对象</th>
							<th>含义</th>
						</tr>
						<tr>
							<td>str.length</td>
							<td>字符串长度</td>
						</tr>
						<tr>
							<td>arr.length</td>
							<td>数组长度</td>
						</tr>
						<tr>
							<td>function.length</td>
							<td>参数长度/个数</td>
						</tr>
						<tr>
							<td>number</td>
							<td>-</td>
						</tr>
						<tr>
							<td>object</td>
							<td>-</td>
						</tr>
					</table>
				</span></li>
				<li>arr<a href="">[index]</a><span>
<pre><code data-language="javascript">
	var  box =[];
	box['name']=iRuxu;
	alert(box);  //空
	alert(box['name']); //iRuxu
	alert(box[0]); //iRuxu 
</code></pre>
如果是字符串下标，不会体现在数组上，需要指定下标键打印，如果是索引下标，则可以直接打印
				</span></li>
			</ul>
			<h4>[<span>-</span>]Set</h4>
			<ul>
				<li><a href="">new Set()</a><span>
					Set是一组key的集合，但不存储value，且key不能重复。<br>
					要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set。
<pre><code data-language="javascript">
	var s1 = new Set(); // 空Set
	var s2 = new Set([1, 2, 3]); // 含1, 2, 3
</code></pre>
				</span></li>
				<li>set.<a href="">add</a>(key)<span>
					s.add(4)
					//Set {1,2,3,4}
				</span></li>
				<li>set.<a href="">delete</a>(key)<span>
					s.delete(3)
				</span></li>
			</ul>
			<h4>[<span>-</span>]添加移除</h4>
			<ul>
				<li><a href="">push()</a><span>栈：后方添加项目，返回总数。</span></li>
				<li><a href="">pop()</a><span>栈：后方移除项目，返回移除项。</span></li>
				<li><a href="">unshift()</a><span>队列：前方添加项目，返回总数。</span></li>
				<li><a href="">shift()</a><span>队列：前方移除项目，返回移除项。</span></li>
			</ul>
			<h4>[<span>-</span>]串联分割</h4>
			<ul>
				<li><a href="">concat()</a><span>连接两个或更多的数组，并返回结果，返回新数组。（合并数组->新）</span></li>
				<li><a href="">slice</a>(n,m)<span>从某个已有的数组返回选定的元素，返回新数组。（过滤数组->新）
						<br>当含1个参数时，起始到末尾全部：slice(1)——索引为1开始到末尾
						<br>当含2个参数时，起始到末尾-1：slice(1,4)——索引为1~3，不包含4</span></li>
				<li><a href="">splice</a>(n,m,[val])<span>
							方法向/从数组中添加/删除/替换项目，然后返回被删除的项目。
							<br>注释：请注意，splice() 方法与 slice() 方法的作用是不同的，splice()方法会直接对数组进行修改。
							<br>第1个参数为起始索引位置，第2个参数为删除的数目，当数目为0时则为添加项目，第3个参数开始为添加新的项目（如只删除无此参数）。
							<br>splice(0,1)——位置0删除1项
							<br>splice(2,0,arr1,arr2) ——位置2开始添加2项
							<br>splice(1,1,100) —— 位置1删除并添加1项 
				</span></li>
				<li><a href="">join</a>(符号)<span>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</span></li>
			</ul>
			<h4>[<span>-</span>]查找位置</h4>
			<ul>
				<li><a href="">indexOf</a>(value,n)<span>正向查找,n为起始索引,如查找不到则返回-1</span></li>
				<li><a href="">lastIndexOf</a>(value,n)<span>逆向查找 </span></li>
			</ul>
			<h4>[<span>-</span>]排序</h4>
			<ul>
				<li><a href="">sort</a>([fn(a,b)])<span>
					默认排序顺序为按字母升序（字符串模式） <br>
					默认把所有元素先转换为String再排序。即结果'10'排在了'2'的前面，因为字符'1'比字符'2'的ASCII码小，大写比小写靠前。<br>
					函数执行完返回的是对数组的引用，请注意，数组在原数组上进行排序并修改原数组，并不生成副本。
					<hr>
					sort方法参数如果提供一个函数，那么该函数必须返回以下值之一：<br>
					负值，所传递的第一个参数比第二个参数小；<br>
					正值，所传递的第一个参数比第二个参数大；<br>
					零，两个参数相等。<br>
<pre><code data-language="javascript">
	arr.sort(function(a,b){
		//升序
		return a - b;
		//降序
		return b - a;

		//升序
		if (x < y) {
		    return -1;
		}
		if (x > y) {
		    return 1;
		}
			return 0;
		})
</code></pre>
					</span></li>
				<li><a href="">reverse()</a><span>
					反转
				</span></li>
				</ul>
			<h4>[<span>-</span>]迭代递归</h4>
			<ul>
				<li><a href="">map</a><em>(fn(item,[i],[arr]),[obj])</em><span>
					通过指定函数处理数组的每个元素，并返回处理后的数组，map()不会改变原始数组。<br>
					obj对象作为该执行回调时使用，传递给函数，用作 "this" 的值。如果省略了 thisValue ，"this" 的值为 "undefined"。<hr>
					map()与forEach()的区别：<br>
					<table>
						<tr>
							<th>map</th>
							<th>forEach</th>
						</tr>
						<tr>
							<td>返回新的数组</td>
							<td>返回undefine</td>
						</tr>
						<tr>
							<td>执行回调，应在回调中return计算后的新值</td>
							<td>只执行回调函数，对应的打印等操作或新建数组需在回调中声明</td>
						</tr>
					</table>
					</span></li>
				<li><a href="">reduce</a><em>(fn(cur,item,[i],[arr]),[init])</em><span>
					方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。<br>
					回调函数需返回cur，执行完成reduce会返回最终total值。<br>
					<a href="http://www.runoob.com/jsref/jsref-reduce.html">参考资料</a>
					</span></li>
				<li><a href="">reduceRight</a><em>(fn(cur,item,[i],[arr]),[init])</em><span>
					从右向左递归。
				</span></li>
			</ul>
			<h4>[<span>-</span>]筛选过滤</h4>
			<ul>
				<li><a href="">filter</a><em>(fn(item,[i],[arr]),[obj])</em><span>			
					检测数值元素，并返回符合条件所有元素的数组。<br>
					和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。<br>
					<a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014351219769203e3fbe1ed611475db3d439393add8997000">参考资料</a>
					</span></li>
				<li><a href="">every</a><em>(fn(item,[i],[arr]),[obj])</em><span>
					every()方法用于检测数组所有元素是否都符合指定条件，如果数组中检测到有一个元素不满足，则整个表达式返回 false，且剩余的元素不会再进行检测；如果所有元素都满足条件，则返回 true。
<pre><code data-language="javascript">
	var ages = [32, 33, 16, 40];
	function checkAdult(age) {
	    return age >= 18;
	}
</code></pre>
					</span></li>
				<li><a href="">some</a><em>(fn(item,[i],[arr]),[obj])</em><span>
					some() 方法用于检测数组中的元素是否满足指定条件，如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。如果没有满足条件的元素，则返回false。
				</span></li>
				<li><a href="">find</a><em>(fn(item,[i],[arr]),[obj])</em><span>
					find() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素。当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined。
				</span></li>
				<li><a href="">遍历方法对比一览</a><span>
					<table>
						<tr>
							<th>方法</th>
							<th>回调函数返回值</th>
							<th>方法返回值</th>
						</tr>
						<tr>
							<td>map</td>
							<td>return new_item</td>
							<td>retrun new_array</td>
						</tr>
						<tr>
							<td>forEach</td>
							<td>-</td>
							<td>undefine</td>
						</tr>
						<tr>
							<td>reduce/reduceRight</td>
							<td>return cur_value</td>
							<td>return total_value</td>
						</tr>
						<tr>
							<td>filter</td>
							<td>return true/false</td>
							<td>return filter_array</td>
						</tr>
						<tr>
							<td>every/some</td>
							<td>return true/false</td>
							<td>return true/false</td>
						</tr>
						<tr>
							<td>find</td>
							<td>return true/false</td>
							<td>return value/undefined</td>
						</tr>
					</table>
				</span></li>
			</ul>
			<h4>[<span>-</span>]其它</h4>
			<ul>
				
			</ul>
		</div>
	</div>
	<div class="u-block">
		<h3>Iterable (Array/Map/Set)<span>-</span></h3>
		<div class="u-list">
			<h4>[<span>-</span>]迭代</h4>
			<ul>
				<li><a href="">forEach</a><em>(fn(val,[i],[iterable]))</em><span>
				每个元素都执行一次回调函数。<br>
				Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身<br>
				Map的回调函数参数依次为value、key和map本身
				<table>
					<tr>
						<th>类型</th>
						<th>参数</th>
					</tr>
					<tr>
						<td>array</td>
						<td>value,index,array</td>
					</tr>
					<tr>
						<td>set</td>
						<td>value,value,set</td>
					</tr>
					<tr>
						<td>map</td>
						<td>value,key,map</td>
					</tr>
				</table>
<pre><code data-language="javascript">
	var a = ['A', 'B', 'C'];
	a.forEach(function (element, index, array) {
		// element: 指向当前元素的值
		// index: 指向当前索引
		// array: 指向Array对象本身
	alert(element);
	});
</code></pre>
				</span></li>
			</ul>
		</div>
	</div>
</div>