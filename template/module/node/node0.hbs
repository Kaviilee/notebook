<!-- 全局对象、事件 -->
<div class="u-col">
    <div class="u-block">
        <h3>global<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>-</span>] global变量</h4>
            <ul>
                <li>
                    <a href="">global</a>
                    <span>
                        全局对象
                    </span>
                </li>
                <li>
                    <a href="">module</a>
                    <span>
                        对当前模块的引用 <br>
                        全局变量在所有模块中均可使用，但以下变量的作用域只在模块内
                    </span>
                </li>
                <li>
                    <a href="">__filename</a>
                    <span>
                        当前正在执行的脚本的文件名，它将输出文件所在位置的绝对路径 <br>
                        如果在模块中，返回的值是模块文件的路径。
                    </span>
                </li>
                <li>
                    <a href="">__dirname</a>
                    <span>
                        表示当前执行脚本所在的目录
                    </span>
                </li>
                <li>
                    <a href="">exports</a>
                    <span>
                        这是一个对于 module.exports 的更简短的引用形式 <br>
                        如果一个新的值被赋值给 exports，它就不再绑定到 module.exports <br>
                        但如果是对exports.prop进行赋值，则依然当做module.exports.prop输出 <br>
                        当 module.exports 属性被一个新的对象完全替代时，也会重新赋值 exports
                    </span>
                </li>
                <li>
                    <a href="">require</a>(mod)
                    <span>
                        引入模块 <br>
                        缓存 > 原生模块 > 文件模块 > node_modules > 全局目录
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] module对象</h4>
            <ul style="display:none;">
                <li>
                    module.<a href="">exports</a>
                    <span>
                        模块对外输出 <br>
                        单个函数输出，需要 module.exports = fn(){} <br>
                        作为对象输出，可以exports.prop = fn(){} <br>
                        或者 module.exports = $obj
                    </span>
                </li>
                <li>
                    module.<a href="">children</a>
                    <span>
                        被该模块引用的模块对象，返回数组 <br>
                        不会包括内置对象
                    </span>
                </li>
                <li>
                    module.<a href="">parent</a>
                    <span>
                        最先引用该模块的模块
                    </span>
                </li>
                <li>
                    module.<a href="">id</a>
                    <span>
                        模块的标识符。 通常是完全解析后的文件名 <br>
                        被引入的模块，同__filename
                    </span>
                </li>
                <li>
                    module.<a href="">filename</a>
                    <span>
                        模块的完全解析后的文件名
                    </span>
                </li>
                <li>
                    module.<a href="">loaded</a>
                    <span>
                        模块是否已经加载完成，或正在加载中
                    </span>
                </li>
                <li>
                    module.<a href="">paths</a>
                    <span>
                        模块的搜索路径,返回数组
                    </span>
                </li>
                <li>
                    require.<a href="">cache</a>
                    <span>
                        被引入的模块将被缓存在这个对象中。从此对象中删除键值对将会导致下一次 require 重新加载被删除的模块。
                    </span>
                </li>
                <li>
                    require.<a href="">main</a>
                    <span>
                        当 Node.js 直接运行一个文件时，require.main 会被设为它的 module。 这意味着可以通过 require.main === module 来判断一个文件是否被直接运行 <br>
                        通过检查 require.main.filename 来获取当前应用程序的入口点
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] timers</h4>
            <ul>
                <li>
                    <a href="">setImmediate</a>(fn,[arg])
                    <span>
                        预定立即执行的 callback，它是在 I/O 事件的回调之后被触发。 <br>
                        当多次调用 setImmediate() 时，callback 函数会按照它们被创建的顺序依次执行。 每次事件循环迭代都会处理整个回调队列。 如果一个立即定时器是被一个正在执行的回调排入队列的，则该定时器直到下一次事件循环迭代才会被触发。
                    </span>
                </li>
                <li>
                    <a href="">clearImmediate</a>(immediate)
                    <span>
                        取消一个由 setImmediate() 创建的 Immediate 对象。
                    </span>
                </li>
                <li>
                    <a href="">setInterval</a>(fn,delay,[arg])
                    <span>
                        预定每隔 delay 毫秒重复执行的 callback。
                    </span>
                </li>
                <li>
                    <a href="">clearInterval</a>(timeout)
                    <span>
                        取消一个由 setInterval() 创建的 Timeout 对象。
                    </span>
                </li>
                <li>
                    <a href="">setTimeout</a>(fn,delay,[arg])
                    <span>
                        预定在 delay 毫秒之后执行的单次 callback。
                    </span>
                </li>
                <li>
                    <a href="">clearTimeout</a>(timeout)
                    <span>
                        取消一个由 setTimeout() 创建的 Timeout 对象。
                    </span>
                </li>
                <li>
                    <a href="">timeout.ref()</a>
                    <span>
                        调用时，只要 Timeout 处于活动状态就要求 Node.js 事件循环不要退出。<br>
                        返回 Timeout 的一个引用。
                    </span>
                </li>
                <li>
                    <a href="">timeout.unref()</a>
                    <span>
                        当调用时，活动的 Timeout 对象不要求 Node.js 事件循环保持活动。 <br>
                        返回对 Timeout 的一个引用。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] console</h4>
            <ul style="display:none;">
                <li>
                    <a href="">new Console</a>(stdout,[stderr])
                    <span>
                        通过传入一个或两个可写流实例，创建一个新的 Console 对象。 stdout 是一个可写流，用于打印日志或输出信息。 stderr 用于输出警告或错误。 如果没有传入 stderr ，则警告或错误输出会被发送到 stdout 。
                    </span>
                </li>
                <li>
                    console.<a href="">log/info</a>([data,..])
                    <span>
                        打印到 stdout，并带上换行符。
                    </span>
                </li>
                <li>
                    console.<a href="">error/warn</a>([data,..])
                    <span>
                        打印到 stderr，并带上换行符。 
                    </span>
                </li>
                <li>
                    console.<a href="">dir</a>(obj,[opt])
                    <span>
                        在 obj 上使用 util.inspect() 并打印结果字符串到 stdout。  <hr>
                        showHidden - 如果为 true，则该对象中的不可枚举属性和 symbol 属性也会显示。默认为 false。 <br>
                        depth - 告诉 util.inspect() 函数当格式化对象时要递归多少次。 这对于检查较大的复杂对象很有用。 默认为 2。 设为 null 可无限递归。<br>
                        colors - 如果为 true，则输出会带有 ANSI 颜色代码。 默认为 false。 颜色是可定制的，详见定制 util.inspect() 颜色。
                    </span>
                </li>
                <li>
                    console.<a href="">time</a>(label)
                    <span>
                        启动一个定时器，用以计算一个操作的持续时间。 定时器由一个唯一的 label 标识。 当调用 console.timeEnd() 时，可以使用相同的 label 来停止定时器，并以毫秒为单位将持续时间输出到 stdout。 定时器持续时间精确到亚毫秒。
                    </span>
                </li>
                <li>
                    console.<a href="">timeEnd</a>(label)
                    <span>
                        停止之前通过调用 console.time() 启动的定时器，并打印结果到 stdout
                    </span>
                </li>
                <li>
                    console.<a href="">count</a>([label])
                    <span>
                        维护一个指定 label 的内部计数器并且输出到 stdout 指定 label 调用 console.count() 的次数。label计数器的显示标签，默认为 'default'。
                    </span>
                </li>
                <li>
                    console.<a href="">countRest</a>([label])
                    <span>
                        重置指定 label 的内部计数器。
                    </span>
                </li>
                <li>
                    console.<a href="">group</a>([label])
                    <span>
                        将后续行的缩进增加两个空格。
                    </span>
                </li>
                <li>
                    console.<a href="">groupEnd()</a>
                    <span>
                        将后续行的缩进减少两个空格。
                    </span>
                </li>
                <li>
                    console.<a href="">clear()</a>
                    <span>
                        当 stdout 是一个 TTY 时，调用 console.clear() 将尝试清除 TTY。 当 stdout 不是一个TTY时，该方法什么都不做。
                    </span>
                </li>
                <li>
                    console.<a href="">assert</a>(val,[msg,..])
                    <span>
                        一个简单的断言测试，验证 value 是否为真。 如果不为真，则抛出 AssertionError。
                    </span>
                </li>
                <li>
                    console.<a href="">trace</a>([msg,..])
                    <span>
                        打印字符串 'Trace :' 到 stderr ，并通过 util.format() 格式化消息与堆栈跟踪在代码中的当前位置。
                    </span>
                </li>
            </ul>
        </div>
    </div>
    <div class="u-block">
        <h3>events<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>+</span>] EventEmitter类</h4>
            <ul style="display:none;">
                <li>
                    <a href="">var EventEmitter = require('events')</a>
                    <span>
                        引入events模块，得到EventEmitter类
                    </span>
                </li>
                <li>
                    <a href="">class $EMT extends EventEmitter {}</a>
                    <span>
                        需要监听事件的对象，继承事件对象 <br>
                        大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。
                    </span>
                </li>
                <li>
                    <a href="">var evt = new $EMT()</a>
                    <span>
                        创建一个EventEmitter 实例
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 添加/移除/触发监听器</h4>
            <ul>
                <li>
                    eet.<a href="">on</a>(evt,listener)
                    <span>
                        绑定事件及事件处理程序 <br>
                        也可以写作eet.addListener(evt,fn) <br>
                        一个事件可以有多个监听器，但参数应是一致的，否则应作为多个事件处理
                        <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">prependListener</a>(evt,listener)
                    <span>
                        添加 listener 函数到名为 eventName 的事件的监听器数组的开头。 <br>
                        不会检查 listener 是否已被添加。 多次调用并传入相同的 eventName 和 listener 会导致 listener 被添加与调用多次。
                        <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">once</a>(evt,listener)
                    <span>
                        为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器。 <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">prependOnceListener</a>(evt,listener)
                    <span>
                        添加一个单次 listener 函数到名为 eventName 的事件的监听器数组的开头。 <br> 下次触发 eventName 事件时，监听器会被移除，然后调用。
                        <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">removeListener</a>(evt,listener)
                    <span>
                        移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。 <br>
                        removeListener 最多只会从监听器数组里移除一个监听器实例。 如果任何单一的监听器被多次添加到指定 eventName 的监听器数组中，则必须多次调用 removeListener 才能移除每个实例。 <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">removeAllListeners</a>([evt])
                    <span>
                        移除全部或指定 eventName 的监听器。 <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">emit</a>(evt,[arg])
                    <span>
                        触发事件 <br>
                        arg为监听器回调函数传入的参数，同一个事件下的监听器应使用同样的参数 <hr>
                        返回值：布尔值，如果事件有监听器，则返回 true ，否则返回 false。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 内置事件</h4>
            <ul style="display:none;">
                <li>
                    [evt]<a href="">newListener</a>
                    <span>
                        EventEmitter 实例会在一个监听器被添加到其内部监听器数组之前触发自身的 'newListener' 事件。
                    </span>
                </li>
                <li>
                    [evt]<a href="">removeListener</a>
                    <span>
                        'removeListener' 事件在 listener 被移除后触发。
                    </span>
                </li>
                <li>
                    [evt]<a href="">error</a>
                    <span>
                        我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 其它属性/方法</h4>
            <ul style="display:none;">
                <li>
                    eet.<a href="">eventNames()</a>
                    <span>
                        列出触发器上所有绑定的事件，返回一个数组。
                    </span>
                </li>
                <li>
                    eet.<a href="">getMaxListeners()</a>
                    <span>
                        返回 EventEmitter 当前的最大监听器限制值，默认10
                    </span>
                </li>
                <li>
                    eet.<a href="">setMaxListeners</a>(n)
                    <span>
                        值设为 Infinity（或 0）表明不限制监听器的数量。 <br>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">listenerCount</a>(evt)
                    <span>
                        返回指定事件的监听器的数量
                    </span>
                </li>
                <li>
                    eet.<a href="">listeners</a>(evt)
                    <span>
                        返回指定事件的监听器数组的副本
                    </span>
                </li>
            </ul>
        </div>
    </div>
    <div class="u-block">
        <h3>process<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>+</span>] 事件</h4>
            <ul style="display:none">
                <li>
                    [evt]<a href="">exit</a>(exitCode)
                    <span>
                        显式调用process.exit()方法，使得Node.js进程即将结束； <br>
                        Node.js事件循环数组中不再有额外的工作，使得Node.js进程即将结束 <hr>
                        'exit'事件监听器的回调函数，只有一个入参，这个参数的值可以是process.exitCode的属性值，或者是调用process.exit()方法时传入的exitCode值。 <hr>
                        'exit'事件监听器的回调函数，只允许包含同步操作。所有监听器的回调函数被调用后，任何在事件循环数组中排队的工作都会被强制丢弃，然后Nodje.js进程会立即结束。 例如回调中的timeout操作永远不会被执行(因为不是同步操作)。 <hr>
                        <a href="http://www.runoob.com/nodejs/nodejs-global-object.html">退出状态码参考资料</a>
                    </span>
                </li>
                <li>
                    [evt]<a href="">beforeExit</a>(exitCode)
                    <span>
                        当Node.js的事件循环数组已经为空，并且没有额外的工作被添加进来，事件'beforeExit'会被触发。 <br>
                        process.exitCode 作为唯一的参数值传递给'beforeExit'事件监听器的回调函数。  <hr>
                        正常情况下，如果没有额外的工作被添加到事件循环数组，Node.js进程会结束。但是如果'beforeExit'事件绑定的监听器的回调函数中，含有一个可以进行异步调用的操作，那么Node.js进程会继续运行。 <br>
                        如果进程由于显式的原因而将要终止，例如直接调用process.exit()或抛出未捕获的异常，'beforeExit'事件不会被触发。
                    </span>
                </li>
                <li>
                    [evt]<a href="">uncaughtException</a>(err)
                    <span>
                        如果Javascript未捕获的异常，沿着代码调用路径反向传递回event loop，会触发'uncaughtException'事件。 Node.js默认情况下会将这些异常堆栈打印到stderr 然后进程退出。 为'uncaughtException'事件增加监听器会覆盖上述默认行为。
                    </span>
                </li>
                <li>
                    [evt]<a href="">Signal Events</a>
                    <span>
                        当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。 <br>
                        <a href="http://man7.org/linux/man-pages/man7/signal.7.html">参考资料</a>
                    </span>
                </li>
                <li>
                    [evt]<a href="">disconnect</a>
                    <span>
                        如果Node.js进程是由IPC channel的方式创建的，当IPC channel关闭时，会触发'disconnect'事件。
                    </span>
                </li>
                <li>
                    [evt]<a href="">message</a>(msg,sendHanle)
                    <span>
                        如果Node.js进程是由IPC channel的方式创建的，当子进程收到父进程的的消息时(消息通过childprocess.send()发送）， 会触发'message'事件。 <hr>
                        'message'事件监听器的回调函数中被传递的参数如下： <br>
                        message - 解析的JSON对象，或primitive值。 <br>
                        sendHandle - 一个net.Socket 或 net.Server对象，或undefined。
                    </span>
                </li>
                <li>
                    [evt]<a href="">rejectionHandled</a>
                    <span>
                        如果有Promise被rejected，并且此Promise在Nodje.js事件循环的下次轮询及之后期间，被绑定了一个错误处理器[例如使用promise.catch()][])， 会触发'rejectionHandled'事件。 <hr>
                        <a href="http://nodejs.cn/api/process.html#process_event_rejectionhandled">参考资料</a>
                    </span>
                </li>
                <li>
                    [evt]<a href="">unhandledRejection</a>
                    <span>
                        <a href="http://nodejs.cn/api/process.html#process_event_unhandledrejection">参考资料</a>
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 基本属性</h4>
            <ul>
                <li>
                    process.<a href="">stdout</a>
                    <span>
                        标准输出流
                    </span>
                </li>
                <li>
                    process.<a href="">stderr</a>
                    <span>
                        标准错误流
                    </span>
                </li>
                <li>
                    process.<a href="">stdin</a>
                    <span>
                        标准输入流
                    </span>
                </li>
                <li>
                    process.<a href="">exitCode</a>
                    <span>
                        进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 常用方法</h4>
            <ul>
                <li>
                    process.<a href="">chdir</a>(dir)
                    <span>
                        改变当前工作进程的目录，如果操作失败抛出异常。
                    </span>
                </li>
                <li>
                    process.<a href="">cwd()</a>
                    <span>
                        返回当前进程的工作目录
                    </span>
                </li>
                <li>
                    process.<a href="">nextTick</a>(callback,[args])
                    <span>
                        一旦当前事件循环结束，调用回到函数
                    </span>
                </li>
                <li>
                    process.<a href="">abort()</a>
                    <span>
                        这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。 
                    </span>
                </li>
                <li>
                    process.<a href="">exit</a>([code])
                    <span>
                        使用指定的 code 结束进程。如果忽略，将会使用 code 0。
                    </span>
                </li>
                <li>
                    process.<a href="">kill</a>(pid,[signal])
                    <span>
                        发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 'SIGINT' 或 'SIGHUP'。如果忽略，信号会是 'SIGTERM'。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 进程环境</h4>
            <ul style="display:none">
                <li>
                    process.<a href="">argv</a>
                    <span>
                        argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。 <br> 
                        它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。
                    </span>
                </li>
                <li>
                    process.<a href="">argv0</a>
                    <span>
                        v6.4+ <br>
                        保存Node.js启动时传入的argv[0]参数值的一份只读副本
                    </span>
                </li>
                <li>
                    process.<a href="">execPath</a>
                    <span>
                        返回执行当前脚本的 Node 二进制文件的绝对路径
                    </span>
                </li>
                <li>
                    process.<a href="">execArgv</a>
                    <span>
                        返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。
                    </span>
                </li>
                <li>
                    process.<a href="">env</a>
                    <span>
                        返回一个对象，成员为当前 shell 的环境变量
                    </span>
                </li>
                <li>
                    process.<a href="">version</a>
                    <span>
                        Node 的版本
                    </span>
                </li>
                <li>
                    process.<a href="">versions</a>
                    <span>
                        一个属性，包含了 node 的版本和依赖.
                    </span>
                </li>
                <li>
                    process.<a href="">config</a>
                    <span>
                        一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 "config.gypi" 文件相同。
                    </span>
                </li>
                <li>
                    process.<a href="">pid</a>
                    <span>
                        当前进程的进程号
                    </span>
                </li>
                <li>
                    process.<a href="">title</a>
                    <span>
                        进程名
                    </span>
                </li>
                <li>
                    process.<a href="">arch</a>
                    <span>
                        当前 CPU 的架构：'arm'、'ia32' 或者 'x64'。
                    </span>
                </li>
                <li>
                    process.<a href="">platform</a>
                    <span>
                        运行程序所在的平台系统 'darwin', 'freebsd', 'linux', 'sunos' 或 'win32'
                    </span>
                </li>
                <li>
                    process.<a href="">mainModule</a>
                    <span>
                        require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 关联控制</h4>
            <ul style="display:none">
                <li>
                    process.<a href="">umask</a>([mask])
                    <span>
                        设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。
                    </span>
                </li>
                <li>
                    process.<a href="">channel</a>
                    <span>
                        如果Node.js进程是由IPC channel方式创建的，process.channel属性保存IPC channel的引用。 如果IPC channel不存在，此属性值为`undefined。
                    </span>
                </li>
                <li>
                    process.<a href="">connected</a>
                    <span>
                        如果Node.js进程是由IPC channel方式创建的， 只要IPC channel保持连接，process.connected属性就会返回true。 process.disconnect()被调用后，此属性会返回false。 <br>
                        process.connected如果为false，则不能通过IPC channel使用process.send()发送信息。
                    </span>
                </li>
                <li>
                    process.<a href="">disconnect()</a>
                    <span>
                        关闭到父进程的IPC频道，以允许子进程一旦没有其他链接来保持活跃就优雅地关闭。
                    </span>
                </li>
                <li>
                    process.<a href="">send</a>(msg,{},fn)
                    <span>
                        给父进程发送消息
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 性能相关</h4>
            <ul style="display:none">
                <li>
                    process.<a href="">memoryUsage()</a>
                    <span>
                        返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。
                    </span>
                </li>
                <li>
                    process.<a href="">cpuUsage</a>([previousValue])
                    <span>
                        v6.1+ <br>
                        返回包含当前进程的用户CPU时间和系统CPU时间的对象
                    </span>
                </li>
                <li>
                    process.<a href="">uptime()</a>
                    <span>
                        返回 Node 已经运行的秒数
                    </span>
                </li>
                <li>
                    process.<a href="">hrtime()</a>
                    <span>
                        返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] POSIX权限</h4>
            <ul style="display:none">
                <li>
                    process.<a href="">getgid()</a>
                    <span>
                        获取进程的群组标识。获取到得时群组的数字 id，而不是名字。 <br>
                        注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。
                    </span>
                </li>
                <li>
                    process.<a href="">setgid</a>(id)
                    <span>
                        设置进程的群组标识.可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。<br>
                        注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。
                    </span>
                </li>
                <li>
                    process.<a href="">getuid()</a>
                    <span>
                        获取进程的用户标识。这是数字的用户 id，不是用户名。<br>
                        注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。
                    </span>
                </li>
                <li>
                    process.<a href="">setuid</a>(id)
                    <span>
                        设置进程的用户标识。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。<br>
                        注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。
                    </span>
                </li>
                <li>
                    process.<a href="">getgroups()</a>
                    <span>
                        返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。<br>
                        注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。
                    </span>
                </li>
                <li>
                    process.<a href="">setgroups</a>(groups)
                    <span>
                        设置进程的群组 ID。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。<br>
                        注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。
                    </span>
                </li>
                <li>
                    process.<a href="">initgroups</a>(user,extra_group)
                    <span>
                        读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所有你需要有 root 权限，或者有 CAP_SETGID 能力。<br>
                        注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。
                    </span>
                </li>
            </ul>
        </div>
    </div>
</div>