<!-- 全局对象、事件 -->
<div class="u-col">
    <div class="u-block">
        <h3>global<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>-</span>] global变量</h4>
            <ul>
                <li>
                    <a href="">global</a>
                    <span>
                        全局对象
                    </span>
                </li>
                <li>
                    <a href="">module</a>
                    <span>
                        对当前模块的引用 <br>
                        全局变量在所有模块中均可使用，但以下变量的作用域只在模块内
                    </span>
                </li>
                <li>
                    <a href="">__filename</a>
                    <span>
                        当前正在执行的脚本的文件名，它将输出文件所在位置的绝对路径 <br>
                        如果在模块中，返回的值是模块文件的路径。
                    </span>
                </li>
                <li>
                    <a href="">__dirname</a>
                    <span>
                        表示当前执行脚本所在的目录
                    </span>
                </li>
                <li>
                    <a href="">exports</a>
                    <span>
                        这是一个对于 module.exports 的更简短的引用形式 <br>
                        如果一个新的值被赋值给 exports，它就不再绑定到 module.exports <br>
                        但如果是对exports.prop进行赋值，则依然当做module.exports.prop输出 <br>
                        当 module.exports 属性被一个新的对象完全替代时，也会重新赋值 exports
                    </span>
                </li>
                <li>
                    <a href="">require</a>(mod)
                    <span>
                        引入模块 <br>
                        缓存 > 原生模块 > 文件模块 > node_modules > 全局目录
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] module对象</h4>
            <ul style="display:none;">
                <li>
                    module.<a href="">exports</a>
                    <span>
                        模块对外输出 <br>
                        单个函数输出，需要 module.exports = fn(){} <br>
                        作为对象输出，可以exports.prop = fn(){} <br>
                        或者 module.exports = $obj
                    </span>
                </li>
                <li>
                    module.<a href="">children</a>
                    <span>
                        被该模块引用的模块对象，返回数组 <br>
                        不会包括内置对象
                    </span>
                </li>
                <li>
                    module.<a href="">parent</a>
                    <span>
                        最先引用该模块的模块
                    </span>
                </li>
                <li>
                    module.<a href="">id</a>
                    <span>
                        模块的标识符。 通常是完全解析后的文件名 <br>
                        被引入的模块，同__filename
                    </span>
                </li>
                <li>
                    module.<a href="">filename</a>
                    <span>
                        模块的完全解析后的文件名
                    </span>
                </li>
                <li>
                    module.<a href="">loaded</a>
                    <span>
                        模块是否已经加载完成，或正在加载中
                    </span>
                </li>
                <li>
                    module.<a href="">paths</a>
                    <span>
                        模块的搜索路径,返回数组
                    </span>
                </li>
                <li>
                    require.<a href="">cache</a>
                    <span>
                        被引入的模块将被缓存在这个对象中。从此对象中删除键值对将会导致下一次 require 重新加载被删除的模块。
                    </span>
                </li>
                <li>
                    require.<a href="">main</a>
                    <span>
                        当 Node.js 直接运行一个文件时，require.main 会被设为它的 module。 这意味着可以通过 require.main === module 来判断一个文件是否被直接运行 <br>
                        通过检查 require.main.filename 来获取当前应用程序的入口点
                    </span>
                </li>
            </ul>
        </div>
    </div>
    <div class="u-block">
        <h3>events<span>-</span></h3>
        <div class="u-list">
            <h4>[<span>-</span>] EventEmitter类</h4>
            <ul>
                <li>
                    <a href="">var EventEmitter = require('events')</a>
                    <span>
                        引入events模块，得到EventEmitter类
                    </span>
                </li>
                <li>
                    <a href="">class $EMT extends EventEmitter {}</a>
                    <span>
                        需要监听事件的对象，继承事件对象 <br>
                        大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。
                    </span>
                </li>
                <li>
                    <a href="">var evt = new $EMT()</a>
                    <span>
                        创建一个EventEmitter 实例
                    </span>
                </li>
            </ul>
            <h4>[<span>-</span>] 添加/移除/触发监听器</h4>
            <ul>
                <li>
                    eet.<a href="">on</a>(evt,listener)
                    <span>
                        绑定事件及事件处理程序 <br>
                        也可以写作eet.addListener(evt,fn) <br>
                        一个事件可以有多个监听器，但参数应是一致的，否则应作为多个事件处理
                        <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">prependListener</a>(evt,listener)
                    <span>
                        添加 listener 函数到名为 eventName 的事件的监听器数组的开头。 <br>
                        不会检查 listener 是否已被添加。 多次调用并传入相同的 eventName 和 listener 会导致 listener 被添加与调用多次。
                        <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">once</a>(evt,listener)
                    <span>
                        为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器。 <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">prependOnceListener</a>(evt,listener)
                    <span>
                        添加一个单次 listener 函数到名为 eventName 的事件的监听器数组的开头。 <br> 下次触发 eventName 事件时，监听器会被移除，然后调用。
                        <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">removeListener</a>(evt,listener)
                    <span>
                        移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。 <br>
                        removeListener 最多只会从监听器数组里移除一个监听器实例。 如果任何单一的监听器被多次添加到指定 eventName 的监听器数组中，则必须多次调用 removeListener 才能移除每个实例。 <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">removeAllListeners</a>([evt])
                    <span>
                        移除全部或指定 eventName 的监听器。 <hr>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">emit</a>(evt,[arg])
                    <span>
                        触发事件 <br>
                        arg为监听器回调函数传入的参数，同一个事件下的监听器应使用同样的参数 <hr>
                        返回值：布尔值，如果事件有监听器，则返回 true ，否则返回 false。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 内置事件</h4>
            <ul style="display:none;">
                <li>
                    [evt]<a href="">newListener</a>
                    <span>
                        EventEmitter 实例会在一个监听器被添加到其内部监听器数组之前触发自身的 'newListener' 事件。
                    </span>
                </li>
                <li>
                    [evt]<a href="">removeListener</a>
                    <span>
                        'removeListener' 事件在 listener 被移除后触发。
                    </span>
                </li>
                <li>
                    [evt]<a href="">error</a>
                    <span>
                        我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。
                    </span>
                </li>
            </ul>
            <h4>[<span>+</span>] 其它属性/方法</h4>
            <ul style="display:none;">
                <li>
                    eet.<a href="">eventNames()</a>
                    <span>
                        列出触发器上所有绑定的事件，返回一个数组。
                    </span>
                </li>
                <li>
                    eet.<a href="">getMaxListeners()</a>
                    <span>
                        返回 EventEmitter 当前的最大监听器限制值，默认10
                    </span>
                </li>
                <li>
                    eet.<a href="">setMaxListeners</a>(n)
                    <span>
                        值设为 Infinity（或 0）表明不限制监听器的数量。 <br>
                        返回值：返回一个 EventEmitter 引用，可以链式调用。
                    </span>
                </li>
                <li>
                    eet.<a href="">listenerCount</a>(evt)
                    <span>
                        返回指定事件的监听器的数量
                    </span>
                </li>
                <li>
                    eet.<a href="">listeners</a>(evt)
                    <span>
                        返回指定事件的监听器数组的副本
                    </span>
                </li>
            </ul>
        </div>
    </div>
</div>